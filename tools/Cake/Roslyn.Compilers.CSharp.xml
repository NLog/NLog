<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Roslyn.Compilers.CSharp</name>
    </assembly>
    <members>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxVisitor`1">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> visitor that visits only the single SyntaxNode
            passed into its <see cref="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.Visit(Roslyn.Compilers.CSharp.SyntaxNode)"/> method and produces 
            a value of the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="TResult">
            The type of the return value this visitor's Visit method.
            </typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIdentifierName(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQualifiedName(Roslyn.Compilers.CSharp.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGenericName(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeArgumentList(Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAliasQualifiedName(Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPredefinedType(Roslyn.Compilers.CSharp.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayRankSpecifier(Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNullableType(Roslyn.Compilers.CSharp.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOmittedTypeArgument(Roslyn.Compilers.CSharp.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParenthesizedExpression(Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPrefixUnaryExpression(Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPostfixUnaryExpression(Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMemberAccessExpression(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBinaryExpression(Roslyn.Compilers.CSharp.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConditionalExpression(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitThisExpression(Roslyn.Compilers.CSharp.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBaseExpression(Roslyn.Compilers.CSharp.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLiteralExpression(Roslyn.Compilers.CSharp.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMakeRefExpression(Roslyn.Compilers.CSharp.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRefTypeExpression(Roslyn.Compilers.CSharp.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRefValueExpression(Roslyn.Compilers.CSharp.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCheckedExpression(Roslyn.Compilers.CSharp.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDefaultExpression(Roslyn.Compilers.CSharp.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeOfExpression(Roslyn.Compilers.CSharp.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSizeOfExpression(Roslyn.Compilers.CSharp.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElementAccessExpression(Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArgumentList(Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBracketedArgumentList(Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArgument(Roslyn.Compilers.CSharp.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNameColon(Roslyn.Compilers.CSharp.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCastExpression(Roslyn.Compilers.CSharp.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAnonymousMethodExpression(Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSimpleLambdaExpression(Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInitializerExpression(Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitObjectCreationExpression(Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAnonymousObjectMemberDeclarator(Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitStackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQueryExpression(Roslyn.Compilers.CSharp.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQueryBody(Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFromClause(Roslyn.Compilers.CSharp.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLetClause(Roslyn.Compilers.CSharp.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitJoinClause(Roslyn.Compilers.CSharp.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitJoinIntoClause(Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWhereClause(Roslyn.Compilers.CSharp.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOrderByClause(Roslyn.Compilers.CSharp.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOrdering(Roslyn.Compilers.CSharp.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSelectClause(Roslyn.Compilers.CSharp.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGroupClause(Roslyn.Compilers.CSharp.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitQueryContinuation(Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOmittedArraySizeExpression(Roslyn.Compilers.CSharp.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGlobalStatement(Roslyn.Compilers.CSharp.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBlock(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLocalDeclarationStatement(Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitVariableDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitVariableDeclarator(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEqualsValueClause(Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExpressionStatement(Roslyn.Compilers.CSharp.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEmptyStatement(Roslyn.Compilers.CSharp.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLabeledStatement(Roslyn.Compilers.CSharp.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitGotoStatement(Roslyn.Compilers.CSharp.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBreakStatement(Roslyn.Compilers.CSharp.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitContinueStatement(Roslyn.Compilers.CSharp.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitReturnStatement(Roslyn.Compilers.CSharp.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitThrowStatement(Roslyn.Compilers.CSharp.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitYieldStatement(Roslyn.Compilers.CSharp.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWhileStatement(Roslyn.Compilers.CSharp.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDoStatement(Roslyn.Compilers.CSharp.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitForStatement(Roslyn.Compilers.CSharp.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitForEachStatement(Roslyn.Compilers.CSharp.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUsingStatement(Roslyn.Compilers.CSharp.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFixedStatement(Roslyn.Compilers.CSharp.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCheckedStatement(Roslyn.Compilers.CSharp.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUnsafeStatement(Roslyn.Compilers.CSharp.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLockStatement(Roslyn.Compilers.CSharp.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIfStatement(Roslyn.Compilers.CSharp.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElseClause(Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchStatement(Roslyn.Compilers.CSharp.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchSection(Roslyn.Compilers.CSharp.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSwitchLabel(Roslyn.Compilers.CSharp.SwitchLabelSyntax)">
            <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTryStatement(Roslyn.Compilers.CSharp.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCatchClause(Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCatchDeclaration(Roslyn.Compilers.CSharp.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFinallyClause(Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitCompilationUnit(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExternAliasDirective(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUsingDirective(Roslyn.Compilers.CSharp.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNamespaceDeclaration(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeList(Roslyn.Compilers.CSharp.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeTargetSpecifier(Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttribute(Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeArgumentList(Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAttributeArgument(Roslyn.Compilers.CSharp.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitNameEquals(Roslyn.Compilers.CSharp.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameterList(Roslyn.Compilers.CSharp.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitClassDeclaration(Roslyn.Compilers.CSharp.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitStructDeclaration(Roslyn.Compilers.CSharp.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitInterfaceDeclaration(Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEnumDeclaration(Roslyn.Compilers.CSharp.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDelegateDeclaration(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEnumMemberDeclaration(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBaseList(Roslyn.Compilers.CSharp.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeParameterConstraintClause(Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorConstraint(Roslyn.Compilers.CSharp.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitClassOrStructConstraint(Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitTypeConstraint(Roslyn.Compilers.CSharp.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitFieldDeclaration(Roslyn.Compilers.CSharp.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEventFieldDeclaration(Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitMethodDeclaration(Roslyn.Compilers.CSharp.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitOperatorDeclaration(Roslyn.Compilers.CSharp.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConversionOperatorDeclaration(Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorDeclaration(Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDestructorDeclaration(Roslyn.Compilers.CSharp.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPropertyDeclaration(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEventDeclaration(Roslyn.Compilers.CSharp.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIndexerDeclaration(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAccessorList(Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitAccessorDeclaration(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParameterList(Roslyn.Compilers.CSharp.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBracketedParameterList(Roslyn.Compilers.CSharp.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitParameter(Roslyn.Compilers.CSharp.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIncompleteMember(Roslyn.Compilers.CSharp.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitSkippedTokensTrivia(Roslyn.Compilers.CSharp.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDocumentationCommentTrivia(Roslyn.Compilers.CSharp.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElement(Roslyn.Compilers.CSharp.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElementStartTag(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlElementEndTag(Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlEmptyElement(Roslyn.Compilers.CSharp.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlName(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlPrefix(Roslyn.Compilers.CSharp.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlAttribute(Roslyn.Compilers.CSharp.XmlAttributeSyntax)">
            <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlText(Roslyn.Compilers.CSharp.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlCDataSection(Roslyn.Compilers.CSharp.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitXmlComment(Roslyn.Compilers.CSharp.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitIfDirectiveTrivia(Roslyn.Compilers.CSharp.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElifDirectiveTrivia(Roslyn.Compilers.CSharp.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitElseDirectiveTrivia(Roslyn.Compilers.CSharp.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEndIfDirectiveTrivia(Roslyn.Compilers.CSharp.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitRegionDirectiveTrivia(Roslyn.Compilers.CSharp.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitEndRegionDirectiveTrivia(Roslyn.Compilers.CSharp.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitErrorDirectiveTrivia(Roslyn.Compilers.CSharp.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitWarningDirectiveTrivia(Roslyn.Compilers.CSharp.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitBadDirectiveTrivia(Roslyn.Compilers.CSharp.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitDefineDirectiveTrivia(Roslyn.Compilers.CSharp.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitUndefDirectiveTrivia(Roslyn.Compilers.CSharp.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitLineDirectiveTrivia(Roslyn.Compilers.CSharp.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPragmaWarningDirectiveTrivia(Roslyn.Compilers.CSharp.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitPragmaChecksumDirectiveTrivia(Roslyn.Compilers.CSharp.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor`1.VisitReferenceDirectiveTrivia(Roslyn.Compilers.CSharp.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BinderFactory.InSpan(Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.TextSpan)">
            <summary>
            Returns true if the location is within the syntax tree and span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BinderFactory.GetImportsBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns binder that binds usings and aliases 
            </summary>
            <param name="unit">
            Specify <see cref="T:Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax"/> imports in the corresponding namespace, or
            <see cref="T:Roslyn.Compilers.CSharp.CompilationUnitSyntax"/> for top-level imports.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BinderFactory.IsInUsing(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns true if containingNode has a child that contains the specified position
            and has kind UsingDirective.
            </summary>
            <remarks>
            Usings can't see other usings, so this is extra info when looking at a namespace
            or compilation unit scope.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EarlyWellKnownAttributeBinder">
            <summary>
            This is a special binder used for decoding some special well-known attributes very early in the attribute binding phase.
            It only binds those attribute argument syntax which can produce valid attribute arguments, but doesn't report any diagnostics.
            Subsequent binding phase will rebind such erroneous attributes and generate appropriate diagnostics.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder">
            <summary>
            This portion of the binder converts a QueryExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder reports errors arising from resolving queries.
            </summary>
            <summary>
            This portion of the binder converts a AnonymousObjectCreationExpressionSyntax into 
            a bound anonymous object creation node
            </summary>
            <summary>
            A Binder converts names in to symbols and syntax nodes into bound trees. It is context
            dependent, relative to a location in source code.
            </summary>
            <summary>
            This portion of the binder converts an ExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder converts StatementSyntax nodes into BoundStatements
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.EnsureInvariantMeaningInScope(Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            <para>Once a simple name has been bound to a particular symbol, we need to ensure that symbol is the
            <em>only</em>
            binding for that simple name in that local scope or any nested local scope.  We do that by constructing a
            data structure that records, for each scope (LocalScopeBinder), the meaning of every simple name used within
            that scope.
            </para>
            <para>
            The "meaning" is recorded in a dictionary in the local scope that is keyed by simple name (string).  The
            meaning records the symbol that was previously found to be the symbol's definition, the location of the
            reference, and a "Direct" flag that distinguishes between references directly within that scope
            (Direct=true), and references that appear somewhere within more deeply nested scopes (Direct=false).  A
            meaning also has a "Reported" boolean flag that is set once a meaning conflict has been reported, to
            suppress duplicate or cascaded diagnostics.
            </para>
            <para>
            The algorithm works as follows: Once a definition or use of a particular symbol is found within a given
            local scope, an entry with Direct=true is made for that symbol.  It is then resolved against any meaning
            already stored for that scope.  Any entry for that name in the scope indicates an error, which is reported.
            If the existing entry was Direct=true, then both symbols were used or defined directly within that scope. In
            that case an error is reported and their "Reported" flags are set to true to supporess any further
            diagnostics. If the existing entry was "Direct=false", then a conflicting reference appeared in a more
            nested scope, and the conflict is reported a the location of the more nested scope; only the more nested's
            "Reported" flag is then set to true.
            </para>
            <para>
            If no entry was found in the innermost local scope, then a separate entry with "Direct=false" is created and
            resolved, one by one, against all enclosing local scopes.  A scope without an existing entry receives a
            reference to this new entry.  A scope with an existing "Direct=false" entry is skipped.  And a scope
            containing a "Direct=true" entry for a different symbol represents a conflict, which is reported at the
            position of the new "Direct=false" reference, which is the more nested scope.  We also set the "Reported"
            flag for the more nested reference.
            </para>
            <para>
            The correctness of this algorithm depends on a subtle condition that doesn't appear explicitly in the code,
            so it is worth calling out.  You might worry about reporting a single-definition rule conflict somewhere
            while processing a trial binding of a lambda which is later discarded.  Where has the diagnostic gone?  If the
            trial binding is discarded but the meaning's "Reported" flag has been set to true, won't we miss reporting
            an error?  In fact, that cannot happen.  This diagnostic is consistently reported during any (sequential)
            compilation of a given method's body, as explained below.  In "speculative" and SemanticModel trial bindings,
            which may occur in the face of concurrency, these diagnostics do not affect the result of the API (the
            diagnostics are discarded).
            </para>
            <para>
            The conflicts that arise from two meanings that are Direct references within the same scope do not cause a
            problem, because the scope and their entries are either both within the same lambda or not within a lambda
            at all.  If they are both within the same lambda, then the diagnostic will be reported each time we attempt
            to bind the innermost lambda body.
            </para>
            <para>
            The more subtle situation is when the conflict arises between a Direct and a !Direct meaning.  The Direct
            meaning represents a definition of a name or a use of a name in an outer scope, and the !Direct meaning
            within a more nested scope.  We always report such conflicts at the location of the more nested scope.  There
            are two cases to consider: either the Direct meaning is recorded in the scope before the !Direct entry, for
            example when we bind code such as
            </para>
            <code>{ int i; { int i; } }</code>
            <para>
            Or the !Direct entry is recorded first, for example in code such as</para>
            <code>{ { int i; } int i; }</code>
            <para>
            Let us first consider the former.  If the more nested reference appears within a lambda, the diagnostic will
            be reported during every binding of the lambda, because every binding introduces a new meaning for the
            nested variable.
            </para>
            <para>
            Let us now consider the latter situation, and consider what happens if the nested reference appears within a
            lambda.  We have the lambda possibly being bound before the outer variable declaration. In that case the
            error is not reported until we bind the outer definition. But now the error is reported outside the lambda
            binder.  The lambda bindings will appear to succeed without errors.
            </para>
            <para>
            The important points to note are that (1) in either case, we report exactly one error for the conflict, and
            (2) it is the same error in both cases, not depending on binding order.  However, in one case the lambda
            binding "fails", while in the other it "succeeds"; this may result in subtle differences observable in the
            SemanticModel API and possibly different suppression of cascaded diagnostics, as is seen in Dev10.  However,
            I have not been able to reproduce these effects in Roslyn
            </para>
            </summary>
            <param name="node">The simple name syntax whose meaning should be invariant within every enclosing
            scope</param>
            <param name="expression">The bound node to which the given simple name resolved</param>
            <param name="diagnostics">A bag into which diagnostics are to be reported</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ExpressionSymbol(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            A symbol referenced by the bound expression for the purpose of ensuring an invariant meaning in a local
            scope.  For a method group, we select one of the methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.EnsureInvariantMeaningInScopeInternal(Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given that we've found a reference to a symbol as a simple name, ensure that it is the only symbol
            associated with that simple name in this scope or any nested scope.
            <para>
            </para>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUnsafe(Roslyn.Compilers.CSharp.Diagnostic,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Add the unsafe diagnostic to the diagnostic bag, as long as it isn't supposed to be
            suppressed for some reason (usually because another one was reported in the same local
            scope).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUnsafeIfNotAllowed(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUnsafeIfNotAllowed(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUnsafeIfNotAllowed(Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUnsafeIfNotAllowed(Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindTypeParameterConstraintClauses(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeParameterSymbol},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Return a collection of bound constraint clauses indexed by type parameter
            ordinal. All constraint clauses are bound, even if there are multiple constraints
            for the same type parameter, or constraints for unrecognized type parameters.
            Extra constraints are not included in the returned collection however.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindTypeParameterConstraints(System.String,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax},Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind and return a single type parameter constraint clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsValidConstraintType(Roslyn.Compilers.CSharp.TypeConstraintSyntax,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Returns true if the type is a valid constraint type.
            Otherwise returns false and generates a diagnostic.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportQueryLookupFailed(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This is a clone of the Dev10 logic for reporting query errors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsAnonymousTypesAllowed(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Actually, defines if an error ERR_AnonymousTypeNotAvailable is to be generated; 
            
            Dev10 rules (which are based on BindingContext::InMethod()) are difficult to 
            reproduce, so this implementation checks both current symbol as well as syntax nodes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetAnonymousTypeFieldType(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Returns the type to be used as a field type; generates errors in case the type is not
            supported for anonymous type fields.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetRewrittenAttributeConstructorArguments(Roslyn.Compilers.ReadOnlyArray{System.Int32}@,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.Common.CommonTypedConstant[],Roslyn.Compilers.ReadOnlyArray{System.String})">
            <summary>
            Gets the rewritten attribute constructor arguments, i.e. the arguments
            are in the order of parameters, which may differ from the source
            if named constructor arguments are used.
            
            For example:
                void Foo(int x, int y, int z, int w = 3);
            
                Foo(0, z: 2, y: 1);
                
                Arguments returned: 0, 1, 2, 3
            </summary>
            <returns>Rewritten attribute constructor arguments</returns>
            <remarks>
            CONSIDER: Can we share some code will call rewriting in the local rewriter?
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MemberGroupFinalValidation(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method implements the algorithm in spec section 7.6.5.1.
            
            For method group conversions, there are situations in which the conversion is
            considered to exist ("Otherwise the algorithm produces a single best method M having
            the same number of parameters as D and the conversion is considered to exist"), but
            application of the conversion fails.  These are the "final validation" steps of
            overload resolution.
            </summary>
            <returns>
            True if there is any error.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.WasImplicitReceiver(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Was the receiver expression compiler-generated?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupIsCompatibleWithDelegate(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method implements the checks in spec section 15.2.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupConversionHasErrors(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.Conversion,Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method combines final validation (section 7.6.5.1) and delegate compatibility (section 15.2).
            </summary>
            <param name="syntax">SyntaxNode of the expression requiring method group conversion.</param>
            <param name="conversion">Conversion to be performed.</param>
            <param name="receiverOpt">Optional receiver.</param>
            <param name="isExtensionMethod">Method invoked as extension method.</param>
            <param name="delegateType">Target delegate type.</param>
            <param name="diagnostics">Where diagnostics should be added.</param>
            <returns>True if a diagnostic has been added.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MethodGroupConversionDoesNotExistOrHasErrors(Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Conversion@)">
            <summary>
            This method is a wrapper around MethodGroupConversionHasErrors.  As a preliminary step,
            it checks whether a conversion exists.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindEventAssignment(Roslyn.Compilers.CSharp.BinaryExpressionSyntax,Roslyn.Compilers.CSharp.BoundEventAccess,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BinaryOperatorKind,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            For "receiver.event += expr", produce "receiver.add_event(expr)".
            For "receiver.event -= expr", produce "receiver.remove_event(expr)".
            </summary>
            <remarks>
            Performs some validation of the accessor that couldn't be done in CheckEventValueKind, because
            the specific accessor wasn't known.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.TryFoldingNullableEquality(Roslyn.Compilers.CSharp.BinaryOperatorKind,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            If one of the (unconverted) operands has constant value null and the other has
            a null constant value other than null, then they are definitely not equal
            and we can give a constant value for either == or !=.  This is a spec violation
            that we retain from Dev10.
            </summary>
            <param name="kind">The operator kind.  Nothing will happen if it is not a lifted equality operator.</param>
            <param name="left">The left-hand operand of the operation (possibly wrapped in a conversion).</param>
            <param name="right">The right-hand operand of the operation (possibly wrapped in a conversion).</param>
            <returns>
            If the operator represents lifted equality, then constant value true if both arguments have constant
            value null, constant value false if exactly one argument has constant value null, and null otherwise.
            If the operator represents lifted inequality, then constant value false if both arguments have constant
            value null, constant value true if exactly one argument has constant value null, and null otherwise.
            </returns>
            <remarks>
            SPEC VIOLATION: according to the spec (section 7.19) constant expressions cannot
            include implicit nullable conversions or nullable subexpressions.  However, Dev10
            specifically folds over lifted == and != (see ExpressionBinder::TryFoldingNullableEquality).
            Dev 10 does do compile-time evaluation of simple lifted operators, but it does so
            in a rewriting pass (see NullableRewriter) - they are not treated as constant values.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsFixedStatementAddressOfExpression(Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax)">
            <remarks>
            The real implementation is in FixedStatementBinder.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindConditionalOperator(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
             <remarks>
             From ExpressionBinder::EnsureQMarkTypesCompatible:
             
             The v2.0 specification states that the types of the second and third operands T and S of a ternary operator
             must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.
            
             Unfortunately that is not what we implemented in v2.0.  Instead, we implemented
             that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the
             convertibility of the expressions, not the types.
            
            
             Changing that to the algorithm in the standard would be a breaking change.
            
             b ? (Func&lt;int&gt;)(delegate(){return 1;}) : (delegate(){return 2;})
            
             and
            
             b ? 0 : myenum
            
             would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to
             any enum but enum doesn't go to int.)
            
             It gets worse.  We would like the 3.0 language features which require type inference to use
             a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best
             of a set of types.  However, the language committee has decided that this algorithm will NOT
             consume information about the convertibility of expressions. Rather, it will gather up all
             the possible types and then pick the "largest" of them.
            
             To maintain backwards compatibility while still participating in the spirit of consistency,
             we implement an algorithm here which picks the type based on expression convertibility, but
             if there is a conflict, then it chooses the larger type rather than producing a type error.
             This means that b?0:myshort will have type int rather than producing an error (because 0->short,
             myshort->int).
             </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.FoldConditionalOperator(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Constant folding for conditional (aka ternary) operators.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Some nodes have special binder's for their contents (like Block's)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetIteratorElementType(Roslyn.Compilers.CSharp.YieldStatementSyntax,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get the element type of this iterator.
            </summary>
            <param name="node">Node to report diagnostics, if any, such as "yield statement cannot be used
            inside a lambda expression"</param>
            <param name="diagnostics">Where to place any diagnostics</param>
            <returns>Element type of the current iterator, or an error type.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportDiagnosticsIfObsolete(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Issue an error or warning for a symbol if it is Obsolete. If there is not enough
            information to report diagnostics, then store the symbols so that diagnostics
            can be reported at a later stage.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUseSiteErrorForSynthesizedAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method reports use site errors if a required attribute member is missing.
            Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
            errors will be ignored.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReportUseSiteErrorForSynthesizedAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This method reports use site errors if a required attribute member is missing.
            Some attributes are considered to be optional (e.g. the CompilerGeneratedAttribute). In this case the use site
            errors will be ignored.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsUnboundTypeAllowed(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>
            Returns true if the node is in a position where an unbound type
            such as (C&lt;,&gt;) is allowed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.NYIExpression(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundNode},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupResultKind,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Generates a new BoundBadExpression to report a not yet implemented error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BadExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundNode[])">
            <summary>
            Generates a new BoundBadExpression with no known type, and the given bound children.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BadExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.LookupResultKind,Roslyn.Compilers.CSharp.BoundNode[])">
            <summary>
            Generates a new BoundBadExpression with no known type, given lookup resultKind and the given bound children.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BadExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.LookupResultKind,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.BoundNode[])">
            <summary>
            Generates a new BoundBadExpression with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound children.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BadExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.LookupResultKind,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression})">
            <summary>
            Generates a new BoundBadExpression with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound children.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ToBadExpression(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Helper method to generate a bound expression with HasErrors set to true.
            Returned bound expression is guaranteed to have a non-null type, except when <paramref name="expr"/> is an unbound lambda.
            If <paramref name="expr"/> already has errors and meets the above type requirements, then it is returned unchanged.
            Otherwise, if <paramref name="expr"/> is a BoundBadExpression, then it is updated with the <paramref name="resultKind"/> and non-null type.
            Otherwise, a new BoundBadExpression wrapping <paramref name="expr"/> is returned. 
            </summary>
            <remarks>
            Returned expression need not be a BoundBadExpression, but is guaranteed to have HasErrors set to true.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindValue(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Binder.BindValueKind)">
            <summary>
            Bind the expression and verify the expression matches the combination of lvalue and
            rvalue requirements given by valueKind. If the expression was bound successfully, but
            did not meet the requirements, the return value will be a BoundBadExpression that
            (typically) wraps the subexpression.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindQualifiedName(Roslyn.Compilers.CSharp.QualifiedNameSyntax,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            This function is only needed for SemanticModel to perform binding for erroneous cases.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindIdentifier(Roslyn.Compilers.CSharp.SimpleNameSyntax,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a simple identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MakeInvocationExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Helper method to create a synthesized method invocation expression.
            </summary>
            <param name="node">Syntax Node.</param>
            <param name="receiver">Receiver for the method call.</param>
            <param name="methodName">Method to be invoked on the receiver.</param>
            <param name="args">Arguments to the method call.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="typeArgsSyntax">Optional type arguments syntax.</param>
            <param name="typeArgs">Optional type arguments.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <returns>Synthesized method invocation expression.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindInvocationExpression(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.String,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.AnalyzedArguments,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindInvocationExpressionContinued(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.String,Roslyn.Compilers.CSharp.OverloadResolutionResult{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.CSharp.AnalyzedArguments,Roslyn.Compilers.CSharp.MethodGroup,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Perform overload resolution on the method group or expression (BoundMethodGroup)
            and arguments and return a BoundExpression representing the invocation.
            </summary>
            <param name="node">Invocation syntax node.</param>
            <param name="expression">The syntax for the invoked method, including receiver.</param>
            <param name="methodName">Name of the invoked method.</param>
            <param name="result">Overload resolution result for method group executed by caller.</param>
            <param name="analyzedArguments">Arguments bound by the caller.</param>
            <param name="methodGroup">Method group if the invocation represents a potentially overloaded member.</param>
            <param name="delegateTypeOpt">Delegate type if method group represents a delegate.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <returns>BoundCall, BoundDelegateCall, or error expression representing the invocation.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ReplaceTypeOrValueReceiver(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Replace a BoundTypeOrValueExpression with a BoundExpression for either a type (if useType is true)
            or a value (if useType is false).  Any other node is unmodified.
            </summary>
            <remarks>
            Call this once overload resolution has succeeded on the method group of which the BoundTypeOrValueExpression
            is the receiver.  Generally, useType will be true if the chosen method is static and false otherwise.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetDelegateType(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Return the delegate type if this expression represents a delegate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetNameSyntax(Roslyn.Compilers.CSharp.SyntaxNode,System.String@)">
            <summary>
            Gets the NameSyntax associated with the syntax node
            If no syntax is attached it sets the nameString to plain text
            name and returns a null NameSyntax
            </summary>
            <param name="syntax">Syntax node</param>
            <param name="nameString">Plain text name</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetName(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Gets the plain text name associated with the the expression syntax node
            </summary>
            <param name="syntax">Expression syntax node</param>
            <returns>Plain text name</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindArrayInitializerExpressions(Roslyn.Compilers.CSharp.InitializerExpressionSyntax,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.DiagnosticBag,System.Int32,System.Int32)">
            <summary>
            This method walks through the array's InitializerExpressionSyntax and binds all the initializer expressions recursively.
            NOTE: It doesn't convert the bound initializer expressions to array's element type.
            NOTE: This is done separately in ConvertAndBindArrayInitialization method below.
            </summary>
            <param name="initializer">Initializer Syntax.</param>
            <param name="exprBuilder">Bound expression builder.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="rank">Rank of the array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ConvertAndBindArrayInitialization(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.InitializerExpressionSyntax,Roslyn.Compilers.CSharp.ArrayTypeSymbol,System.Nullable{System.Int32}[],System.Int32,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},System.Int32@)">
            <summary>
            Given an array of bound initializer expressions, this method converts these bound expressions
            to array's element type and generates a BoundArrayInitialization with the converted initializers.
            </summary>
            <param name="diagnostics">Diagnostics.</param>
            <param name="node">Initializer Syntax.</param>
            <param name="type">Array type.</param>
            <param name="knownSizes">Known array bounds.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="boundInitExpr">Array of bound initializer expressions.</param>
            <param name="boundInitExprIndex">
            Index into the array of bound initializer expressions to fetch the next bound expression.
            </param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol (in source).
            </summary>
            <param name="initializerSyntaxOpt">Null for implicit, SyntaxKind BaseConstructorInitializer or ThisConstructorInitializer for explicit.</param>
            <param name="constructor">Constructor containing the initializer.</param>
            <param name="diagnostics">Accumulates errors (e.g. unable to find constructor to invoke).</param>
            <returns>A bound expression for the constructor initializer call.</returns>
            <remarks>
            This method should be kept consistent with Compiler.BindConstructorInitializer (e.g. same error codes).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.PerformConstructorOverloadResolution(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.MethodSymbol},Roslyn.Compilers.CSharp.AnalyzedArguments,System.String,Roslyn.Compilers.CSharp.Location,System.Boolean,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.MemberResolutionResult{Roslyn.Compilers.CSharp.MethodSymbol}@,System.Boolean)">
            <summary>
            Given a list of constructors, use overload resolution to determine which one should be called.
            </summary>
            <param name="typeContainingConstructors">The containing type of the constructors.</param>
            <param name="constructors">The candidate constructors.</param>
            <param name="analyzedArguments">The already bound arguments to the constructor.</param>
            <param name="methodName">The name of the constructor method.</param>
            <param name="errorLocation">The location at which to report overload resolution result diagnostics.</param>
            <param name="suppressResultDiagnostics">True to suppress overload resolution result diagnostics (but not argument diagnostics).</param>
            <param name="diagnostics">Where diagnostics will be reported.</param>
            <param name="memberResolutionResult">If this method returns true, then it will contain a valid MethodResolutionResult.
            Otherwise, it may contain a MethodResolutionResult for an inaccessible constructor or nothing at all.</param>
            <param name="allowProtectedConstructorsOfBaseType">It is always legal to access a protected base class constructor
            via a constructor initializer, but not from an object creation expression.</param>
            <returns>True if overload resolution successfully chose an accessible constructor.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccess(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a member access expression
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindLeftOfPotentialColorColorMemberAccess(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Attempt to bind the LHS of a member access expression.  If this is a Color Color case (spec 7.6.4.1),
            then return a BoundExpression if we can easily disambiguate or a BoundTypeOrValueExpression if we
            cannot.  If this is not a Color Color case, then return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccessWithBoundLeft(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the RHS of a member access expression, given the bound LHS.
            It is assumed that CheckValue has not been called on the LHS.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.MakeMemberAccessValue(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Create a value from the expression that can be used as a left-hand-side
            of a member access. This method special-cases method and property
            groups only. All other expressions are returned as is.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccessReportError(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.String,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report the error from member access lookup. Or, if there
            was no explicit error from lookup, report "no such member".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberAccessBadResult(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.String,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticInfo,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Return a BoundExpression representing the invalid member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CombineExtensionMethodArguments(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.AnalyzedArguments,Roslyn.Compilers.CSharp.AnalyzedArguments)">
            <summary>
            Combine the receiver and arguments of an extension method
            invocation into a single argument list to allow overload resolution
            to treat the invocation as a static method invocation with no receiver.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindMemberOfType(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.String,System.Int32,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.CSharp.LookupResult,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Binds a static or instance member access.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetSymbolOrMethodOrPropertyGroup(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.SyntaxNode,System.String,System.Int32,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Given a viable LookupResult, report any ambiguity errors and return either a single
            non-method symbol or a method or property group. If the result set represents a
            collection of methods or a collection of properties where at least one of the properties
            is an indexed property, then 'methodOrPropertyGroup' is populated with the method or
            property group and the method returns null. Otherwise, the method returns a single
            symbol and 'methodOrPropertyGroup' is empty. (Since the result set is viable, there
            must be at least one symbol.) If the result set is ambiguous - either containing multiple
            members of different member types, or multiple properties but no indexed properties -
            then a diagnostic is reported for the ambiguity and a single symbol is returned.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ResolveMethodGroup(Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.AnalyzedArguments,System.Boolean)">
            <summary>
            Perform lookup and overload resolution on methods defined directly on the class and any
            extension methods in scope. Lookup will occur for extension methods in all nested scopes
            as necessary until an appropriate method is found. If analyzedArguments is null, the first
            method group is returned, without overload resolution being performed. That method group
            will either be the methods defined on the receiver class directly (no extension methods)
            or the first set of extension methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupSymbols(Roslyn.Compilers.CSharp.LookupResult,System.String,System.Int32,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for any symbols in scope with the given name and arity
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupSymbolsOrMembers(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions,System.Boolean)">
            <summary>
            If qualifierOpt is null, look for any symbols in
            scope with the given name and arity.
            Otherwise look for symbols that are members of the specified qualifierOpt.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupMembers(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for symbols that are members of the specified namespace or type
            </summary>
            <param name="result"></param>
            <param name="nsOrType"></param>
            <param name="name"></param>
            <param name="arity"></param>
            <param name="basesBeingResolved"></param>
            <param name="options"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupMembersInSubmissions(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.TypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions,Roslyn.Compilers.CSharp.Binder,System.Boolean)">
            <summary>
            Lookup a member name in a submission chain.
            </summary>
            <remarks>
            We start with the current submission class and walk the submission chain back to the first submission.
            The search has two phases
            1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.
               If we find and overloadable symbol(s) (a method or an indexer) we start looking for overloads of this kind 
               (lookingForOverloadsOfKind) of symbol in phase 2.
            2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop 
               looking further. Otherwise, if we find viable overload(s) we add them into the result.
               
            Note that indexers are not supported in script but we deal with them here to handle errors.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.LookupAttributeType(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupOptions,System.Boolean,System.Boolean)">
            <summary>
            Lookup attribute name in the given binder. By default two name lookups are performed:
                (1) With the provided name
                (2) With an Attribute suffix added to the provided name
            Lookup with Attribute suffix is performed only if LookupOptions.VerbatimAttributeName is not set.
            
            If either lookup is ambiguous, we return the corresponding result with ambiguous symbols.
            Else if exactly one result is single viable attribute type, we return that result.
            Otherwise, we return a non-viable result with LookupResult.NotAnAttributeType or an empty result.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetCandidateExtensionMethods(System.Boolean,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},System.String,System.Int32,Roslyn.Compilers.CSharp.LookupOptions,System.Boolean)">
            <summary>
            Return the extension methods from this specific binding scope that match the name and optional
            arity. Since the lookup of extension methods is iterative, proceeding one binding scope at a time,
            GetCandidateExtensionMethods should not defer to the next binding scope. Instead, the caller is
            responsible for walking the nested binding scopes from innermost to outermost. This method is overridden
            to search the available members list in binding types that represent types, namespaces, and usings.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsMethodOrIndexer(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            This helper is used to determine whether this symbol hides / is hidden
            based on its signature, as opposed to its name.
            </summary>
            <remarks>
            CONSIDER: It might be nice to generalize this - maybe an extension method
            on Symbol (e.g. IsOverloadable or HidesByName).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.IsAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType", and sets "failedThroughTypeCheck" if fails
            the protected access check.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.AddLookupSymbolsInfo(Roslyn.Compilers.CSharp.LookupSymbolsInfo,Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Look for names in scope
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.AddMemberLookupSymbolsInfo(Roslyn.Compilers.CSharp.LookupSymbolsInfo,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.LookupOptions,Roslyn.Compilers.CSharp.Binder)">
            <summary>
            Look for names of members
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindStatement(Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.DiagnosticBag)">
            <remarks>
            Noteworthy override is in MemberSemanticModel.IncrementalBinder (used for caching).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetFixedLocalCollectionInitializer(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Wrap the initializer in a BoundFixedLocalCollectionInitializer so that the rewriter will have the
            information it needs (e.g. conversions, helper methods).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CheckValue(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Binder.BindValueKind,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Check the expression is of the required lvalue and rvalue specified by valueKind.
            The method returns the original expression if the expression is of the required
            type. Otherwise, an appropriate error is added to the diagnostics bag and the
            method returns a BoundBadExpression node. The method returns the original
            expression without generating any error if the expression has errors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.RequiresVariableReceiver(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            SPEC: When a property or indexer declared in a struct-type is the target of an 
            SPEC: assignment, the instance expression associated with the property or indexer 
            SPEC: access must be classified as a variable. If the instance expression is 
            SPEC: classified as a value, a compile-time error occurs. Because of 7.6.4, 
            SPEC: the same rule also applies to fields.
            </summary>
            <remarks>
            NOTE: The spec fails to impose the restriction that the receiver must be classified
            as a variable (unlike for properties - 7.17.1).  This seems like a bug, but we have
            production code that won't build with the restriction in place (see DevDiv #15674).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CurrentOrNext``1">
            <summary>
            Get the next binder of type T. This can be used to skip over binders of other types
            in the binder chain. This is not a general purpose helper and should be used with great caution!
            </summary>
            <typeparam name="T">The type that the preceding binder should have.</typeparam>
            <exception cref="T:System.NullReferenceException">If there is no such binder.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.CurrentOrNextOpt``1">
            <summary>
            Get the next binder of type T. This can be used to skip over binders of other types
            in the binder chain. This is not a general purpose helper and should be used with great caution!
            May return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean@,Roslyn.Compilers.CSharp.AliasSymbol@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <param name="alias">Alias symbol if syntax binds to an alias.</param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindTypeOrAlias(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            If the syntax binds to an alias symbol to a type, it returns the alias symbol.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type or alias to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type or alias if syntax binds to a type or alias to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetContainingNamespaceOrType(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or the global
            namespace if containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.BindSimpleName(Roslyn.Compilers.CSharp.SimpleNameSyntax,Roslyn.Compilers.DiagnosticBag,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},System.Boolean,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol)">
            <summary>
            Binds a simple name or the simple name portion of a qualified name. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ConstructNamedTypeUnlessTypeArgumentOmitted(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.DiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructBoundMethodGroupAndReportOmittedTypeArguments.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.ConstructBoundMethodGroupAndReportOmittedTypeArguments(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.CSharp.BoundExpression,System.String,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.LookupResult,System.Boolean,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructNamedTypeUnlessTypeArgumentOmitted.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the special
            member isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticInfo@)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the special
            member isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetWellKnownType(Roslyn.Compilers.WellKnownType,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            member isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticInfo@)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            member isn't found.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.NotFound(Roslyn.Compilers.CSharp.Location,System.String,System.Int32,System.String,Roslyn.Compilers.DiagnosticBag,System.String,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.LookupOptions)">
            <remarks>
            This is only intended to be called when the type isn't found (i.e. not when it is found but is inaccessible, has the wrong arity, etc).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Binder.GetForwardedToAssembly(System.String,System.Int32,System.Boolean@)">
            <summary>
            Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.
            If one is found, search again in the target assembly.  Return the last assembly in the chain.
            </summary>
            <param name="fullName">The metadata name of the (potentially) forwarded type, including the arity (if non-zero).</param>
            <param name="arity">The arity of the forwarded type.</param>
            <param name="encounteredCycle">Set to true if a cycle was found in the type forwarders.</param>
            <returns></returns>
            <remarks>
            Since this method is intended to be used for error reporting, it stops as soon as it finds
            any type forwarder - it does not check other assemblies for consistency or better results.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.InUnsafeRegion">
            <summary>
            True if we are currently in an unsafe region (type, member, or block).
            </summary>
            <remarks>
            Does not imply that this compilation allows unsafe regions (could be in an error recovery scenario).
            To determine that, check this.Compilation.Options.AllowUnsafe.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.Next">
            <summary>
            Get the next binder in which to look up a name, if not found by this binder.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.CheckOverflow">
            <summary>
            True if we are in an explicitly checked context (within checked block or expression).
            False if we are in an explcitly unchecked context (within unchecked block or expression).
            Null otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.CheckOverflowAtRuntime">
            <summary>
            True if instructions that check overflow should be generated.
            </summary>
            <remarks>
            Spec 7.5.12:
            For non-constant expressions (expressions that are evaluated at run-time) that are not 
            enclosed by any checked or unchecked operators or statements, the default overflow checking
            context is unchecked unless external factors (such as compiler switches and execution 
            environment configuration) call for checked evaluation.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.CheckOverflowAtCompileTime">
            <summary>
            True if the compiler should check for overflow while evaluating constant expressions.
            </summary>
            <remarks>
            Spec 7.5.12:
            For constant expressions (expressions that can be fully evaluated at compile-time), 
            the default overflow checking context is always checked. Unless a constant expression 
            is explicitly placed in an unchecked context, overflows that occur during the compile-time 
            evaluation of the expression always cause compile-time errors.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ContainingMemberOrLambda">
            <summary>
            The member containing the binding context.  Note that for the purposes of the compiler,
            a lambda expression is considered a "member" of its enclosing method, field, or lambda.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.IsInIterator">
            <summary>
            Is the contained code within an iterator block?
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ImportsList">
            <summary>
            The Imports for all containing namespace declarations (innermost-to-outermost, including global).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ContainingType">
            <summary>
            The type containing the binding context
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.BindingTopLevelScriptCode">
            <summary>
            Returns true if the binder is binding top-level script code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Binder.ShouldCheckConstraints">
            <summary>
            Check generic type constraints unless the type is used as part of a type or method
            declaration. In those cases, constraints checking is handled by the caller.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.OverflowChecks.Implicit">
            <summary>
            Outside of <c>checked</c>, <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.OverflowChecks.Disabled">
            <summary>
            Within <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.OverflowChecks.Enabled">
            <summary>
            Within <c>checked</c> expression/block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder.RangeVariableMap">
            <summary>
            We represent the set of query variables in scope at a particular point by a RangeVariableMap.
            Each query variable in scope has a key in this map.  If the corresponding value is empty, then
            that query variable is represented directly by a lambda parameter.  If it is non-empty, then
            to get the value of that query variable one starts with the first parameter of the current
            lambda (the first parameter is always the transparent one), and dot through its members using
            the names in the value list, in reverse order.  So, for example, if the query variable "x" has
            a value in this map of ["Item2", "Item1", "Item1"], then the way to compute the value of that
            query variable is starting with the current lambda's first parameter P, compute "P.Item1.Item1.Item2".
            See also WithQueryLambdaParametersBinder.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.singleMeaning">
            <summary>
            A map from a name (string) to its single meaning within that scope.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalScopeBinder.EnsureSingleDefinition(Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            Givn a meaning, ensure that it is the only meaning within this scope (or report a diagnostic that it isn't).
            Returns true if a diagnostic was reported.  Sets done=true if there is no need to check further enclosing
            scopes (for example, when this meaning is the same as a previous meaning, or it can be determined that a
            diagnostic had previously been reported).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalScopeBinder.ResolveConflict(Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning,Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            We've found a possible violation of the single-definition rule.  Check that it is an actual conflict, and if
            so report it.
            </summary>
            <param name="oldMeaning">Previously recorded single meaning for this local scope</param>
            <param name="newMeaning">New single meaning found for this local scope</param>
            <param name="diagnostics">Where to place any diagnostics</param>
            <param name="done">Set to true if the caller should stop checking enclosing scope</param>
            <returns>true if an error was reported</returns>
            <remarks>
            Diagnostics produce by this method should not satisfy ErrorFacts.PreventsSuccessfulDelegateConversion because
            name conflicts are independent of the delegate type to which an anonymous function is converted.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalScopeBinder.ForceSingleDefinitions``1(Roslyn.Compilers.ReadOnlyArray{``0})">
            <summary>
            Enter each symbol as the unique single meaning in the current scope.  This assumes that any conflicts among
            them have been previously reported.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalScopeBinder.LookupLocal(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Call this when you are sure there is a local declaration on this token.  Returns the local.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning">
            <summary>
            The meaning assigned to a name within a given scope.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Name">
            <summary>
            The name
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Symbol">
            <summary>
            The symbol that is its meaning, if known.  May be null in the case of lambda parameters, to allow for the
            fact that each binding the the lambda gets a different set of parameter symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Direct">
            <summary>
            True when used or defined directly in this scope. False when used or defined in some more nested,
            enclosed scope.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Location">
            <summary>
            The location of its use or declaration
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Reported">
            <summary>
            True once a diagnostic has been reported at this location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Position">
            <summary>
            The location of the use or definition, for the purpooses of reporting conflicts.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalScopeBinder.SingleMeaning.Definition">
            <summary>
            Is this a definition (rather than use) of the given name.  This generally doesn't affect the legality of
            a conflict, but may change the diagnostic by which it is reported.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder.AttributeExpressionVisitor">
            <summary>
            Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Binder.BindValueKind">
            <summary>
            Expression lvalue and rvalue requirements.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.RValue">
            <summary>
            Expression is the RHS of an assignment operation.
            </summary>
            <remarks>
            The following are rvalues: values, variables, null literals, properties
            and indexers with getters, events. The following are not rvalues:
            namespaces, types, method groups, anonymous functions.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.RValueOrMethodGroup">
            <summary>
            Expression is the RHS of an assignment operation
            and may be a method group.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.Assignment">
            <summary>
            Expression is the LHS of a simple assignment operation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.IncrementDecrement">
            <summary>
            Expression is the operand of an increment
            or decrement operation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.CompoundAssignment">
            <summary>
            Expression is the LHS of a compound assignment
            operation (such as +=).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.OutParameter">
            <summary>
            Expression is an out parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Binder.BindValueKind.AddressOf">
            <summary>
            Expression is the operand of an address-of operation (&amp;).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.Binder)">
            <remarks>
            Since this method is expected to be called on every nested expression of the argument, it doesn't
            need to recurse (directly).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CommandLineParser.IsValidDefine(System.String)">
            <summary>
            Is this identifier a valid one for /define?
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedStringHashFunctionSymbol">
            <summary>
            Represents a compiler generated synthesized method symbol
            representing string switch hash function
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedGlobalMethodSymbol">
            <summary>
            Represents a compiler generated synthesized method symbol
            that must be emitted in the compiler generated
            PrivateImplementationDetails class
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Symbol">
            <summary>
            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes">
            <summary>
            Gets the attributes for this symbol. Returns an empty <see cref="T:Roslyn.Compilers.ReadOnlyArray`1"/> if
            there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Gets the attributes of a given attribute class on this symbol. Returns an empty
            array if there are no attributes.
            </summary>
            <param name="attributeType">The type of attribute to check for.</param>
            <returns>All attributes of the given type, or an empty array if none.</returns>
            
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(System.String,System.String)">
            <summary>
            Gets the attributes on this symbol that match the namespace and type name.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="namespaceName">Namespace name to match</param>
            <param name="typeName">Type name to match</param>
            <returns>Matching attributes</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(Roslyn.Compilers.AttributeDescription)">
            <summary>
            Gets the attributes on this symbol that match the namespace name, type name and signature.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="description">Attribute to match.</param>
            <returns>Matching attributes</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributes(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Gets the attributes on this symbol which are specified with the given attribute constructor.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="attributeConstructor">Attribute constructor to check for.</param>
            <returns>Attributes specified with the given constructor, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributeTarget">
            <summary>
            Gets the attribute target kind corresponding to the symbol kind
            If attributes cannot be applied to this symbol kind, returns
            an invalid AttributeTargets value of 0
            </summary>
            <returns>AttributeTargets or 0</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.EarlyDecodeWellKnownAttributeType(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>
            Method to early decode the type of well-known attribute which can be queried during the BindAttributeType phase.
            This method is called first during attribute binding so that any attributes that affect semantics of type binding
            can be decoded here.
            </summary>
            <remarks>
            NOTE: If you are early decoding any new well-known attribute, make sure to update PostEarlyDecodeWellKnownAttributeTypes 
            to default initialize this data.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.PostEarlyDecodeWellKnownAttributeTypes">
            <summary>
            This method is called during attribute binding after EarlyDecodeWellKnownAttributeTypes has been executed.
            Symbols should default initialize the data for early decoded well-known attributes here.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.EarlyDecodeWellKnownAttribute(Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments{Roslyn.Compilers.CSharp.EarlyWellKnownAttributeBinder,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.AttributeLocation}@)">
            <summary>
            Method to early decode applied well-known attribute which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.DecodeWellKnownAttribute(Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments{Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.AttributeData,Roslyn.Compilers.CSharp.AttributeLocation}@)">
            <summary>
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            <para>
            NOTE: If we are decoding a well-known attribute that could be queried by the binder, consider decoding it during early decoding pass.
            </para>
            </summary>
            <remarks>
            <para>
            Symbol types should override this if they want to handle a specific well-known attribute.
            If the attribute is of a type that the symbol does not wish to handle, it should delegate back to
            this (base) method.
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.PostDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeData},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeSyntax},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.AttributeLocation,Roslyn.Compilers.WellKnownAttributeData)">
            <summary>
            Called to report attribute related diagnostics after all attributes have been bound and decoded.
            Called even if there are no attributes.
            </summary>
            <remarks>
            This method is called by the binder from <see cref="M:LoadAndValidateAttributes"/> after it has finished binding attributes on the symbol,
            has executed <see cref="M:DecodeWellKnownAttributes"/> for attributes applied on the symbol and has stored the decoded data in the
            lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.
            
            Post-validation for attributes that is dependant on other attributes can be done here.
            
            This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.
            </remarks>
            <param name="boundAttributes">Bound attributes.</param>
            <param name="allAttributeSyntaxNodes">Syntax nodes of attributes in order they are specified in source, or null if there are no attributes.</param>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Roslyn.Compilers.CSharp.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="decodedData">Decoded well-known attribute data, could be null.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax}},Roslyn.Compilers.CustomAttributesBag{Roslyn.Compilers.CSharp.AttributeData}@,Roslyn.Compilers.CSharp.AttributeLocation,System.Boolean)">
            <summary>
            This method does the following set of operations in the specified order:
            (1) GetAttributesToBind: Merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            (2) BindAttributeTypes: Bind all the attribute types to enable early decode of certain well-known attributes by type.
            (3) EarlyDecodeWellKnownAttributes: Perform early decoding of certain well-known attributes that could be queried by the binder in subsequent steps.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (4) GetAttributes: Bind the attributes (attribute arguments and constructor) using bound attribute types.
            (5) DecodeWellKnownAttributes: Decode and validate bound well known attributes.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (6) StoreBoundAttributesAndDoPostValidation:
                (a) Store the bound attributes in lazyCustomAttributes in a thread safe manner.
                (b) Perform some additional post attribute validations, such as
                    1) Duplicate attributes, attribute usage target validation, etc.
                    2) Post validation for attributes dependant on other attributes
                    These validations cannot be performed prior to step 6(a) as we might need to
                    perform a GetAttributes() call on a symbol which can introduce a cycle in attribute binding.
                    We avoid this cycle by performing such validations in PostDecodeWellKnownAttributes after lazyCustomAttributes have been set.
                NOTE: PostDecodeWellKnownAttributes SHOULD NOT change the symbol state.
            </summary>
            <remarks>
            Current design of early decoding well-known attributes doesn't permit decoding attribute arguments/constructor as this can lead to binding cycles.
            For well-known attributes used by the binder, where we need the decoded arguments, we must handle them specially in one of the following possible ways:
              (a) Avoid decoding the attribute arguments during binding and delay the corresponding binder tasks to a separate post-pass executed after binding.
              (b) As the cycles can be caused only when we are binding attribute arguments/constructor, special case the corresponding binder tasks based on the current BindingLocation.
            </remarks>
            <param name="attributesSyntaxLists"></param>
            <param name="lazyCustomAttributesBag"></param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Roslyn.Compilers.CSharp.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="earlyDecodingOnly">Indicates that only early decoding should be performed.  WARNING: the resulting bag will not be sealed.</param>
            <returns>Flag indicating whether lazyCustomAttributes were stored on this thread. Caller should check for this flag and perform NotePartComplete if true.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetAttributesToBind(Roslyn.Utilities.OneOrMany{Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax}},Roslyn.Compilers.CSharp.AttributeLocation,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Binder}@)">
            <summary>
            Method to merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            This is the first step in attribute binding.
            </summary>
            <remarks>
            This method can generate diagnostics for few cases where we have an invalid target specifier and the parser hasn't generated the necessary diagnostics.
            It should not perform any bind operations as it can lead to an attribute binding cycle.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.EarlyDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Binder},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamedTypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeSyntax},Roslyn.Compilers.CSharp.AttributeLocation,Roslyn.Compilers.CSharp.AttributeData[])">
            <summary>
            Method to early decode certain well-known attributes which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ValidateAttributeUsageAndDecodeWellKnownAttributes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Binder},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeSyntax},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeData},Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.AttributeLocation)">
            <summary>
            This method validates attribute usage for each bound attribute and calls <see cref="M:DecodeWellKnownAttribute"/>
            on attributes with valid attribute usage.
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ValidateAttributeUsage(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.AttributeLocation,Roslyn.Compilers.DiagnosticBag,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.NamedTypeSymbol})">
            <summary>
            Validate attribute usage target and duplicate attributes.
            </summary>
            <param name="attributeType">Attribute class for the attribute</param>
            <param name="node">Syntax node for attribute specification</param>
            <param name="symbolPart">Symbol part to which the attribute has been applied.</param>
            <param name="diagnostics">Diagnostics</param>
            <param name="uniqueAttributeTypes">Set of unique attribute types applied to the symbol</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ForceCompleteObsoleteAttribute">
            <summary>
            Ensure that attributes are bound and the ObsoleteState of this symbol is known.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ForceComplete(Roslyn.Compilers.CSharp.SourceLocation,System.Threading.CancellationToken)">
            <summary>
            Used to force (source) symbols to a given state of completion.
            </summary>
            <param name="locationOpt">The location within which binders should be completed</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel out of
            this operation early at the behest of the caller.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.HasAtMostOneBitSet(Roslyn.Compilers.CSharp.Symbol.CompletionPart)">
            <remarks>
            Since this formula is rather opaque, a demonstration of its correctness is
            provided in Roslyn.Compilers.CSharp.UnitTests.CompletionTests.TestHasAtMostOneBitSet.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.CheckDefinitionInvariant">
            <summary>
            Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.IsDefinitionOrDistinct">
            <summary>
            Return whether the symbol is either the original definition
            or distinct from the original. Intended for use in Debug.Assert
            only since it may include a deep comparison.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetCustomAttributesToEmit(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AttributeData},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.SynthesizedAttributeData},System.Boolean)">
            <summary>
            Returns a list of attributes to emit to CustomAttribute table.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.MakeMetadataName(System.String@)">
            <summary>
            The CLI spec puts limits the maximum length of name and paths
            (when encoded as UTF-8).  The Metadata name of a symbol is the
            name after having been modified to satisfy the length restrictions.
            </summary>
            <param name="metadataName">The truncated name.</param>
            <returns>True if truncation occurred.</returns>
            <remarks>Not guaranteed to be unique.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetDeclaringSyntaxNodeHelper``1(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Location})">
            <summary>
            Helper for implementing DeclaringSyntaxNodes for derived classes that store a location but not a 
            SyntaxNode or SyntaxReference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetDeclaringSyntaxNodeHelper(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxReference})">
            <summary>
            Helper for implementing DeclaringSyntaxNodes for derived classes that store SyntaxReferences.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.AfterAddingTypeMembersChecks(Roslyn.Compilers.CSharp.ConversionsBase,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform additional checks after the member has been
            added to the member list of the containing type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.op_Equality(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.op_Inequality(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol, suitable for debugging purposes, or
            for placing in an error message.
            </summary>
            <remarks>
            This will provide a useful representation, but it would be clearer to call ToDisplayString
            directly and provide an explicit format.
            Sealed so that ToString and ToDisplayString can't get out of sync.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            This is intended primarily for inserting localized descriptions of symbols into
            user-facing error messages.  If you need more fine-grained control of the output, try
            calling Symbol.ToDisplayString directly.
            </summary>
            <remarks>
            Generally speaking, this method should not be called directly.  Instead, they should be
            passed directly to errors/diagnostics.  To use a different format string, update the
            error message (e.g. Change "Problem with {0}" to "Problem with {0:S}" to display the
            short name of a symbol).
            
            We could have subclasses do their own parsing of the format string (to accept other
            formats), but we can probably do everything from here using Symbol.Kind.
            </remarks>
            <param name="format">
                G - general: default (determined by SymbolDisplay.ToDisplayString)
                E - error: format to be used in compiler error messages
                T - test: includes lots of qualification, parameters, modifiers, etc
                S - short: just the (user-facing) name of the symbol
                I - IL: to be used when visualizing IL
            </param>
            <param name="formatProvider">Usually a CultureInfo object.</param>
            <returns>A description of this symbol.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetSynthesizedAttributes">
            <summary>
            Gets the synthesized attributes for this symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetDocumentationComment(System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Fetches the documentation comment for this element with a cancellation token.
            </summary>
            <returns>A DocumentationComment object.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.GetUseSiteErrorInfo">
            <summary>
            Returns error info for an error, if any, that should be reported at the use site of the symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Symbol.DeriveUseSiteErrorInfoFromType(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol}@)">
            <summary>
            Derive error info from a type symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            3) The length of names is limited to not exceed metadata restrictions.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingType">
            <summary>
            Returns the nearest lexically enclosing type, or null if there is none.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingNamespace">
            <summary>
            Gets the nearest enclosing namespace for this namespace or type. For a nested type,
            returns the namespace that contains its container.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingAssembly">
            <summary>
            Returns the assembly containing this symbol. If this symbol is shared across multiple
            assemblies, or doesn't belong to an assembly, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ContainingModule">
            <summary>
            Returns the module containing this symbol. If this symbol is shared across multiple
            modules, or doesn't belong to a module, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsDefinition">
            <summary>
            Returns whether this the original definition of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.DeclaringSyntaxNodes">
            <summary>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for
            example, partial classes) may be defined in more than one location. This property should
            return one or more syntax nodes only if the symbol was declared in source code and also
            was not implicitly declared (see the IsImplicitlyDeclared property). 
            
            Note that for namespace symbol, the declaring syntax might be declaring a nested
            namespace. For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is
            the entire NamespaceDeclarationSyntax for N1.N2. For the global namespace, the declaring
            syntax will be the CompilationUnitSyntax.
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata or
            was implicitly declared, returns an empty read-only array.
            </returns>
            <remarks>
            To go the opposite direction (from syntax node to symbol), see <see cref="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.MemberDeclarationSyntax,System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <remarks>
            Even for metadata symbols, IsOverride = true does not imply that OverriddenMethod will
            be non-null.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not
            have an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense,
            and may be used by code, but that are simply declared implicitly rather than
            with explicit language syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              this "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types,
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code. Examples of symbols
            that cannot be referenced by name are:
               constructors, destructors, operators, explicit interface implementations,
               accessor methods for properties and events, array types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
            <summary>
            As an optimization, viability checking in the lookup code should use this property instead
            of CanBeReferencedByName.  The full name check will then be performed in the SemanticModel.
            </summary>
            <remarks>
            This property exists purely for performance reasons.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.IsFromSource">
            <summary>
            True if and only if the symbol is the one original symbol resulting from some
            declaration in the source. The declaration might be implicit, for example a synthesized
            constructor is considered to come from source. Constructed and substituted symbols
            are from source if their original symbol is from source. ErrorTypeSymbols are
            never from source. Array types and pointer types never return true for this property, 
            as they are not "declared" in the source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            Supposed to be ErrorCode, but it causes inconsistent accessibility error.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute. 
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Symbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Symbol.CompletionPart">
            <summary>
            This enum describes the types of components that could give
            us diagnostics.  We shouldn't read the list of diagnostics
            until all of these types are accounted for.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as newslot (as indicated by the presence of the "newslot" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all SourceNamedTypeSymbols, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.IsMetadataVirtual(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as virtual (as indicated by the presence of the "virtual" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all SourceNamedTypeSymbols, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes on method's return type.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Gets the attributes of a given attribute class on method's return type.
            Returns an empty array if there are no attributes.
            </summary>
            <param name="attributeType">The type of attribute to check for.</param>
            <returns>All attributes of the given type, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetReturnTypeAttributes(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Gets the attributes on method's return type which are specified with the given attribute constructor.
            Returns an empty array if there are no such attributes.
            </summary>
            <param name="attributeConstructor">Attribute constructor to check for.</param>
            <returns>Attributes specified with the given constructor, or an empty array if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetOriginalConstructedOverriddenMethod(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes. Also, if the given method symbol
            is generic then the resulting virtual or abstract method is constructed with the
            same type arguments as the given method.
            </summary>
            <param name="callingType">The search must respect accessibility from this type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.CallsAreOmitted(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Returns true if calls to this method are omitted in this syntax tree. Calls are omitted
            when the called method is a partial method with no implementation part, or when the
            called method is a conditional method whose condition is not true in the source file
            corresponding to the given syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.CallsAreConditionallyOmitted(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Calls are conditionally omitted if both the following requirements are true:
             (a) IsConditional == true, i.e. it has at least one applied/inherited conditional attribute AND
             (b) None of conditional symbols corresponding to these conditional attributes are defined in the given syntaxTree.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.CanOverrideOrHide(Roslyn.Compilers.CSharp.MethodKind)">
            <summary>
            Some method kinds do not participate in overriding/hiding (e.g. constructors).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.HasEntryPointSignature">
            <summary>
            Checks if the method has an entry point compatible signature, i.e.
            - the return type is either void or int
            - has either no parameter or a single parameter of type string[]
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.ReduceExtensionMethod(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.ReduceExtensionMethod">
            <summary>
            If this is an extension method, returns a reduced extension method
            symbol representing the method. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.Construct(Roslyn.Compilers.CSharp.TypeSymbol[])">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.Construct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodSymbol.lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbol.GenerateMethodBody(Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Generates bound block representing method's body for methods in lowered form and adds it to
            a collection of method bodies of the current module. This method is supposed to only be 
            called for method symbols which return SynthesizesLoweredBoundBody == true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ImplementationAttributes">
            <summary>
            Misc implementation metadata flags (ImplFlags in metadata).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnValueMarshallingInformation">
            <summary>
            Marshalling information for return value (FieldMarshal in metadata). 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code (metadata flag RequiresSecurityObject is set).
            </summary>
            <remarks>
            A method can me marked as RequiresSecurityObject by applying the DynamicSecurityMethodAttribute in source.
            DynamicSecurityMethodAttribute is a pseudo custom attribute defined as an internal class in System.Security namespace.
            This attribute is set on certain security methods defined within mscorlib.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for C-style variable
             argument lists. This is used extremely rarely in C# code and is represented using the undocumented __arglist keyword.
            
             Note that methods with params on the last parameter are indicated with the IsParams property on ParameterSymbol, and
             are not represented with this property.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ThisParameter">
            <summary>
            Get the "this" parameter for this method.  This is only valid for original source methods.
            For other methods it throws an InvalidOperationException. Returns null for a static method,
            or a parameter symbol for a non-static method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
            <remarks>
            The default implementation is always correct, but may be unnecessarily slow.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ReadOnlyArray.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.AssociatedPropertyOrEvent">
            <summary>
            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
            returns the property that this method is the getter or setter for.
            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
            returns the event that this method is the adder or remover for.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            Note that if an overriding method D.M overrides C.M, which in turn overrides 
            virtual method B.M, the "overridden method" of D.M is C.M, not the original virtual
            method B.M. Note also that constructed generic methods are not considered to 
            override anything.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.Kind">
            <summary>
            Returns value 'Method' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsScriptConstructor">
            <summary>
            Returns true if this symbol represents a constructor of a script class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsImplicitConstructor">
            <summary>
            Returns if the method is implicit constructor (normal and static)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsSubmissionConstructor">
            <summary>
            Returns true if this symbol represents a constructor of an interactive submission class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IsEntryPointCandidate">
            <summary>
            Determines whether this method is a candidate for a default assembly entry point 
            (i.e. it is a static method called "Main").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, returns the extension
            method from which this was reduced. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method also
            has a part that implements it with a body, returns that implementing
            definition.  Otherwise null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method with a body, returns the corresponding
            definition part (without a body).  Otherwise null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.ParameterRefKinds">
            <summary>
            Null if no paremter is ref/out. Otherwise the RefKind for each parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic method instantiation, returns null.
            The map targets the original definition of the method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.IteratorElementType">
            <summary>
            If the method was written as an iterator method (i.e. with yield statements in its body) returns the
            element type of the iterator.  Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.SynthesizesLoweredBoundBody">
            <summary>
            Returns true for synthesized sybols which generate synthesized body in lowered form
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodSymbol.SuppressDebugInfo">
            <summary>
            If true, suppresses generation of debug info in this method even if generateDebugInfo is true
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SynthesizedGlobalMethodSymbol.ContainingSymbol">
            <summary>
            Synthesized methods that must be emitted in the compiler generated
            PrivateImplementationDetails class have null containing type symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod">
            <summary>
            When C# interface implementation differs from CLR interface implementation,
            we insert a synthesized explicit interface implementation that delegates
            to the method that C# considers an implicit implementation.
            There are two key scenarios for this:
            1) A single source method is implicitly implementing one or more interface
               methods from metadata and the interface methods have different custom
               modifiers.  In this case, we explicitly implement the interface methods
               and have (all) implementations delegate to the source method.
            2) A non-virtual, non-source method in a base type is implicitly implementing
               an interface method.  Since we can't change the "virtualness" of the 
               non-source method, we introduce an explicit implementation that delegates
               to it instead.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceSynthesizedMethodSymbol">
            <summary>
            A base class for synthesized methods that want a this parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceSynthesizedMethodSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceSynthesizedMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod.GenerateMethodBody(Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given a SynthesizedExplicitImplementationMethod (effectively a tuple (interface method, implementing method, implementing type)),
            construct a BoundBlock body.  Consider the tuple (Interface.Foo, Base.Foo, Derived).  The generated method will look like:
            
            R Interface.Foo&lt;T1, T2, ...&gt;(A1 a1, A2 a2, ...)
            {
                //don't return the output if the return type is void
                return this.Foo&lt;T1, T2, ...&gt;(a1, a2, ...);
            }
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedSealedPropertyAccessor">
            <summary>
            If a sealed override property defines fewer accessors than the
            original virtual property, it is necessary to synthesize a sealed
            accessor so that the accessor will not be overridable from metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SynthesizedSealedPropertyAccessor.GenerateMethodBody(Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodToClassRewriter">
            <summary>
            a bound node rewriter that rewrites types properly (which in some cases the automatically-generated
            base class does not).  This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodToClassRewriter.CompilationState">
            <summary> A not-null collection of synthesized methods generated for the current source type. </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodToClassRewriter.BaseMethodWrapperSymbol">
            <summary>
            A wrapper method that is created for non-virtually calling a base-class 
            virtual method from other classes (like those created for lambdas...).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodToClassRewriter.SynthesizedMethodBaseSymbol">
            <summary>
            A base method symbol used as a base class for lambda method symbol and base method wrapper symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IAttributeTargetSymbol">
            <summary>
            Implemented by symbols that can be targetted by an attribute declaration (i.e. source symbols).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IAttributeTargetSymbol.AttributesOwner">
            <summary>
            Returns the owner of attributes that apply to this symbol.
            </summary>
            <remarks>
            Attributes for this symbol might be retrieved from attribute list of another (owning) symbol.
            In that case this property returns that owning symbol, otherwise it returns "this".
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IAttributeTargetSymbol.AllowedAttributeLocations">
            <summary>
            Returns a bit set of attribute locations applicable to this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IAttributeTargetSymbol.DefaultAttributeLocation">
            <summary>
            Attribute location corresponding to this symbol.
            </summary>
            <remarks>
            Location of an attribute if an explicit location is not specified via attribute target specification syntax.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares atributes for this method symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetReturnTypeAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares atributes for return type of this method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetDecodedReturnTypeWellKnownAttributeData">
            <summary>
            Returns information retrieved from custom attributes on return type in source, or null if the symbol is not source symbol or there are none.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetReturnTypeAttributesBag">
            <summary>
            Returns a bag of custom attributes applied on the method return value and data decoded from well-known attributes. Returns null if there are no attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes applied on the return value of this method symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMethodSymbol.Locations">
            <summary>
            Overridden by <see cref="T:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol"/>, 
            which might return locations of partial methods.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMethodSymbol.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
            </summary>
            <remarks>
            Used for example for event accessors. The "remove" method delegates attribute binding to the "add" method. 
            The bound attribute data are then applied to both accessors.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMethodSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute. 
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodToClassRewriter.BaseMethodWrapperSymbol.GenerateMethodBody(Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodBodySynthesizer">
            <summary>
            Contains methods related to synthesizing bound nodes in lowered form 
            that does not need any processing before passing to codegen
            </summary>
            <summary>
            Contains methods related to synthesizing bound nodes in initial binding 
            form that needs lowering, primarily method bodies for compiler-generated methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.ConstructSingleInvocationMethodBody(Roslyn.Compilers.CSharp.SyntheticBoundNodeFactory,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean)">
            <summary>
            Construct a body for a method containing a call to a single other method with the same signature (modulo name).
            </summary>
            <param name="F">Bound node factory.</param>
            <param name="methodToInvoke">Method to invoke in constructed body.</param>
            <param name="useBaseReference">True for "base.", false for "this.".</param>
            <returns>Body for implementedMethod.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.MakeSubmissionInitialization(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.SynthesizedSubmissionFields,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Generates a submission initialization part of a Script type constructor that represents an interactive submission.
            </summary>
            <remarks>
            The constructor takes a parameter of type <see cref="T:Roslyn.Scripting.Session"/> - the session reference.
            It adds the object being constructed into the session by calling <see cref="M:Microsoft.CSharp.RuntimeHelpers.SessionHelpers.SetSubmission(Roslyn.Scripting.Session,System.Int32,System.Object)"/>,
            and retrieves strongly typed references on all previous submission script classes whose members are referenced by this submission.
            The references are stored to fields of the submission (<paramref name="synthesizedFields"/>).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.ConstructAutoPropertyAccessorBody(Roslyn.Compilers.CSharp.SourceMethodSymbol)">
            <summary>
            Construct a body for an auto-property accessor (updating or returning the backing field).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody(Roslyn.Compilers.CSharp.SourceEventSymbol,System.Boolean,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Generate a thread-safe accessor for a field-like event.
            
            DelegateType tmp0 = _event; //backing field
            DelegateType tmp1;
            DelegateType tmp2;
            do {
                tmp1 = tmp0;
                tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=
                tmp0 = Interlocked.CompareExchange&lt;DelegateType&gt;(ref _event, tmp2, tmp1);
            } while ((object)tmp0 != (object)tmp1);
            </summary>
            <remarks>
            CONSIDER: Dev10 has fallback logic - if Interlocked.CompareExchange is not available, just call
            Delegate.Combine/Remove and mark the method synchronized (unless it is a struct method).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.GetConstructedCompareExchangeMethod(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get the MethodSymbol for System.Threading.Interlocked.CompareExchange&lt;T&gt; for a given T.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodySynthesizer.GetBaseTypeFinalizeMethod(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Look for a base type method named "Finalize" that is protected (or protected internal), has no parameters, 
            and returns void.  It doesn't need to be virtual or a destructor.
            </summary>
            <remarks>
            You would think that this would share code and logic with PEMethodSymbol.OverridesRuntimeFinalizer, 
            but FUNCBRECCS::bindDestructor has its own loop that performs these checks (differently).
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceScopeBuilder">
            <summary>
            Class to cache and build namespace scopes. Should be released and collected once all namespace scopes
            are built, since it contains caches that won't be needed anymore.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceScopeBuilder.GetNamespaceScopes(Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Imports})">
            <remarks>
            CONSIDER: in the case of field initializers, it is possible that different parts of a method could have different
            namespace scopes (i.e. if they come from different parts of a partial type).  Currently, we're following Dev10's
            approach of using the context of the (possibly synthesized) constructor into which the field initializers are
            inserted.  It might be possible to give field initializers their own scopes, assuming the EE supports it.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceScopeBuilder.BuildNamespaceString(Roslyn.Compilers.CSharp.NamespaceSymbol)">
            <summary>
            Qualified name of namespace.
            e.g. "A.B.C"
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceScopeBuilder.BuildNamespaceStringHelper(Roslyn.Compilers.CSharp.NamespaceSymbol)">
            <summary>
            Empty string for the global namespace, "A.B." for everything else (i.e. trailing dot).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceScopeBuilder.BuildTypeString(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Qualified name of type followed by full assembly name, with square brackets in place of
            angle brackets and around type arguments.
            e.g. "A.B.C`2[[D.E,assembly], [F.G,assembly]],assembly"
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceScopeBuilder.BuildTypeStringHelper(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Same as GetTypeString, but without containing type/namespace.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EmptyStructTypeCache">
            <summary>
            A small cache for remembering empty struct types for flow analysis.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EmptyStructTypeCache.IsEmptyStructType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determine if the given type is an empty struct type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EmptyStructTypeCache.IsEmptyStructType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.NamedTypeSymbol})">
            <summary>
            Determine if the give type is an empty struct type,. "typesWithMembersOfThisType" contains
            a list of types that have members (directly or indirectly) of this type.
            to remove circularity.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.UnassignedAddressTakenVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.compilation">
            <summary>
            The compilation in which the analysis is taking place.  This is needed to determine which
            conditional methods will be compiled and which will be omitted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.method">
            <summary>
            The method whose body is being analyzed. Method attribute is only being used for
            references to method parameters. Thus, 'method' should not be used directly, but
            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used
            instead.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.methodMainNode">
            <summary>
            The bound node of the method or initializer being analyzed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.labels">
            <summary>
            The flow analysis state at each label, computed by merging the state from branches to
            that label with the state when we fall into the label.  Entries are created when the
            label is encountered.  One case deserves special attention: when the destination of the
            branch is a label earlier in the code, it is possible (though rarely occurs in practice)
            that we are changing the state at a label that we've already analyzed. In that case we
            run another pass of the analysis to allow those changes to propagate. This repeats until
            no further changes to the state of these labels occurs.  This can result in quadratic
            performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
            3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.backwardBranchChanged">
            <summary>
            Set to true after an analysis scan if the analysis was incomplete due to a backward
            "goto" branch changing some analysis result.  In this case the caller scans again (until
            this is false). Since the analysis proceeds by monotonically changing the state computed
            at each label, this must terminate.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.pendingBranches">
            <summary>
            See property PendingBranches
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.labelsSeen">
            <summary>
            All of the labels seen so far in this forward scan of the body
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.State">
            <summary>
            The definite assignment and/or reachability state at the point currently being analyzed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AbstractFlowPass`1.loopHeadState">
            <summary>
            A cache of the state at the backward branch point of each loop.  This is not needed
            during normal flow analysis, but is needed for DataFlowsOut region analysis.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.EnterRegion">
            <summary>
            Subclasses may override EnterRegion to perform any actions at the entry to the region.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.LeaveRegion">
            <summary>
            Subclasses may override LeaveRegion to perform any action at the end of the region.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.Scan(System.Boolean@)">
            <summary>
            Perform a single pass of flow analysis.  Note that after this pass,
            this.backwardBranchChanged indicates if a further pass is required.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.ShouldAnalyzeOutParameters(Roslyn.Compilers.CSharp.Location@)">
            <summary>
            Specifies whether or not method's out parameters should be analyzed. If there's more
            than one location in the method being analyzed, then the method is partial and we prefer
            to report an out parameter in partial method error.
            </summary>
            <param name="location">location to be used</param>
            <returns>true if the out parameters of the method should be analyzed</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.LabelState(Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Return the flow analysis state associated with a label.
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.RemoveReturns">
            <summary>
            Return to the caller the set of pending return statements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.SetUnreachable">
            <summary>
            Set the current state to one that indicates that it is unreachable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.VisitCondition(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Visit a boolean condition expression.
            </summary>
            <param name="node"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.VisitRvalue(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Visit a general expression, where we will only need to determine if variables are
            assigned (or not). That is, we will not be needing AssignedWhenTrue and
            AssignedWhenFalse.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.VisitStatement(Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            Visit a statement.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.LoopHead(Roslyn.Compilers.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backwards branch would go to.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.LoopTail(Roslyn.Compilers.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backward branch is placed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.ResolveBreaks(`0,Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Used to resolve break statements in each statement form that has a break statement
            (loops, switch).
            </summary>
            <param name="breakState"></param>
            <param name="label"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.ResolveContinues(Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            Used to resolve continue statements in each statement form that supports it.
            </summary>
            <param name="continueLabel"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.NoteBranch(Roslyn.Compilers.CSharp.AbstractFlowPass{`0}.PendingBranch,Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            Subclasses override this if they want to take special actions on processing a goto
            statement, when both the jump and the label have been located.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.ResolveBranches(Roslyn.Compilers.CSharp.LabelSymbol,Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            To handle a label, we resolve all branches to that label.  Returns true if the state of
            the label changes as a result.
            </summary>
            <param name="label">Target label</param>
            <param name="target">Statement containing the target label</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.SavePending">
            <summary>
            Since branches cannot branch into constructs, only out, we save the pending branches
            when visiting more nested constructs.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.RestorePending(Roslyn.Compilers.CSharp.AbstractFlowPass{`0}.SavedPending)">
            <summary>
            We use this to restore the old set of pending branches after visiting a construct that contains nested statements.
            </summary>
            <param name="oldPending">The old pending branches, which are to be merged with the current ones</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.Unimplemented(Roslyn.Compilers.CSharp.BoundNode,System.String)">
            <summary>
            Report an unimplemented language construct.
            </summary>
            <param name="node"></param>
            <param name="feature"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.DefaultVisit(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Since each language construct must be handled according to the rules of the language specification,
            the default visitor reports that the construct for the node is not implemented in the compiler.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.TypeIsImmutable(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Certain (struct) types are known by the compiler to be immutable.  In these cases calling a method on
            the type is known (by flow analysis) not to write the receiver.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.VisitAddressOfOperator(Roslyn.Compilers.CSharp.BoundAddressOfOperator,System.Boolean)">
            <summary>
            If the operand is definitely assigned, we may want to perform a read (in addition to
            a write) so that the operand can show up as ReadInside/DataFlowsIn.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowPass`1.PendingBranches">
            <summary>
            Pending escapes generated in the current scope (or more deeply nested scopes). When jump
            statements (goto, break, continue, return) are processed, they are placed in the
            pendingBranches buffer to be processed later by the code handling the destination
            statement. As a special case, the processing of try-finally statements might modify the
            contents of the pendingBranches buffer to take into account the behavior of
            "intervening" finally clauses.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowPass`1.Diagnostics">
            <summary>
            Where all diagnostics are deposited.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowPass`1.MethodParameters">
            <summary>
            If a method is currently being analyzed returns its parameters, returns an empty array
            otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AbstractFlowPass`1.MethodThisParameter">
            <summary>
            If a method is currently being analyzed returns its 'this' parameter, returns null
            otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractFlowPass`1.AbstractLocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AbstractFlowPass`1.PendingBranch">
            <summary>
            A pending branch.  There are created for a return, break, continue, or goto statement.
            The idea is that we don't know if the branch will eventually reach its destination
            because of an intervening finally block that cannot complete normally.  So we store them
            up and handle them as we complete processing each construct.  At the end of a block, if
            there are any pending branches to a label in that block we process the branch.  Otherwise
            we relay it up to the enclosing construct as a pending branch of the enclosing
            construct.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.initiallyAssignedVariables">
            <summary>
            Some variables that should be considered initially assigned.  Used for region analysis.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.usedVariables">
            <summary>
            Variables that were used anywhere, in the sense required to suppress warnings about
            unused variables.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.writtenVariables">
            <summary>
            Variables that were initialized or written anywhere.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.unsafeAddressTakenVariables">
            <summary>
            Map from variables that had their addresses taken, to the location of the first corresponding
            address-of expression.
            </summary>
            <remarks>
            Doesn't include fixed statement address-of operands.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.capturedVariables">
            <summary>
            Variables that were captured by anonymous functions.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.sourceAssembly">
            <summary>
            The current source assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.variableSlot">
            <summary>
            A mapping from local variables to the index of their slot in a flow analysis local state.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.unassignedVariableAddressOfSyntaxes">
            <summary>
            A set of address-of expressions for which the operand is not definitely assigned.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.variableBySlot">
            <summary>
            A mapping from the local variable slot to the symbol for the local variable itself.  This
            is used in the implementation of region analysis (support for extract method) to compute
            the set of variables "always assigned" in a region of code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.nextVariableSlot">
            <summary>
            Variable slots are allocated to local variables sequentially and never reused.  This is
            the index of the next slot number to use.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.alreadyReported">
            <summary>
            Tracks variables for which we have already reported a definite assignment error.  This
            allows us to report at most one such error per variable.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.emptyStructTypeCache">
            <summary>
            A cache for remember which structs are empty.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.requireOutParamsAssigned">
            <summary>
            true if we should check to ensure that out parameters are assigned on every exit point.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.DataFlowPass.topLevelMethod">
            <summary>
            The topmost method of this analysis.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.Analyze(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.DiagnosticBag,System.Boolean)">
            <summary>
            Perform data flow analysis, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.Analyze(System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.WriteConsideredUse(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            This reflects the Dev10 compiler's rules for when a variable initialization is considered a "use"
            for the purpose of suppressing the warning about unused variables.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.VariableSlot(Roslyn.Compilers.CSharp.Symbol,System.Int32)">
            <summary>
            Locals are given slots when their declarations are encountered.  We only need give slots
            to local variables, out parameters, and the "this" variable of a struct constructs.
            Other variables are not given slots, and are therefore not tracked by the analysis.  This
            returns -1 for a variable that is not tracked, for fields of structs that have the same
            assigned status as the container, and for structs that (recursively) contain no data members.
            We do not need to track references to
            variables that occur before the variable is declared, as those are reported in an
            earlier phase as "use before declaration". That allows us to avoid giving slots to local
            variables before processing their declarations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.MakeSlot(Roslyn.Compilers.CSharp.Symbol,System.Int32)">
            <summary>
            Force a variable to have a slot.  Returns -1 if the variable has an empty struct type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.MakeSlot(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Return the slot for a variable, or -1 if it is not tracked (because, for example, it is an empty struct).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.CheckAssigned(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Check that the given variable is definitely assigned.  If not, produce an error.
            </summary>
            <param name="symbol"></param>
            <param name="node"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.ReportUnassigned(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Report a given variable as not definitely assigned.  Once a variable has been so
            reported, we suppress further reports of that variable.
            </summary>
            <param name="symbol"></param>
            <param name="node"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.Assign(Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Mark a variable as assigned (or unassigned).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.FieldsAllSet(System.Int32,Roslyn.Compilers.CSharp.DataFlowPass.LocalState)">
            <summary>
            Does the struct variable at the given slot have all of its instance fields assigned?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.VisitUsingStatement(Roslyn.Compilers.CSharp.BoundUsingStatement)">
            <remarks>
            Variables declared in a using statement are always considered used, so this is just an assert.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowPass.currentMethodOrLambda">
            <summary>
            Reflects the enclosing method or lambda at the current location (in the bound tree).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DataFlowPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompilationReference">
            <summary>
            Represents a reference to another C# compilation. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationReference.#ctor(Roslyn.Compilers.CSharp.Compilation,System.String,System.Boolean)">
            <summary>
            Create a metadata reference to a compilation.
            </summary>
            <param name="compilation">The compilation to reference.</param>
            <param name="alias">A namespace alias for this reference.</param>
            <param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationReference.Compilation">
            <summary>
            Returns the referenced Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ExpressionLambdaRewriter.VisitExactType(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Visit the expression, but do so in a way that ensures that its type is precise.  That means that any
            sometimes-unnecessary conversions (such as an implicit reference conversion) are retained.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeConversion(Roslyn.Compilers.CSharp.BoundConversion,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.ConversionKind,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean,System.Boolean,System.Boolean,Roslyn.Compilers.ConstantValue,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Helper method to generate a lowered conversion.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeConversion(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean)">
            <summary>
            Helper method to generate a lowered conversion from the given rewrittenOperand to the given rewrittenType.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeConversion(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.ConversionKind,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,Roslyn.Compilers.ConstantValue)">
            <summary>
            Helper method to generate a lowered conversion from the given rewrittenOperand to the given rewrittenType with the given conversion kind.
            </summary>
            <remarks>
            Conversion kind must not be a user defined conversion, use the other overload which takes a 'Conversion' parameter for generating synthesized user defined conversions.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            This is the entry point for foreach-loop lowering.  It delegates to
              RewriteEnumeratorForEachStatement
              RewriteSingleDimensionalArrayForEachStatement
              RewriteMultiDimensionalArrayForEachStatement
              RewriteStringForEachStatement
            </summary>
            <remarks>
            NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
            We are diverging from the C# 4 spec (and Dev10) to follow the C# 5 spec.
            The iteration variable will be declared *inside* each loop iteration,
            rather than outside the loop.
            NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteEnumeratorForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a collection using an enumerator.
            
            E e = ((C)(x)).GetEnumerator()
            try {
                while (e.MoveNext()) {
                    V v = (V)(T)e.Current;
                    // body
                }
            }
            finally {
                // clean up e
            }
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.SynthesizeCall(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.Conversion,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Synthesize a no-argument call to a given method, possibly applying a conversion to the receiver.
            
            If the receiver is of struct type and the method is an interface method, then skip the conversion
            and just call the interface method directly - the code generator will detect this and generate a 
            constrained virtual call.
            </summary>
            <param name="syntax">A syntax node to attach to the synthesized bound node.</param>
            <param name="receiver">Receiver of method call.</param>
            <param name="method">Method to invoke.</param>
            <param name="receiverConversion">Conversion to be applied to the receiver if not calling an interface method on a struct.</param>
            <param name="convertedReceiverType">Type of the receiver after applying the conversion.</param>
            <returns>A BoundExpression representing the call.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteStringForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate the characters of a string.
            
            string s = x;
            for (int p = 0; p &lt; s.Length; p = p + 1) {
                V v = (V)s.Chars[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring string's 
            implementation of IEnumerable and just indexing into its characters.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteSingleDimensionalArrayForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a single-dimensional array.
            
            A[] a = x;
            for (int p = 0; p &lt; a.Length; p = p + 1) {
                V v = (V)a[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteMultiDimensionalArrayForEachStatement(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a multi-dimensional array.
            
            A[...] a = x;
            int q_0 = a.GetUpperBound(0), q_1 = a.GetUpperBound(1), ...;
            for (int p_0 = a.GetLowerBound(0); p_0 &lt;= q_0; p_0 = p_0 + 1)
                for (int p_1 = a.GetLowerBound(1); p_1 &lt;= q_1; p_1 = p_1 + 1)
                    ...
                        { V v = (V)a[p_0, p_1, ...]; /* body */ }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to nested for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.GetUnconvertedCollectionExpression(Roslyn.Compilers.CSharp.BoundForEachStatement)">
            <summary>
            So that the binding info can return an appropriate SemanticInfo.Converted type for the collection
            expression of a foreach node, it is wrapped in a BoundConversion to the collection type in the
            initial bound tree.  However, we may be able to optimize away (or entirely disregard) the conversion
            so we pull out the bound node for the underlying expression.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.AddForEachExpressionSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (Type var in |expr|) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.AddForEachIterationVariableSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (|Type var| in expr) { }
            </summary>
            <remarks>
            Hit every iteration.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.AddForEachKeywordSequencePoint(Roslyn.Compilers.CSharp.ForEachStatementSyntax,Roslyn.Compilers.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            |foreach| (Type var in expr) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitLockStatement(Roslyn.Compilers.CSharp.BoundLockStatement)">
             <summary>
             Lowers a lock statement to a try-finally block that calls Monitor.Enter and Monitor.Exit
             before and after the body, respectively.
             
             C# 4.0 version
             
             L locked;
             bool flag = false;
             try {
                 locked = `argument`;
                 Monitor.Enter(locked, ref flag);
                 `body`
             } finally {
                 if (flag) Monitor.Exit(locked);
             }
            
             Pre-4.0 version
             
             L locked = `argument`;
             Monitor.Enter(locked, ref flag);
             try {
                 `body`
             } finally {
                 Monitor.Exit(locked);
             }
             </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitUsingStatement(Roslyn.Compilers.CSharp.BoundUsingStatement)">
            <summary>
            Rewrite a using statement into a try finally statement.  Two forms are possible:
              1) using (expr) stmt
              2) using (C c = expr) stmt
              
            The former is handled by RewriteExpressionUsingStatement and the latter is handled by
            RewriteDeclarationUsingStatement (called in a loop, once for each local declared).
            </summary>
            <remarks>
            It would be more in line with our usual pattern to rewrite using to try-finally
            in the ControlFlowRewriter, but if we don't do it here the BoundMultipleLocalDeclarations
            will be rewritten into a form that makes them harder to separate.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteExpressionUsingStatement(Roslyn.Compilers.CSharp.BoundUsingStatement,Roslyn.Compilers.CSharp.BoundBlock)">
            <summary>
            Lower "using (expression) statement" to a try-finally block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteDeclarationUsingStatement(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundLocalDeclaration,Roslyn.Compilers.CSharp.BoundBlock,Roslyn.Compilers.CSharp.Conversion)">
            <summary>
            Lower "using (ResourceType resource = expression) statement" to a try-finally block.
            </summary>
            <remarks>
            Assumes that the local symbol will be declared (i.e. in the LocalsOpt array) of an enclosing block.
            Assumes that using statements with multiple locals have already been split up into multiple using statements.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteWinRtEvent(Roslyn.Compilers.CSharp.BoundEventAssignmentOperator,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            If we are in a WinRT type event, we need to encapsulate the adder call
            (Which returns an EventRegistrationToken) with a call to 
            WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these
            require us to create a new Func representing the adder and another
            Action representing the Remover.
            
            The rewritten call looks something like:
            
            WindowsRuntimeMarshal.AddEventHandler&lt;EventHandler&gt;
                (new Func&lt;EventHandler, EventRegistrationToken&gt;(@object.add), 
                 new Action&lt;EventRegistrationToken&gt;(@object.remove), handler);
            
            Where @object is a compiler - generated local temp.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeAssignmentOperator(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean)">
            <summary>
            Generates a lowered form of the assignment operator for the given left and right sub-expressions.
            Left and right sub-expressions must be in lowered form.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeArguments(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean,Roslyn.Compilers.ReadOnlyArray{System.Int32},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.RefKind}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.LocalSymbol}@)">
            <summary>
            Rewrites arguments of an invocation according to the receiving method or indexer.
            It is assumed that the each argument has already been lowered, but we may need
            additional rewriting for the arguments, such as generating a params array, re-ordering
            arguments based on argsToParamsOpt map, inserting arguments for optional parameters, etc.
            'optionalParametersMethod' is the method used for values of any optional parameters.
            For indexers, this method must be an accessor, and for methods it must be the method
            itself. 'optionalParametersMethod' is needed for indexers since the getter and setter
            may have distinct optional parameter values.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MergeArgumentsAndSideEffects(Roslyn.Compilers.CSharp.BoundExpression[],Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.RefKind},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundAssignmentOperator})">
            <summary>
            Process tempStores and add them as sideeffects to arguments where needed. The return
            value tells how many temps are actually needed. For unnecessary temps the corresponding
            temp store will be cleared.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.CreateObjectCreationExpression(Roslyn.Compilers.CSharp.BoundObjectCreationExpression,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.RefKind},Roslyn.Compilers.ConstantValue,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Build an object creation expression without performing any rewriting
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitUnaryOperator(Roslyn.Compilers.CSharp.BoundUnaryOperator)">
            <summary>
            This rewriter lowers pre-/post- increment/decrement operations (initially represented as
            unary operators). We use BoundSequenceExpressions because we need to capture the RHS of the
            assignment in a temp variable.
            </summary>
            <remarks>
            This rewriter assumes that it will be run before decimal rewriting (so that it does not have
            to lower decimal constants and operations) and call rewriting (so that it does not have to
            lower property accesses).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitIncrementOperator(Roslyn.Compilers.CSharp.BoundIncrementOperator)">
            <summary>
            The rewrites are as follows: suppose the operand x is a variable of type X. The
            chosen increment/decrement operator is modelled as a static method on a type T,
            which takes a value of type T and returns the result of incrementing or decrementing
            that value.
            
            x++
                X temp = x
                x = (X)(T.Increment((T)temp))
                return temp
            x--
                X temp = x
                x = (X)(T.Decrement((T)temp))
                return temp
            ++x
                X temp = (X)(T.Increment((T)x))
                x = temp
                return temp
            --x
                X temp = (X)(T.Decrement((T)x))
                x = temp
                return temp
                
            For example, we might have a class X with user-defined implicit conversions
            to and from short, but no user-defined increment or decrement operators. We
            would bind x++ as "X temp = x; x = (X)(short)((int)(short)temp + 1); return temp;"
            </summary>
            <param name="node">The unary operator expression representing the increment/decrement.</param>
            <returns>A bound sequence that uses a temp to acheive the correct side effects and return value.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeRValue(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Transform an expression from a form suitable as an lvalue to a form suitable as an rvalue.
            </summary>
            <param name="rewrittenExpression"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.RewriteBuiltInShiftOperation(Roslyn.Compilers.CSharp.BoundBinaryOperator,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BinaryOperatorKind,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,System.Int32)">
            <summary>
            Spec section 7.9: if the left operand is int or uint, mask the right operand with 0x1F;
            if the left operand is long or ulong, mask the right operand with 0x3F.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.MakeSizeOfMultiplication(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.PointerTypeSymbol,System.Boolean)">
            <summary>
            This rather confusing method tries to reproduce the functionality of ExpressionBinder::bindPtrAddMul and
            ExpressionBinder::bindPtrMul.  The basic idea is that we have a numeric expression, x, and a pointer type, 
            T*, and we want to multiply x by sizeof(T).  Unfortunately, we need to stick in some conversions to make
            everything work.
            
              1) If x is an int, then convert it to a IntPtr (i.e. a native int).  Dev10 offers no explanation (ExpressionBinder::bindPtrMul).
              2) Do overload resolution based on the (possibly converted) type of X and int (the type of sizeof(T)).
              3) If the result type of the chosen multiplication operator is signed, convert the product to IntPtr;
                 otherwise, convert the product to UIntPtr.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.VisitConditionalOperator(Roslyn.Compilers.CSharp.BoundConditionalOperator)">
            <summary>
            If the condition has a constant value, then just use the selected branch.
            e.g. "true ? x : y" becomes "x".
            
            In some special cases, it is also necessary to make implicit reference conversions
            explicit to satisfy CLR verification rules.  See IsUpdateRequiredForExplicitConversion.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.UpdateForExplicitConversionIfNecessary(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.BoundExpression@,Roslyn.Compilers.CSharp.BoundExpression@)">
            <summary>
            Determines whether it is necessary to perform an explicit conversion so that the
            types of two conditional branches will verifiably reconcile.
            </summary>
            <param name="destinationType">The expected type of both branches.</param>
            <param name="rewrittenConsequence">The first branch.</param>
            <param name="rewrittenAlternative">The second branch.  Updated (i.e. visited, converted, etc) if necessary.</param>
            <remarks>
            From ILGENREC::GenQMark
            See VSWhideby Bugs #49619 and 108643. If the destination type is an interface we need
            to force a static cast to be generated for any cast result expressions. The static cast
            should be done before the unifying jump so the code is verifiable and to allow the JIT to
            optimize it away. NOTE: Since there is no staticcast instruction, we implement static cast
            with a stloc / ldloc to a temporary.
            http://bugcheck/bugs/VSWhidbey/49619
            http://bugcheck/bugs/VSWhidbey/108643
            http://bugcheck/bugs/DevDivBugs/42645
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.TransformCompoundAssignmentLHS(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.LocalSymbol})">
            <summary>
            In the expanded form of a compound assignment (or increment/decrement), the LHS appears multiple times.
            If we aren't careful, this can result in repeated side-effects.  This creates (ordered) temps for all of the
            subexpressions that could result in side-effects and returns a side-effect-free expression that can be used
            in place of the LHS in the expanded form.
            </summary>
            <param name="originalLHS">The LHS sub-expression of the compound assignment (or increment/decrement).</param>
            <param name="stores">Populated with a list of assignment expressions that initialize the temporary locals.</param>
            <param name="temps">Populated with a list of temporary local symbols.</param>
            <returns>A side-effect-free expression representing the LHS.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LocalRewriter.Rewrite(System.Boolean,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.SynthesizedSubmissionFields,System.Boolean@)">
            <summary>
            Lower a block of code by performing local rewritings.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.state">
            <summary>
            The "state" of the state machine that is the translation of the iterator method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.current">
            <summary>
            The field of the generated iterator class that underlies the Current property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.dispatches">
            <summary>
            For each distinct label, the set of states that need to be dispatched to that label.
            Note that there is a dispatch occurring at every try-finally statement, so this
            variable takes on a new set of values inside each try block.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.finalizerStateMap">
            <summary>
            A mapping from each state of the state machine to the new state that will be used to execute
            finally blocks in case the state machine is disposed.  The Dispose method computes the new state
            and then runs MoveNext.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.hasFinalizerState">
            <summary>
            A try block might have no state (transitions) within it, in which case it does not need
            to have a state to represent finalization.  This flag tells us whether the current try
            block that we are within has a finalizer state.  Initially true as we have the (trivial)
            finalizer state of -1 at the top level.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.IteratorRewriter.currentFinalizerState">
            <summary>
            If hasFinalizerState is true, this is the state for finalization from anywhere in this
            try block.  Initially set to -1, representing the no-op finalization required at the top
            level.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.IteratorRewriter.RewriteIterator(Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Rewrite an iterator method into a state machine class.
            </summary>
            <param name="body">The original body of the method</param>
            <param name="method">The method's identity</param>
            <param name="compilationState">The collection of generated methods that result from this transformation and which must be emitted</param>
            <param name="diagnostics">Diagnostic bag for diagnostics.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.IteratorRewriter.VisitTryStatement(Roslyn.Compilers.CSharp.BoundTryStatement)">
            <summary>
            The try statement is the most complex part of the state machine transformation.
            Since the CLR will not allow a 'goto' into the scope of a try statement, we must
            generate the dispatch to the state's label stepwise.  That is done by translating
            the try statements from the inside to the outside.  Within a try statement, we
            start with an empty dispatch table (representing the mapping from state numbers
            to labels).  During translation of the try statement's body, the dispatch table
            will be filled in with the data necessary to dispatch once we're inside the try
            block.  We generate that at the head of the translated try statement.  Then, we
            copy all of the states from that table into the table for the enclosing construct,
            but associate them with a label just before the translated try block.  That way
            the enclosing construct will generate the code necessary to get control into the
            try block for all of those states.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IteratorRewriter.IteratorCaptureWalker">
            <summary>
            A walker that computes the set of local variables of an iterator
            method that must be moved to fields of the generated class.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IteratorRewriter.IteratorClass">
            <summary>
            The class that represents a translated iterator method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedClass">
            <summary>
            A class synthesized for a lambda or iterator method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSymbol">
            <summary>
            A TypeSymbol is a base class for all the symbols that represent a type
            in C#.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty IEnumerable. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(Roslyn.Compilers.CSharp.TypeDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetSourceTypeMember(System.String,System.Int32,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Get a source type symbol of given name, arity and kind.  If a tree and syntax are provided, restrict the results
            to those that are declared within the given syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.LookupMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup an immediately nested type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedTypeName">
            Simple type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types or namespaces described by a qualified name.
            </summary>
            <param name="qualifiedName">Sequence of simple plain names.</param>
            <returns>
            A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities), 
            or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist).
            </returns>
            <remarks>
            "C.D" matches C.D, C{T}.D, C{S,T}.D{U}, etc.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. Equivalent to !IsNamespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.MakeAllInterfaces">
            Produce all implemented interfaces in topologically sorted order. We use
            TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
            long dependency cycles removed. Consequently, it is possible (and we do) use the
            simplest version of Tarjan's topological sorting algorithm.
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindImplementationForInterfaceMember(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.GetUseSiteErrorInfo">
            <summary>
            Returns error info for an error, if any, that should be reported at the use site of the symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.GetUseSiteErrorInfo(System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol}@)">
            <summary>
            Has the same purpose as the one above, but carries a hash set of types that are being checked or have been checked
            already in order to avoid duplicate work and, more importantly, avoid infinite loops due to cyclic type references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ComputeImplementationForInterfaceMember(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Performs interface mapping (spec 13.4.4).
            </summary>
            <remarks>
            CONSIDER: we could probably do less work in the metadata and retargeting cases - we won't use the diagnostics.
            </remarks>
            <param name="interfaceMember">A non-null property on an interface type.</param>
            <param name="implementingType">The type implementing the interface property (usually "this").</param>
            <param name="diagnostics">Bag to which to add diagnostics.</param>
            <returns>The implementing property or null, if there isn't one.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.CheckForImplementationOfCorrespondingPropertyOrEvent(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,Roslyn.Compilers.CSharp.Symbol@)">
            <summary>
            If we were looking for an accessor, then look for an accessor on the implementation of the
            corresponding interface property/event.  If it is valid as an implementation (ignoring the name),
            then prefer it to our current result if:
              1) our current result is null; or
              2) our current result is on the same type.
              
            If there is no corresponding accessor on the implementation of the corresponding interface
            property/event and we found an accessor, then the accessor we found is invalid, so clear it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ReportImplicitImplementationMatchDiagnostics(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            These diagnostics are for members that do implicitly implement an interface member, but do so
            in an undesirable way.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.ReportImplicitImplementationMismatchDiagnostics(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            These diagnostics are for members that almost, but not actually, implicitly implement an interface member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.FindPotentialImplicitImplementationMemberDeclaredInType(Roslyn.Compilers.CSharp.Symbol,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Symbol@,Roslyn.Compilers.CSharp.Symbol@)">
            <summary>
            Search the declared members of a type for one that could be an implementation
            of a given interface member (depending on interface declarations).
            </summary>
            <param name="interfaceMember">The interface member being implemented.</param>
            <param name="implementingTypeIsFromSource">The value of implementingType.OriginalDefinition.IsFromSource (avoid recomputing repeatedly).</param>
            <param name="currType">The type on which we are looking for a declared implementation of the interface member.</param>
            <param name="implicitImpl">A member on currType that could implement the interface, or null.</param>
            <param name="closeMismatch">A member on currType that could have been an attempt to implement the interface, or null.</param>
            <remarks>
            There is some similarity between this member and MemberSymbol.FindOverriddenOrHiddenMembersInType.
            When making changes to this member, think about whether or not they should also be applied in MemberSymbol.
            One key difference is that custom modifiers are considered when looking up overridden members, but
            not when looking up implicit implementations.  We're preserving this behavior from Dev10.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbol.IsInterfaceMemberImplementation(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol,System.Boolean)">
             <summary>
             To implement an interface member, a candidate member must be public, non-static, and have
             the same signature.  "Have the same signature" has a looser definition if the type implementing
             the interface is from source.
             </summary>
             <remarks>
             PROPERTIES:
             NOTE: we're not checking whether this property has at least the accessors
             declared in the interface.  Dev10 considers it a match either way and,
             reports failure to implement accessors separately.
            
             If the implementing type (i.e. the type with the interface in its interface
             list) is in source, then we can ignore custom modifiers in/on the property
             type because they will be copied into the bridge property that explicitly
             implements the interface property (or they would be, if we created such
             a bridge property).  Bridge *methods* (not properties) are inserted in 
             SourceNamedTypeSymbol.ImplementInterfaceMember.
            
             CONSIDER: The spec for interface mapping (13.4.4) could be interpreted to mean that this
             property is not an implementation unless it has an accessor for each accessor of the
             interface property.  For now, we prefer to represent that case as having an implemented
             property and an unimplemented accessor because it makes finding accessor implementations
             much easier.  If we decide that we want the API to report the property as unimplemented,
             then it might be appropriate to keep current result internally and just check the accessors
             before returning the value from the public API (similar to the way MethodSymbol.OverriddenMethod
             filters MethodSymbol.OverriddenOrHiddenMembers.
             </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.BaseType">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively).  Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerble&lt;object&gt;
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.InterfacesAndTheirBaseInterfaces">
            <summary>
            Gets the set of interfaces that this type directly implements, plus the base interfaces
            of all such types.
            </summary>
            <remarks>
            CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
            alternative approaches (recompute every time, cache on the side, only store on some types,
            etc).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.SpecialType">
            <summary>
            Gets corresponding special TypeId of this type.
            </summary>
            <remarks>
            Not preserved in types constructed from this one.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.PrimitiveTypeCode">
            <summary>
            Gets corresponding primitive type code for this type declaration.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including delegate).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.IsManagedType">
            <summary>
            Is this type a managed type (false for everything but enum, pointer, and
            some struct types).
            </summary>
            <remarks>
            See Type::computeManagedType.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeSymbol.AbstractMembers">
            <summary>
            The set of abstract members in declared in this type or declared in a base type and not overridden.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSymbol.SymbolAndDiagnostics">
            <summary>
            Represents the method by which this type implements a given interface type
            and/or the corresponding diagnostics.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.InterfacesVisit(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.Emit.Module,Roslyn.Compilers.ArrayBuilder{Microsoft.Cci.ITypeReference},System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.NamedTypeSymbol}@)">
            <summary>
            Add the type to the builder and then recurse on its interfaces.
            </summary>
            <remarks>
            Pre-order depth-first search.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetOperators(System.String)">
            <summary>
            Get the operators for this type by their metadata name
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetAttributeUsageInfo">
            <summary>
            Gets the associated attribute usage info for an attribute type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.MakeMetadataName(System.String@)">
            <summary>
            Return the name including the metadata arity suffix, and whether it was truncated.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.MakeMetadataName(System.String@,System.String@)">
            <summary>
            Make the metadata name and the unsuffixed metadata name
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>A ReadOnlyArraycontaining all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Used to implement visitor pattern.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetEarlyAttributeDecodingMembers">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Equals(System.Object)">
            <summary>
            Compares this symbol to an object.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.EqualsComplicatedCases(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Helper for more complicated cases of Equals like when we have generic instantiations or types nested within them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetHashCode">
            <summary>
            Returns hash code of this symbol.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Construct(Roslyn.Compilers.CSharp.TypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.Construct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetAllTypeParameters(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.TypeParameterSymbol})">
            <summary>
            Return all of the type parameters in this type and enclosing types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.FindEnclosingTypeParameter(System.String)">
            <summary>
            Return the nearest type parameter with the given name in
            this type or any enclosing type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamedTypeSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ReadOnlyArray.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.KnownCircularStruct">
            <summary>
            Returns true for a struct type containing a cycle.
            This property is intended for flow analysis only
            since it is only implemented for source types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that is is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Indexers">
            <summary>
            Get the indexers for this type.
            </summary>
            <remarks>
            Won't include indexers that are explicit interface implementations.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this type might contain extension methods. If this property
            returns false, there are no extension methods in this type.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MangleName">
            <summary>
            Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
            Must return False for a type with Arity == 0.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type.  These occur only
            within a <code>typeof</code> expression.  A generic type is considered <em>unbound</em>
            if all of the type argument lists in its fully qualified name are empty.
            Note that the type arguments of an unbound generic type will be returned as error
            types because they do not really have type arguments.  An unbound generic type
            yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic type instantiation, returns null.
            The map targets the original definition of the type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsComImport">
            <summary>
            Returns a flag indicating whether this symbol is ComImport.
            </summary>
            <remarks>
            A type can me marked as a ComImport type in source by applying the <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.IsSerializable">
            <summary>
            True if the type is serializable (has Serializable metadata flag).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.Layout">
            <summary>
            Type layout information (ClassLayout metadata and layout kind flags).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.DefaultMarshallingCharSet">
            <summary>
            The default charset used for type marshalling. 
            Can be changed via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.MarshallingCharSet">
            <summary>
            Marshalling charset of string data fields within the type (string formatting flags in metadata).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamedTypeSymbol.ComImportCoClass">
            <summary>
            If CoClassAttribute was applied to the type and the attribute argument is a valid named type argument, i.e. accessible class type, then it returns the type symbol for the argument.
            Otherwise, returns null.
            </summary>
            <remarks>
            <para>
            This property invokes force completion of attributes. If you are accessing this property
            from the binder, make sure that we are not binding within an Attribute context.
            This could lead to a possible cycle in attribute binding.
            We can avoid this cycle by first checking if we are within the context of an Attribute argument,
            i.e. if(!binder.InAttributeArgument) { ...  namedType.ComImportCoClass ... }
            </para>
            <para>
            CONSIDER: We can remove the above restriction and possibility of cycle if we do an
            early binding of some well known attributes.
            </para>
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IteratorRewriter.IteratorConstructor">
            <summary>
            The constructor of the class that is the translation of an iterator method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntheticBoundNodeFactory">
            <summary>
            A helper class for synthesizing quantities of code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntheticBoundNodeFactory.CheckSwitchSections(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundSwitchSection})">
            <summary>
            Check for (and assert that there are no) duplicate case labels in the switch.
            </summary>
            <param name="sections"></param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CheckedUncheckedBinder">
            <summary>
            Controls overflow checks. Created for checked/unchecked blocks.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BuckStopsHereBinder">
            <summary>
            A binder that knows no symbols and will not delegate further.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.UnsafeBinder">
            <summary>
            Indicates that the current context allows unsafe constructs.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SuppressUnsafeDiagnosticsBinder">
            <summary>
            Indicates that the unsafe diagnostics are not reported in the current context, regardless
            of whether or not it is (part of) an unsafe region.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.IsBaseDefinitionOfDefinition(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Determines if a class, struct or interface (the base type) is identical to or
            a base type of the derived type, considering only the declarations. 
            </summary>
            <remarks>
            Object is NOT considered a base of an interface but is considered as base of a struct. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.ClassifyConversion(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.ClassifyConversionForCast(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.ClassifyStandardConversion(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any standard implicit or standard explicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.ClassifyImplicitConversion(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any user-defined or built-in implicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversions(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <remarks>
            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversionForSwitchGoverningType.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.ComputeApplicableUserDefinedImplicitConversionSet(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.NamedTypeSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.UserDefinedConversionAnalysis},System.Boolean)">
            <summary>
            This method find the set of applicable user-defined and lifted conversion operators, u.
            The set consists of the user-defined and lifted implicit conversion operators declared by
            the classes and structs in d that convert from a type encompassing source to a type encompassed by target.
            However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source
            to any target. This flag must be set only if we are computing user defined conversions from a given source
            type to any target type.
            </summary>
            <remarks>
            Currently allowAnyTarget flag is only set to true by AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,
            where we must consider user defined implicit conversions from the type of the switch expression to
            any of the possible switch governing types.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <remarks>
            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverloadResolution.HidesByName(Roslyn.Compilers.CSharp.Symbol)">
            <remarks>
            This is specifically a private helper function (rather than a public property or extension method)
            because applying this predicate to a non-method member doesn't have a clear meaning.  The goal was
            simply to avoid repeating ad-hoc code in a group of related collections.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundNode.HasErrors">
            <summary>
            Determines if a bound node, or any child, grandchild, etc has an error (not warning)
            diagnostic associated with it. The HasError bit is initially set for a node by providing it
            to the node constructor. If any child nodes of a node have
            the HasErrors bit set, then it is automatically set to true on the parent bound node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundNode.WasCompilerGenerated">
            <remarks>
            NOTE: not generally set in rewriters.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundExpression.Display">
            <summary>
            Returns a serializable object that is used for displaying this expression in a diagnostic message.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundQueryClause.Operation">
            <summary>
            The bound expression that invokes the operation of the query clause.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundQueryClause.Cast">
            <summary>
            The bound expression that is the invocation of a "Cast" method specified by the query translation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundQueryClause.UnoptimizedForm">
            <summary>
            The bound expression that is the query expression in "unoptimized" form.  Specifically, a final ".Select"
            invocation that is omitted by the specification is included here.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberSemanticModel">
            <summary>
            Binding info for expressions and statements that are part of a member declaration.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to <see cref="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation"/>.<see cref="M:Compilation.GetSemanticModel"/>. 
            </summary>
            <remarks>
            <para>An instance of <see cref="T:Roslyn.Compilers.CSharp.SemanticModel"/> caches local symbols and semantic
            information. Thus, it is much more efficient to use a single instance of <see cref="T:Roslyn.Compilers.CSharp.SemanticModel"/> when asking multiple questions about a syntax tree, because
            information from the first question may be reused. This also means that holding onto an
            instance of SemanticModel for a long time may keep a significant amount of memory from being
            garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> of the <see cref="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation"/>),
            that symbol will be returned (i.e. the returned value will be reference-equal to one
            reachable from the root of the symbol table). Symbols representing entities without names
            (e.g. array-of-int) may or may not exhibit reference equality. However, some named symbols
            (such as local variables) are not reachable from the root. These symbols are visible as
            answers to semantic questions. When the same SemanticModel object is used, the answers
            exhibit reference-equality.  
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfoWorker(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options">Options to control behavior.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetTypeInfoWorker(Roslyn.Compilers.CSharp.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetMemberGroupWorker(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetIndexerGroupWorker(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of indexer symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetConstantValueWorker(Roslyn.Compilers.CSharp.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets a the constant value for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativelyBoundNode(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption,Roslyn.Compilers.CSharp.Binder@)">
            <summary>
            Bind the given expression speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativelyBoundAttribute(System.Int32,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.CSharp.Binder@)">
            <summary>
            Bind the given attribute speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfo(Roslyn.Compilers.CSharp.OrderingSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfo(Roslyn.Compilers.CSharp.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfo(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfo(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSymbolInfo(Roslyn.Compilers.CSharp.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The symbol information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
            the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that
            the attribute is being applied to.
            </param>
            <param name="attribute">A syntax node that represents a parsed attribute. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the attribute.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the constructor initializer.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetTypeInfo(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a constructor initializer.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetTypeInfo(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an expression.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetTypeInfo(Roslyn.Compilers.CSharp.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an attribute.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeTypeInfo(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The type information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetIndexerGroup(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
            <param name="expression">Potential indexer receiver.</param>
            <param name="cancellationToken">To cancel the computation.</param>
            <returns>Accessible, non-hidden indexers.</returns>
            <remarks>
            If the receiver is an indexer expression, the list will contain the indexers that could be applied to the result
            of accessing the indexer, not the set of candidates that were considered during construction of the indexer expression.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetQueryClauseInfo(Roslyn.Compilers.CSharp.QueryClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetAliasInfo(Roslyn.Compilers.CSharp.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="nameSyntax"/> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetSpeculativeAliasInfo(System.Int32,Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the binder that encloses the position.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetMemberModel(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets the MemberSemanticModel that contains the node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.CheckAndAdjustPosition(System.Int32)">
            <summary>
            Given a position, locates the containing token.  If the position is actually within the
            leading trivia of the containing token or if that token is EOF, moves one token to the
            left.  Returns the start position of the resulting token.
            
            This has the effect of moving the position left until it hits the beginning of a non-EOF
            token.
            
            Throws an ArgumentOutOfRangeException if position is not within the root of this model.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetAdjustedNodePosition(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            A convenience method that determines a position from a node.  If the node is missing,
            then its position will be adjusted using CheckAndAdjustPosition.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.LookupSymbols(System.Int32,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,System.String,System.Nullable{System.Int32},Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional
            container. Only symbols that are accessible and visible from the given location are
            returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="arity">The number of generic type parameters the symbol has. If null is
            specified then symbols with any arity are returned.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
            <exception cref="T:System.ArgumentException">Throws an argument exception if the passed lookup options are invalid.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AddLookupSymbolsInfo(System.Int32,Roslyn.Compilers.CSharp.LookupSymbolsInfo,Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Gets the names of the available named symbols in the context of the specified location
            and optional container. Only symbols that are accessible and visible from the given
            location are returned.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="info">A lookup table that given a symbol name returns all present
            arities and/or a symbol if unique.</param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <returns>A list of names of symbols that were found. If no symbols were found, an empty
            list is returned. 
            </returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.IsAccessible(System.Int32,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.IsEventUsableAsField(System.Int32,Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetBindableParentNode(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            If the node is an expression, return the nearest parent node
            with semantic meaning. Otherwise return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeControlFlow(Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeControlFlow(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Analyze data-flow within an expression. 
            </summary>
            <param name="expression">The expression within the associated SyntaxTree to analyze.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.AnalyzeDataFlow(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversion(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversion(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversionForCast(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ClassifyConversionForCast(System.Int32,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this
            object. Does not get errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for
            diagnostics, it may take a significant amount of time. Unlike GetDeclarationDiagnostics,
            diagnostics for method bodies and initializers are not cached, the any semantic
            information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares an anonymoust object.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding
            symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was
            introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="typeParameter"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="forEachStatement"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="catchDeclaration"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.JoinIntoClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.QueryContinuationSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ResolveOverloads``1(System.Int32,Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ArgumentSyntax})">
            <summary>
            Resolves the set of provided arguments against set of provided methods to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            binding. An OverloadResolutionResult is returned that gives the result of the compiler's
            overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="members">The set of methods to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
            <param name="typeArguments">If present, the type argument provided. If not provided,
            type inference is done.</param>
            <remarks>
            This can be used to resolve constructors as well as methods.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.ResolveIndexerOverloads(System.Int32,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.PropertySymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ArgumentSyntax})">
            <summary>
            Resolves the set of provided arguments against set of provided indexers to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            binding. An OverloadResolutionResult is returned that gives the result of the compiler's
            overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="indexers">The set of indexers to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetIndexerGroupSemanticSymbols(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Binder)">
            <summary>
            Returns a list of accessible, non-hidden indexers that could be invoked with the given expression
            as a receiver.
            </summary>
            <remarks>
            If the given expression is an indexer access, then this method will return the list of indexers
            that could be invoked on the result, not the list of indexers that were considered.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetNamedArgumentSymbolInfo(Roslyn.Compilers.CSharp.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the semantic info of a named argument in an invocation-like expression.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.FindNamedParameter(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol},System.String)">
            <summary>
            Find the first parameter named "argumentName".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.CreateReducedExtensionMethodsFromOriginalsIfNecessary(Roslyn.Compilers.CSharp.BoundCall)">
            <summary>
            If the call represents an extension method invocation with an explicit receiver, return the original
            methods as ReducedExtensionMethodSymbols. Otherwise, return the original methods unchanged.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.CreateReducedExtensionMethodIfNecessary(Roslyn.Compilers.CSharp.BoundCall)">
            <summary>
            If the call represents an extension method with an explicit receiver, return a
            ReducedExtensionMethodSymbol. Otherwise, return the original call method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetForEachStatementInfo(Roslyn.Compilers.CSharp.ForEachStatementSyntax)">
            <summary>
            Gets for each statement info.
            </summary>
            <param name="node">The node.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this ISemanticModel returns the innermost
            NamedType that the positoin is considered inside of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.Root">
            <summary>
            The root node of the syntax tree that this binding is based on.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions">
            <summary>
            Options to control the internal working of GetSymbolInfoWorker. Not currently exposed
            to public clients, but could be if desired.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions.PreferTypeToConstructors">
            <summary>
            When binding "C" new C(...), return the type C and do not return information about
            which constructor was bound to. Bind "new C(...)" to get information about which constructor
            was chosen.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions.PreferConstructorsToType">
            <summary>
            When binding "C" new C(...), return the constructor of C that was bound to, if C unambiguously
            binds to a single type with at least one constructor. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions.ResolveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return OtherTypeOrNamespace.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SemanticModel.SymbolInfoOptions.PreserveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return the alias symbol X.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetEnclosingBinder(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            This overload exists for callers who
              a) Already have a node in hand and don't want to search through the tree
              b) May want to search from an indirect container (e.g. node containing node
                 containing position).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetBoundRoot">
            <summary>
            Get the bound node corresponding to the root.
            </summary> 
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetUpperBoundNode(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Get the highest bound node in the tree associated with a particular syntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetLowerBoundNode(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last
            in a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this
            object. Does not get errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for
            diagnostics, it may take a significant amount of time. Unlike GetDeclarationDiagnostics,
            diagnostics for method bodies and initializers are not cached, the any semantic
            information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetLambdaEnclosingBinder(System.Int32,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.ExecutableCodeBinder)">
            <summary>
            Performs the same function as GetEnclosingBinder, but is known to take place within a
            specified lambda.  Walks up the syntax hierarchy until a node with an associated binder
            is found.
            </summary>
            <remarks>
            CONSIDER: can this share code with MemberSemanticModel.GetEnclosingBinder?
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.GetBoundNodes(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Get all bounds nodes associated with a node, ordered from highest to lowest in the bound tree.
            Strictly speaking, the order is that of a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberSemanticModel.MemberSymbol">
            <summary>
            The member symbol 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberSemanticModel.RootBinder">
            <summary>
            The root binder (this binder will parent the interior block binders)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.NodeMapBuilder.AddToMap(Roslyn.Compilers.CSharp.BoundNode,System.Collections.Generic.Dictionary{Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundNode}},Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Walks the bound tree and adds all non compiler generated bound nodes whose syntax matches the given one
            to the cache.
            </summary>
            <param name="root">The root of the bound tree.</param>
            <param name="map">The cache.</param>
            <param name="node">The syntax node where to add bound nodes for.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.NodeMapBuilder.ShouldAddNode(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Decides whether to the add the bound node to the cache or not.
            </summary>
            <param name="currentBoundNode">The bound node.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberSemanticModel.IncrementalBinder">
            <summary>
            The incremental binder is used when binding statements. Whenever a statement
            is bound, it checks the bound node cache to see if that statement was bound, 
            and returns it instead of rebinding it. 
            
            For example, we might have:
               while (x > foo())
               {
                 y = y * x;
                 z = z + y;
               }
            
            We might first get semantic info about "z", and thus bind just the statement
            "z = z + y". Later, we might bind the entire While block. While binding the while
            block, we can reuse the binding we did of "z = z + y".
            </summary>
            <remarks>
            NOTE: any member overridden by this binder should follow the BuckStopsHereBinder pattern.
            Otherwise, a subsequent binder in the chain could suppress the caching behavior.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSemanticModel.IncrementalBinder.GetBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            We override GetBinder so that the BindStatement override is still
            in effect on nested binders.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeCompilationState">
            <summary>
            Represents the state of compilation of one particular type.
            This includes, for example, a collection of synthesized methods created during lowering. 
            </summary>
            <remarks>
            WARNING: Note that the collection class is not thread-safe and will 
            need to be revised if emit phase is changed to support multithreading when
            translating a particular type.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.TypeCompilationState.generatedMethods">
            <summary> Flat array of created methods, non-empty if not-null </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.TypeCompilationState.wrappers">
            <summary> 
            Map of wrapper methods created for base access of base type virtual methods from 
            other classes (like those created for lambdas...); actually each method symbol will 
            only need one wrapper to call it non-virtually.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.TypeCompilationState.IteratorImplementationClass">
            <summary>
            A mapping from (source) iterator methods to the compiler-generated classes that implement them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeCompilationState.AddGeneratedMethod(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundStatement)">
            <summary> Add a 'regular' generated method </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeCompilationState.AddMethodWrapper(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundStatement)">
            <summary> 
            Add a 'wrapper' method and map it to the original one so it can be reused. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeCompilationState.GetMethodWrapper(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary> 
            Get a 'wrapper' method for the original one. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeCompilationState.Free">
            <summary> Free resources allocated for this method collection </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.EmitModule">
            <summary>
            The Emit.Module for generating code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.CurrentDebugImports">
            <summary>
            Any generated methods that don't suppress debug info will use this
            list of debug imports.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.Type">
            <summary>
            The type for which this compilation state is being used.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.AnyGeneratedMethods">
            <summary> Any methods? </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.NextWrapperMethodIndex">
            <summary> The index of the next wrapped method to be used </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeCompilationState.GeneratedMethods">
            <summary> Method/body collection </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeCompilationState.MethodWithBody">
            <summary> Synthesized method info </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterSymbol">
            <summary>
            Represents a parameter of a method or indexer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParameterSymbol.Microsoft#Cci#IParameterDefinition#GetDefaultValue">
            <summary>
            Gets constant value to be stored in metadata Constant table.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ParameterSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.RefKind">
            <summary>
            Determines if the parameter ref, out or neither.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.MarshallingInformation">
            <summary>
            Describes how the parameter is marshalled when passed to native code.
            Null if no specific marshalling information is available for the parameter.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this parameter, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The "'this' parameter has ordinal -1.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is semantically optional.
            </summary>
            <remarks>
            True iff the parameter has a default argument syntax, 
            or the parameter is not a params-array and Optional metadata flag is set.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsMetadataOptional">
            <summary>
            True if Optional flag is set in metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsMetadataIn">
            <summary>
            True if Out flag is set in metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsMetadataOut">
            <summary>
            True if In flag is set in metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.HasDefaultValue">
            <summary>
            Returns true if the parameter explicitly specifies a default value to be passed
            when no value is provided as an argument to a call.
            </summary>
            <remarks>
            True if the parameter has a default argument syntax, 
            or the parameter is from source and <see cref="T:System.Runtime.InteropServices.DefaultParameterValueAttribute"/> is applied, 
            or the parameter is from metadata and HasDefault metadata flag is set.
            
            The default value can be obtained with <see cref="P:Roslyn.Compilers.CSharp.ParameterSymbol.DefaultValue"/> property.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.DefaultValue">
            <summary>
            Returns the default value of the parameter. If HasDefaultValue
            returns false then DefaultValue throws an InvalidOperationException.
            </summary>
            <remarks>
            If the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type, then this property will return null.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.DefaultConstantValue">
            <summary>
            Returns the default value constant of the parameter, 
            or null if the parameter doesn't have a default value or 
            the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeField">
            <summary>
            Describes anonymous type field in terms of its name, type and other attributes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeField.Name">
            <summary>Anonymous type field name, not nothing and not empty</summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeField.Location">
            <summary>Anonymous type field location</summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeField.Type">
            <summary>Anonymous type field type</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeField.IsGood">
            <summary> 
            'true' if all the attributes are not null
            This is ONLY used for debugging purpose
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager">
            <summary>
            Manages anonymous types created on module level. All requests for anonymous type symbols 
            go via the instance of this class, the symbol will be either created or returned from cache.
            </summary>
            <summary>
            Manages anonymous types created in owning compilation. All requests for 
            anonymous type symbols go via the instance of this class.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.concurrentTypesCache">
            <summary>
            Cache of created anonymous type templates used as an implementation of anonymous 
            types in emit phase.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.anonymousTypeTemplatesSetIsSealed">
            <summary>
            We should not see new anonymous types from source after we finished emit phase, 
            this field seals the collection; in DEBUG it also is used to check the assertion.
            
            Note, 0 means the collection is not sealed, any other value seals the collection.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.ConstructAnonymousTypeImplementationSymbol(Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol)">
            <summary>
            Given anonymous type provided constructs an implementation type symbol to be used in emit phase; 
            if the anonymous type has at least one field the implementation type symbol will be created based on 
            a generic type template generated for each 'unique' anonymous type structure, otherwise the template
            type will be non-generic.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.AssignTemplatesNamesAndCompile(Roslyn.Compilers.CSharp.MethodBodyCompiler,Roslyn.Compilers.CSharp.Emit.Module,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Resets numbering in anonymous type names and compiles their methods
            NOTE: this call also seals the collection of templates so after it is called once
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.IsAnonymousTypeTemplate(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns true if the named type is an implementation template for an anonymous type
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.GetAnonymousTypeHiddenMethods(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Retrieves methods of anonymous type template which are not placed to symbol table.
            In current implementation those are overriden 'ToString', 'Equals' and 'GetHashCode'
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.TranslateAnonymousTypeSymbol(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Translates anonymus type public symbol into an implementation type symbol to be used in emit.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Translates anonymus type method symbol into an implementation method symbol to be used in emit.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.ReportMissingOrErroneousSymbols(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Reports all use site errors in special or well known symbols required for anonymous types
            </summary>
            <returns>true if there was at least one error</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Roslyn.Compilers.CSharp.AnonymousTypeDescriptor)">
            <summary>
            Given anonymous type descriptor provided constructs an anonymous type symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.GetAnonymousTypeProperty(Roslyn.Compilers.CSharp.NamedTypeSymbol,System.Int32)">
            <summary>
            Get a symbol of constructed anonymous type property by propery index
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.GetAnonymousTypePropertyTypes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Retrieves anonymous type properties types
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Given an anonymous type and new field types construct a new anonymous type symbol; 
            a new type symbol will reuse type descriptor from the constructed type with new type arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.IsSameType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Logical equality on anonymous types that ignores custom modifiers and/or the object/dynamic distinction.
            Differs from IsSameType for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeManager.AreTemplatesSealed">
            <summary>
            Collection of anonymous type templates is sealed 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeManager.AllCreatedTemplates">
            <summary>
            Returns all templates owned by this type manager
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeManager.Compilation">
            <summary> 
            Current compilation
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeComparer">
            <summary> 
            Comparator being used for stable ordering in anonymous type indices.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol">
            <summary>
            Represents an anonymous type 'public' symbol which is used in binding and lowering.
            In emit phase it is being substituted with implementation symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol.Properties">
            <summary> Properties defined in the type </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol.name2symbol">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePublicSymbol.TypeDescriptor">
            <summary> Anonymous type descriptor </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeConstructorSymbol">
            <summary>
            Represents an anonymous type constructor.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.SynthesizedMethodBase">
            <summary>
            Represents a base implementation for anonymous type synthesized methods.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePropertyGetAccessorSymbol">
            <summary>
            Represents a getter for anonymous type property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeEqualsMethodSymbol">
            <summary>
            Represents an anonymous type 'Equals' method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeGetHashCodeMethodSymbol">
            <summary>
            Represents an anonymous type 'GetHashCode' method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeToStringMethodSymbol">
            <summary>
            Represents an anonymous type 'ToString' method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol">
            <summary>
            Represents an anonymous type 'template' which is a generic type to be used for all 
            anonymous type having the same structure, i.e. the same number of fields and field names.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.metadataEntityName">
            <summary> Name to be used as metadata name during emit </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.SpecialMembers">
            <summary> This list consists of synthesized method symbols for ToString, 
            Equals and GetHashCode which are not part of symbol table </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.Properties">
            <summary> Properties defined in the template </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.name2symbol">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.smallestLocation">
            <summary> Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.TypeDescriptorKey">
            <summary> Key pf the anonymous type descriptor </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.AdjustLocation(Roslyn.Compilers.CSharp.Location)">
            <summary>
            In emit phase every time a created anonymous type is referenced we try to store the lowest 
            location of the template. It will be used for ordering templates and assigning emitted type names.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeTemplateSymbol.SmallestLocation">
            <summary>
            Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT;
            
            NOTE: if this property is queried, smallest location must not be null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypePropertySymbol">
            <summary>
            Represents an anonymous type template's property symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.PropertySymbol.lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
            <remarks>
            In source, we regard a property as an indexer if it is declared with an IndexerDeclarationSyntax.
            From metadata, we regard a property if it has parameters and is a default member of the containing
            type.
            CAVEAT: To ensure that this property (and indexer Names) roundtrip, source properties are not
            indexers if they are explicit interface implementations (since they will not be marked as default
            members in metadata).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsIndexedProperty">
            <summary>
            True if this an indexed property; that is, a property with parameters
            within a [ComImport] type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertySymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeParameterSymbol">
            <summary>
            Represents an anonymous type template's type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeParameterSymbol.EnsureAllConstraintsAreResolved">
            <summary>
            Called by ConstraintTypes, Interfaces, EffectiveBaseType, and DeducedBaseType
            to allow derived classes to ensure constraints within the containing
            type or method are resolved in a consistent order, regardless of the
            order the callers query individual type parameters.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeParameterSymbol.EnsureAllConstraintsAreResolved(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeParameterSymbol})">
            <summary>
            Helper method to force type parameter constraints to be resolved.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeParameterSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            Duplicates and cycles are removed, although the collection may include
            redundant constraints where one constraint is a base type of another.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.IsMethodTypeParameter">
            <summary>
            True if the type parameter was declared by a generic method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.DeclaringType">
            <summary>
            The type that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.EffectiveBaseType">
            <summary>
            The effective base class of the type parameter (spec 10.1.5). If the deduced
            base type is a reference type, the effective base type will be the same as
            the deduced base type. Otherwise if the deduced base type is a value type,
            the effective base type will be the most derived reference type from which
            deduced base type is derived.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.EffectiveInterfaces">
            <summary>
            The effective interface set (spec 10.1.5).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.DeducedBaseType">
            <summary>
            The most encompassed type (spec 6.4.2) from the constraints.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSymbol.AllEffectiveInterfaces">
            <summary>
            The effective interface set and any base interfaces of those
            interfaces. This is AllInterfaces excluding interfaces that are
            only implemented by the effective base type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeManager.AnonymousTypeFieldSymbol">
            <summary>
            Represents a baking field for an anonymous type template property symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.FieldSymbol">
            <summary>
            Represents a field in a class, struct or enum
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.AssociatedPropertyOrEvent">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that property/event. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsAbstract">
            <summary>
            Returns false because field can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsExtern">
            <summary>
            Returns false because field can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsOverride">
            <summary>
            Returns false because field can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsSealed">
            <summary>
            Returns false because field can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsVirtual">
            <summary>
            Returns false because field can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HasRuntimeSpecialName">
            <summary>
            True if this symbol has a runtime-special name (metadata flag RuntimeSpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.IsNotSerialized">
            <summary>
            True if this field is not serialized (metadata flag NotSerialized is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.MarshallingInformation">
            <summary>
            Describes how the field is marshalled when passed to native code.
            Null if no specific marshalling information is available for the field.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this field, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.TypeLayoutOffset">
            <summary>
            Offset assigned to the field when the containing type is laid out by the VM.
            Null if unspecified.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AssemblyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on an assembly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterEarlyWellKnownAttributeData">
            <summary>
            Information early-decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(Roslyn.Compilers.ObsoleteAttributeData@,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ObsoleteAttributeHelpers.InitializeObsoleteState(Roslyn.Compilers.ThreeState@,Roslyn.Compilers.CustomAttributesBag{Roslyn.Compilers.CSharp.AttributeData})">
            <summary>
            Initializes the ObsoleteState only for the case where there are no attribute on the symbol and when 
            attributes have been stored in the bag.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceParameterSymbolBase">
            <summary>
            Base class for all parameters that are emitted.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedAttributeData">
            <summary>
            Class to represent a synthesized attribute
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceAttributeData">
            <summary>
            Represents a Source custom attribute specification
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeData">
            <summary>
            A Symbol attribute represents a .NET attribute applied to a symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Compares the namespace and type name with the attribute's namespace and type name.
            Returns true if they are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.IsTargetEarlyAttribute(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.AttributeSyntax,Roslyn.Compilers.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.ToString">
            <summary>
            Returns the System.String that represents the current AttributeData.
            </summary>
            <returns>A System.String that represents the current AttributeData.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.DecodePermissionSetAttribute(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.AttributeSyntax,System.Int32,System.Int32,Roslyn.Compilers.DiagnosticBag)">
             <summary>
             Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.
             </summary>
             <remarks>
             PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
             Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute at ndp\clr\src\vm\securityattributes.cpp.
             It involves following steps:
              1) Verifying that the specified file name resolves to a valid path.
              2) Reading the contents of the file into a byte array.
              3) Convert each byte in the file content into two bytes containing hexa-decimal characters.
              4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            
             Step 1) is performed in this method, i.e. during binding.
             Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.
             See <see cref="T:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference"/> for remaining fixup steps.
             </remarks>
             <returns>String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeData.ShouldEmitAttribute(Roslyn.Compilers.CSharp.Symbol,System.Boolean)">
            <summary>
            This method determines if an applied attribute must be emitted.
            Some attributes appear in symbol model to reflect the source code,
            but should not be emitted.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.AttributeClass">
            <summary>
            The attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.AttributeConstructor">
            <summary>
            The constructor on the attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.ConstructorArguments">
            <summary>
            Constructor arguments on the attribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeData.NamedArguments">
            <summary>
            Named (property value) arguments on the attribute. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAttributeData.IsTargetAttribute(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.AttributeDescription)">
            <summary>
            This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
            in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
            and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
            well known attributes.
            </summary>
            <param name="targetSymbol">The symbol which is the target of the attribute</param>
            <param name="description">The attribute to match.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAttributeData.GetSystemType(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Gets the System.Type type symbol from targetSymbol's containing assembly.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>System.Type type symbol.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAttributeData.ConstructorArgumentsSourceIndices">
            <summary>
            If the <see cref="P:Roslyn.Compilers.CSharp.AttributeData.ConstructorArguments"/> contains any named constructor arguments or default value arguments,
            it returns an array representing each argument's source argument index. A value of -1 indicates default value argument.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Compilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyWellKnownTypes">
            <summary>
            An array of cached well known types available for use in this Compilation.
            Lazily filled by GetWellKnownType method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyWellKnownTypeMembers">
            <summary>
            Lazy cache of well known members.
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetWellKnownTypeMember(Roslyn.Compilers.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.SynthesizeAttribute(Roslyn.Compilers.WellKnownMember,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.Common.CommonTypedConstant},Roslyn.Compilers.ReadOnlyArray{System.Collections.Generic.KeyValuePair{System.String,Roslyn.Compilers.Common.CommonTypedConstant}})">
            <summary>
            Synthesizes a custom attribute. 
            Returns null if the <paramref name="constructor"/> symbol is missing and the attribute is synthesized only if present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.anonymousTypeManager">
            <summary>
            Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyAssemblySymbol">
            <summary>
            The <see cref="T:Roslyn.Compilers.CSharp.SourceAssemblySymbol"/> for this compilation. Do not access directly, use Assembly property
            instead. This field is lazily initialized by AssemblyManager, AssemblyManager.CacheLockObject must be locked
            while AssemblyManager "calculates" the value and assigns it, several threads must not perform duplicate
            "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyReferencedAssembliesMap">
            <summary>
            A map from a metadata reference to an AssemblySymbol used for it. Do not access
            directly, use ReferencedAssembliesMap property instead. This field is lazily initialized
            by AssemblyManager when it creates SourceAssemblySymbol, AssemblyManager.CacheLockObject
            must be locked while AssemblyManager "calculates" the value and assigns it, several
            threads must not perform duplicate "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyReferencedModulesMap">
            <summary>
            A map from a net-module metadata reference to a ModuleSymbol used for it. The
            ModuleSymbol is one of the modules contained in m_AssemblySymbol.Modules list. Do not
            access directly, use ReferencedModulesMap property instead. This field is lazily
            initialized by AssemblyManager when it creates SourceAssemblySymbol,
            AssemblyManager.CacheLockObject must be locked while AssemblyManager "calculates" the
            value and assigns it, several threads must not perform duplicate "calculation"
            simultaneously.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyAssemblyManagerDiagnostics">
            <summary>
            reference through AssemblyManagerDiagnostics
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.lazyEntryPoint">
            <summary>
            Contains the main method of this assembly, if there is one.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Create(System.String,Roslyn.Compilers.CSharp.CompilationOptions,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree},System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider)">
            <summary>
            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
            on the returned object will allow to continue building up the Compilation incrementally.
            </summary>
            <param name="outputName">The name of the compilation: file name and extension.  Must be non-null.</param>
            <param name="options">The compiler options to use.</param>
            <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
            <param name="references">The references for the new compilation.</param>
            <param name="fileResolver">Resolves file references for the compilation.</param>
            <param name="metadataFileProvider">Translates a resolved assembly reference path to a path to the file that can be opened by the compiler.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreateSubmission(System.String,Roslyn.Compilers.CSharp.CompilationOptions,Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.Compilation,System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference},Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider,System.Type,System.Type)">
            <summary>
            Creates a new compilation that can be used in scripting.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Clone">
            <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.WithReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.WithOptions(Roslyn.Compilers.CSharp.CompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.WithPreviousSubmission(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSubmissionResultType(System.Boolean@)">
            <summary>
            Returns the type of the submission return value. 
            </summary>
            <returns>
            The type of the last expression of the submission. 
            Null if the type of the last expression is unknown (null).
            Void type if the type of the last expression statement is void or 
            the submission ends with a declaration or statement that is not an expression statement.
            </returns>
            <remarks>
            Note that the return type is System.Void for both compilations "System.Console.WriteLine();" and "System.Console.WriteLine()", 
            and <paramref name="hasValue"/> is <c>False</c> for the former and <c>True</c> for the latter.
            </remarks>
            <param name="hasValue">True if the submission has value, i.e. if it ends with a statement that is an expression statement.</param>
            <exception cref="T:System.InvalidOperationException">The compilation doesn't represent a submission (<see cref="P:IsSubmission"/> return false).</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ContainsSyntaxTree(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree.  False otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddSyntaxTrees(Roslyn.Compilers.CSharp.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveSyntaxTrees(Roslyn.Compilers.CSharp.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info
            for use with trees added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ReplaceSyntaxTree(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info
            for use with trees added later. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetReferencedAssemblySymbol(Roslyn.Compilers.MetadataReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> for a metadata reference used to create this compilation.
            </summary>
            <returns><see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Uses object identity when comparing two references. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetReferencedModuleSymbol(Roslyn.Compilers.MetadataReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents an added metadata module.
            </summary>
            <returns><see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Note that this method uses <see cref="T:Roslyn.Compilers.MetadataReference"/> object identity when comparing two references. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDirectiveReference(Roslyn.Compilers.CSharp.ReferenceDirectiveTriviaSyntax)">
            <summary>
            Returns a metadata reference that a given #r resolves to.
            </summary>
            <param name="directive">#r directive.</param>
            <returns>Metadata reference the specified directive resolves to.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ReplaceReference(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetCompilationNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Given for the specified module or assembly namespace, gets the corresponding compilation
            namespace (merged namespace representation for all namespace declarations and references
            with contributions for the namespaceSymbol).  Can return null if no corresponding
            namespace can be bound in this compilation with the same name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.BindScriptClass">
            <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:CommonCompilationOptions.ScriptClassName"/> to find the symbol.
            </summary>
            <returns>The Script class symbol or null if it is not defined.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies
            using its canonical CLR metadata name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreateArrayTypeSymbol(Roslyn.Compilers.CSharp.TypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.CreatePointerTypeSymbol(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetSemanticModel(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetImports(Roslyn.Compilers.CSharp.SingleNamespaceDeclaration)">
            <summary>
            Returns imported symbols for the given declaration.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage of a compilation. There are no diagnostics for declarations or accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not
            include any diagnostics that might be produced during emit.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="outputStream">Stream to which the compilation will be written.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="pdbFileName">The name of the PDB file - embedded in the output.  Null to infer from the stream or the compilation.
            Ignored unless pdbStream is non-null.
            </param>
            <param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
            <param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <param name="win32ResourcesInRESFormat">Stream from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.String,System.String,System.String,System.Threading.CancellationToken,System.String,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="outputPath">Path of the file to which the compilation will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <param name="win32ResourcesInRESFormatPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.EmitMetadataOnly(System.IO.Stream,System.String,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Emits the IL for the symbol declarations into the specified stream.  Useful for emitting information for
            cross-language modeling of code.  This emits what it can even if there are errors.
            </summary>
            <param name="metadataStream">Stream to which the compilation's metadata will be written.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription},System.Boolean,Roslyn.Compilers.CodeGen.CompilationTestData,System.Boolean)">
            <summary>
            This overload is only intended to be directly called by tests that want to pass an ilBuilderMap.
            The map is used for storing a list of methods and their associated IL.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.Emit(System.Reflection.Emit.ModuleBuilder,Roslyn.Compilers.IAssemblyLoader,System.Func{Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.AssemblyIdentity},System.Threading.CancellationToken)">
            <summary>
            Emits the compilation into given <see cref="T:System.Reflection.Emit.ModuleBuilder"/> using Reflection.Emit APIs.
            </summary>
            <param name="moduleBuilder">
            The module builder to add the types into. Can be reused for multiple compilation units.
            </param>
            <param name="assemblyLoader">
            Loads an assembly given an <see cref="T:Roslyn.Compilers.AssemblyIdentity"/>. 
            This callback is used for loading assemblies referenced by the compilation.
            <see cref="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)"/> is used if not specified.
            </param>
            <param name="assemblySymbolMapper">
            Applied when converting assembly symbols to assembly references.
            <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> is mapped to its <see cref="P:Roslyn.Compilers.CSharp.AssemblySymbol.Identity"/> by default.
            </param>
            <param name="cancellationToken">Can be used to cancel the emit process.</param>
            <returns>
            An instance of <see cref="T:Roslyn.Compilers.CSharp.ReflectionEmitResult"/> that indicates whether or not the call succeeded and includes the list of errors
            and the entry point if there is any.
            </returns>
            <remarks>
            Reflection.Emit doesn't support all metadata constructs. If an unsupported construct is
            encountered a metadata writer that procudes uncollectible code is used instead. This is
            indicated by 
            <see cref="P:CommonReflectionEmitResult.IsUncollectible"/> flag on the result. 
            
            Reusing <see cref="T:System.Reflection.Emit.ModuleBuilder"/> may be beneficial in certain
            scenarios. For example, when emitting a sequence of code snippets one at a time (like in
            REPL). All the snippets can be compiled into a single module as long as the types being
            emitted have unique names. Reusing a single module/assembly reduces memory overhead. On
            the other hand, collectible assemblies are units of collection. Defining too many
            unrelated types in a single assemly might prevent the unused types to be collected. 
            
            No need to provide a name override when using Reflection.Emit, since the assembly already
            exists.
            </remarks>
            <exception cref="T:System.InvalidOperationException">Referenced assembly can't be resolved.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddObsoleteSymbol(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Add the given symbol, node and containingSymbol to a queue to be processed later.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.GetObsoleteContextState(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.
            </summary>
            <returns>
            True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any
            symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent
            hierarchy is Obsolete.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AddObsoleteDiagnostic(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Create a diagnostic for the given symbol. This could be an error or a warning based on
            the ObsoleteAttribute's arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.ReportObsoleteDiagnostics(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Process the queue of stored symbols and report Obsolete diagnostics for them (if applicable).
            </summary>
            <param name="diagnostics"></param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.Options">
            <summary>
            The options the compilation was created with. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SyntaxTrees">
            <summary>
            The syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SourceAssembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.Assembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SourceModule">
            <summary>
            Get a ModuleSymbol that refers to the module being created by compiling all of the code.
            By getting the GlobalNamespace property of that module, all of the namespaces and types
            defined in source code can be obtained.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.GlobalNamespace">
            <summary>
            Gets the root namespace that contains all namespaces and types defined in source code or in 
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Compilation.SemanticDiagnostics">
            <summary>
            The bag in which semantic analysis should deposit its diagnostics.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Compilation.AssemblyManager">
            <summary>
            AssemblyManager encapsulates functionality to create an underlying SourceAssemblySymbol 
            (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced
            assemblies (with underlying ModuleSymbols) all properly linked together based on
            reference resolution between them.
            
            AssemblyManager is also responsible for reuse of metadata readers for imported modules
            and assemblies as well as existing AssemblySymbols for referenced assemblies. In order
            to do that, it maintains global cache for metadata readers and AssemblySymbols
            associated with them. The cache uses WeakReferences to refer to the metadata readers and
            AssemblySymbols to allow memory and resources being reclaimed once they are no longer
            used. The tricky part about reusing existing AssemblySymbols is to find a set of
            AssemblySymbols that are created for the referenced assemblies, which (the
            AssemblySymbols from the set) are linked in a way, consistent with the reference
            resolution between the referenced assemblies.
            
            When existing Compilation is used as a metadata reference, there are scenarios when its
            underlying SourceAssemblySymbol cannot be used to provide symbols in context of the new
            Compilation. Consider classic multi-targeting scenario: compilation C1 references v1 of
            Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case,
            SourceAssemblySymbol for C1 is linked to AssemblySymbol for v1 of Lib.dll. However,
            given the set of references for C2, the same reference for C1 should be resolved against
            v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll leaking
            through C1 (through method signatures, etc.) must be retargeted to the types from v2 of
            Lib.dll. In this case, AssemblyManager creates a special RetargetingAssemblySymbol for
            C1, which is responsible for the type retargeting. The RetargetingAssemblySymbols could
            also be reused for different Compilations, AssemblyManager maintains a cache of
            RetargetingAssemblySymbols (WeakReferences) for each Compilation.
            
            The only public entry point of this class is CreateSourceAssembly() method.
            
            TODO: Comment on CorLibrary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.CheckPropertiesConsistency(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.MetadataReference,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.WeakIdentityPropertiesEquivalent(Roslyn.Compilers.AssemblyIdentity,Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            C# only considers culture when comparing weak identities.
            It ignores versions of weak identities and reports an error if there are two weak assembly 
            references passed to a compilation that have the same simple name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsSourceAssemblySymbolCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsReferencedAssembliesMapCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compilation.AssemblyManager.IsReferencedModulesMapCreated(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            For testing purposes only.
            </summary>
            <param name="compilation"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Compilation.PossiblyObsoleteSymbolData">
            <summary>
            This structure encapsulates information needed to report Obsolete diagnostics for a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.PossiblyObsoleteSymbolData.Symbol">
            <summary>
            The symbol for which Obsolete diagnostics will be reported, if the symbol is Obsolete.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.PossiblyObsoleteSymbolData.Node">
            <summary>
            The syntax node for which diagnostics will be issued.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Compilation.PossiblyObsoleteSymbolData.ContainingSymbol">
            <summary>
            The context in which this symbol appears. If the ContainingSymbol itself is Obsolete (or a symbol in it's
            parent hierarchy) then we should suppress reporting Obsolete diagnostics for the given symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol">
            <summary>
            AssemblySymbol to represent missing, for whatever reason, CorLibrary.
            The symbol is created by AssemblyManager on as needed basis and is shared by all compilations
            with missing CorLibraries.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingAssemblySymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> that represents
            an assembly that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AssemblySymbol.corLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
            The value is provided by AssemblyManager and must not be modified. For SourceAssemblySymbol, non-missing 
            coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
            the main module. If there is no existing assembly that can be used as a source for the primitive types, 
            the value is a Compilation.MissingCorLibrary. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.SetCorLibrary(Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            A helper method for AssemblyManager to set the system assembly, which provides primitive 
            types like Object, String, etc., think mscorlib.dll. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.LookupAssemblyForForwardedMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Look up the assembly to which the given metadata type is forwarded.
            </summary>
            <param name="emittedName"></param>
            <returns>
            The assembly to which the given type is forwarded or null, if there isn't one.
            </returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetNoPiaResolutionAssemblies">
            <summary>
            Return an array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by previous compilation referencing this assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetLinkedReferencedAssemblies">
            <summary>
            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Gets the symbol for the pre-defined type from core library associated with this assembly.
            </summary>
            <returns>The symbol for the pre-defined type or null if the type is not defined in the core library.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Get symbol for predefined type from Cor Library used by this assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="metadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean)">
            <summary>
            Lookup a type within the assembly using its canonical CLR metadata name.
            </summary>
            <param name="metadataName"></param>
            <param name="includeReferences">
            If search within assembly fails, lookup in assemblies referenced by the primary module.
            For source assembly, this is equivalent to all assembly references given to compilation.
            </param>
            <param name="useCLSCompliantNameArityEncoding">
            While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
            </param>
            <returns>Null if the type can't be found.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetTypeByReflectionType(System.Type,System.Boolean)">
            <summary>
            Resolves <see cref="T:System.Type"/> to a <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> available in this assembly
            its referenced assemblies.
            </summary>
            <param name="type">The type to resolve.</param>
            <param name="includeReferences">Use referenced assemblies for resolution.</param>
            <returns>The resolved symbol if successful or null on failure.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AssemblySymbol.GetSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type used by this Assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.CorLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., think mscorlib.dll. 
            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.BaseName">
            <summary>
            Get the base name of the assembly. This is equivalent to AssemblyName.Name, but may be 
            much faster to retrieve for source code assemblies, since it does not require binding
            the assembly-level attributes that contain the version number and other assembly
            information.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.Identity">
            <summary>
            Gets the identity of this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.Modules">
            <summary>
            Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.IsLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
            <remarks>
            These names are the simple identifiers for the type, and do not include namespaces,
            outer type names, or type parameters.
            
            This functionality can be used for features that want to quickly know if a name could be
            a type for performance reasons.  For example, classification does not want to incur an
            expensive binding call cost if it knows that there is no type with the name that they
            are looking at.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this assembly might contain extension methods. If this property
            returns false, there are no extension methods in this assembly.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AssemblySymbol.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in a compilation using the assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol.lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetDeclaredSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MissingCorLibrarySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly. Only should be
            called if it is know that this is the Cor Library (mscorlib).
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol">
            <summary>
            A source parameter, potentially with a default value, attributes, etc.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceParameterSymbol">
            <summary>
            Base class for parameters can be referred to from source code.
            </summary>
            <remarks>
            These parameters can potentially be targetted by an attribute specified in source code. 
            As an optimization we distinguish simple parameters (no attributes, no modifiers, etc.) and complex parameters.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceParameterSymbol.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceParameterSymbol.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares atributes for this parameter symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source parameter symbols.
            </summary>
            <remarks>
            Used for parameters of partial implementation. We bind the attributes only on the definition
            part and copy them over to the implementation.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceComplexParameterSymbol.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceEventAccessorSymbol">
            <summary>
            Base class for event accessors - synthesized and user defined.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceFieldSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceFieldSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceFieldSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceFieldSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceFieldSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceFieldSymbol.DocumentationCommentProvider">
            <summary>
            Returns the syntax node that might be annotated by a doc comment.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceFieldSymbol.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceFieldSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute. 
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceFieldSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceSimpleParameterSymbol">
            <summary>
            A source parameter that has no default value, no attributes,
            and is not params.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceClonedParameterSymbol">
            <summary>
            Represents a source parameter cloned from another <see cref="T:Roslyn.Compilers.CSharp.SourceParameterSymbol"/>, when they must share attribute data and default constant value.
            For example, parameters on a property symbol are cloned to generate parameters on accessors.
            Similarly parameters on delegate invoke method are cloned to delegate begin/end invoke methods.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedAccessorValueParameterSymbol">
            <summary>
            Represents the compiler generated value parameter for property/event accessor.
            This parameter has no source location/syntax, but may have attributes.
            Attributes with 'param' target specifier on the accessor must be applied to the this parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedLocal">
            <summary>
            A synthesized local variable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.Type">
            <summary>
            Gets the type of this local.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsPinned">
            <summary>
            WARN WARN WARN: If you access this via the semantic model, things will break (since the initializer may not have been bound).
            
            Whether or not this local is pinned (i.e. the type will be emitted with the "pinned" modifier).
            </summary>
            <remarks>
            Superficially, it seems as though this should always be the same as DeclarationKind == LocalDeclarationKind.Fixed.
            Unfortunately, when we fix a string expression, it is not the declared local (e.g. char*) but a synthesized temp (string)
            that is pinned.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsExtern">
            <summary>
            Returns false because local variable can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsSealed">
            <summary>
            Returns false because local variable can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsAbstract">
            <summary>
            Returns false because local variable can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsOverride">
            <summary>
            Returns false because local variable can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsVirtual">
            <summary>
            Returns false because local variable can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsStatic">
            <summary>
            Returns false because local variable can't be declared as static in C#.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because local variable can't be used outside the member body..
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LocalSymbol"/>.
            It should be the member symbol containing this local variable in its body; such as <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/>. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.Kind">
            <summary>
            Returns value 'Local' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsCatch">
            <summary>
            Returns true if this local variable was declared in a catch clause. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsUsing">
            <summary>
            Returns true if the local variable is declared in resource-acquisition of a 'using statement';
            otherwise false
            </summary>
            <exmaple>
            <code>
                using (var localVariable = new StreamReader("C:\\Temp\\MyFile.txt")) { ... } 
            </code>
            </exmaple>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsFixed">
            <summary>
            Returns true if the local variable is declared in fixed-pointer-initializer (in unsafe context)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsFor">
            <summary>
            Returns true if this local variable is declared in for-initializer
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsForEach">
            <summary>
            Returns true if this local variable is declared as iteration variable
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.IsWriteable">
            <summary>
            Returns false if <see ref="LocalSymbol.IsUsing" />, <see ref="LocalSymbol.IsFixed" />,
            <see ref="LocalSymbol.IsFor" />, <see ref="LocalSymbol.IsForEach" /> or 
            <see ref="LocalSymbol.IsConst" /> return true
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedCapturedVariable">
            <summary>
            A field of a frame class that represents a variable that has been captured in a lambda or iterator.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedFieldSymbol">
            <summary>
            Represents a compiler generated field of given type and name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowPass.Analyze(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
            the body might be reachable..
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowPass.Analyze(System.Boolean@,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.  Returns true if the end of the
            body might be reachable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ControlFlowPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RegionAnalysisContext">
            <summary>
            Represents region analysis context attributes such as compilation, region, etc...
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.Compilation">
            <summary> Compilation to use </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.Method">
            <summary> Method symbol if available, null otherwise </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.BoundNode">
            <summary> Bound node, not null </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.FirstInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.LastInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.RegionAnalysisContext.Failed">
            <summary> True if the input was bad, such as no first and last nodes </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.RegionAnalysisContext.#ctor(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Construct context
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractRegionDataFlowPass.Scan(System.Boolean@)">
            <summary>
            To scan the whole body, we start outside (before) the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AlwaysAssignedWalker">
            <summary>
            A region analysis walker that computes the set of variables that are always assigned a value
            in the region. A variable is "always assigned" in a region if an analysis of the region that
            starts with the variable unassigned ends with the variable assigned.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DataFlowsInWalker">
            <summary>
            A region analysis walker that computes the set of variables whose values flow into (are used
            in) the region. A variable assigned outside is used inside if an analysis that leaves the
            variable unassigned on entry to the region would cause the generation of "unassigned" errors
            within the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DataFlowsOutWalker">
            <summary>
            A region analysis walker that computes the set of variables for
            which their assigned values flow out of the region.
            A variable assigned inside is used outside if an analysis that
            treats assignments in the region as unassigning the variable would
            cause "unassigned" errors outside the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EntryPointsWalker">
            <summary>
            A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
            invoked by a superclass when the two endpoints of a jump have been identified.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExitPointsWalker">
            <summary>
            A region analysis walker that records jumps out of the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReadWriteWalker">
            <summary>
            A region analysis walker that records reads and writes of all variables, both inside and outside the region.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RegionReachableWalker">
            <summary>
            A region analysis walker that computes whether or not the region completes normally.  It does this by determining
            if the point at which the region ends is reachable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DataFlowAnalysis">
            <summary>
            This class implements the region data flow analysis operations.  Region data flow analysis
            provides information how data flows into and out of a region.  The analysis is done lazily.
            When created, it performs no analysis, but simply caches the arguments. Then, the first time
            one of the analysis results is used it computes that one result and caches it. Each result
            is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.VariablesDeclared">
            <summary>
            A collection of the local variables that are declared within the region. Note that the region must be
            bounded by a method's body or a field's initializer, so method parameter symbols are never included
            in the result, but lambda parameters might appear in the result.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.DataFlowsIn">
            <summary>
            A collection of the local variables for which a value assigned outside the region may be used inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.DataFlowsOut">
            <summary>
            A collection of the local variables for which a value assigned inside the region may be used outside the region.
            Note that every reachable assignment to a ref or out variable will be included in the results.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.AlwaysAssigned">
            <summary>
            A collection of the local variables for which a value is always assigned inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.ReadInside">
            <summary>
            A collection of the local variables that are read inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.WrittenInside">
            <summary>
            A collection of local variables that are written inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.ReadOutside">
            <summary>
            A collection of the local variables that are read outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.WrittenOutside">
            <summary>
            A collection of local variables that are written outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.Captured">
            <summary>
            A collection of the non-constant local variables and parameters that have been referenced in anonymous functions
            and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            A collection of the non-constant local variables and parameters that have had their address (or the address of one
            of their fields) taken using the '&amp;' operator.
            </summary>
            <remarks>
            If there are any of these in the region, then a method should not be extracted.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DataFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.UnassignedVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.VariablesDeclaredWalker">
            <summary>
            A region analysis walker that records declared variables.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter">
            <summary>
            The rewriter for removing lambda expressions from method bodies and introducing closure classes
            as containers for captured variables along the lines of the example in section 6.5.3 of the
            C# language specification.
            
            The entry point is the public method Rewrite.  It operates as follows:
            
            First, an analysis of the whole method body is performed that determines which variables are
            captured, what their scopes are, and what the nesting relationship is between scopes that
            have captured variables.  The result of this analysis is left in LambdaRewriter.analysis.
            
            Then we make a frame, or compiler-generated class, represented by an instance of
            LambdaRewriter.Frame for each scope with captured variables.  The generated frames are kept
            in LambdaRewriter.frames.  Each frame is given a single field for each captured
            variable in the corresponding scope.  These are are maintained in LambdaRewriter.proxies.
            
            Finally, we walk and rewrite the input bound tree, keeping track of the following:
            (1) The current set of active frame pointers, in LambdaRewriter.framePointers
            (2) The current method being processed (this changes within a lambda's body), in LambdaRewriter.currentMethod
            (3) The "this" symbol for the current method in LambdaRewriter.currentFrameThis, and
            (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
            
            There are a few key transformations done in the rewriting.
            (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
                moved into a new, compiler-generated method of a selected frame class.
            (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
            (3) References to captured variables are transformed into references to fields of a frame class.
            
            In addition, the rewriting deposits into the field LambdaRewriter.generatedMethods a (MethodSymbol, BoundStatement)
            pair for each generated method.
            
            LambdaRewriter.Rewrite produces its output in two forms.  First, it returns a new bound statement
            for the caller to use for the body of the original method.  Second, it returns a collection of
            (MethodSymbol, BoundStatement) pairs for additional method that the lambda rewriter produced.
            These additional methods contain the bodies of the lambdas moved into ordinary methods of their
            respective frame classes, and the caller is responsible for processing them just as it does with
            the returned bound node.  For example, the caller will typically perform iterator method and
            asynchronous method transformations, and emit IL instructions into an assembly.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.Rewrite(Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeCompilationState,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.LambdaRewriter.Analysis)">
            <summary>
            Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
            bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
            MethodBodyCompiler.  See this class' documentation
            for a more thorough explanation of the algorithm and its use by clients.
            </summary>
            <param name="node">The bound node to be rewritten</param>
            <param name="method">The containing method of the node to be rewritten</param>
            <param name="compilationState">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
            <param name="diagnostics">Diagnostic bag for diagnostics</param>
            <param name="analysis">A caller-provided analysis of the node's lambdas</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.MakeFrames">
            <summary>
            Create the frame types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.FrameOfType(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame type.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameType">The type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.FramePointer(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame class.
            Note that for generic frames, the frameClass parameter is the generic definition, but
            the resulting expression will be constructed with the current type parameters.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameClass">The class type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.IntroduceFrame``1(Roslyn.Compilers.CSharp.BoundNode,Roslyn.Compilers.CSharp.LambdaRewriter.LambdaFrame,System.Func{Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundStatement},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.LocalSymbol},``0})">
            <summary>
            Introduce a frame around the translation of the given node.
            </summary>
            <param name="node">The node whose translation should be translated to contain a frame</param>
            <param name="frame">The frame for the translated node</param>
            <param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
            <returns>The translated statement, as returned from F</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.BlockDepth(Roslyn.Compilers.CSharp.BoundNode)">
            <summary>
            Compute the nesting depth of a given block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis">
            <summary>
            Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
            The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.seenLambda">
            <summary>
            Set to true of any lambda expressions were seen in the analyzed method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.blockParent">
            <summary>
            For each statement that defines variables, identifies the nearest enclosing statement that defines variables.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.variableBlock">
            <summary>
            For each captured variable, identifies the statement in which it will be moved to a frame class.  This is
            normally the block where the variable is introduced, but method parameters are moved
            to a frame class within the body of the method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.needsParentFrame">
            <summary>
            Blocks that are positioned between a block declaring some lifted variables
            and a block that contains the lambda that lifts said variables.
            If such block itself requires a closure, then it must lift parent frame pointer into the closure
            in addition to whatever else needs to be lifted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.captured">
            <summary>
            The set of captured variables seen in the method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.capturedSyntax">
            <summary>
            The syntax nodes associated with each captured variable.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.declaredInsideExpressionLambda">
            <summary>
            The set of variables that were declared anywhere inside an expression lambda.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.captures">
            <summary>
            For each lambda in the code, the set of variables that it captures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.inExpressionLambda">
            <summary>
            Set to true while we are analyzing the interior of an expression lambda.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LambdaRewriter.Analysis.RecordCaptureInIntermediateBlocks(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Once we see a lambda lifting something
            We mark all blocks from the current up to the one that declares lifted symbol as
            needing a parent frame.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.LambdaFrame">
            <summary>
            A class that represents the set of variables in a scope that have been
            captured by lambdas within that scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.LambdaCapturedVariable">
            <summary>
            A field of a frame class that represents a variable that has been captured in a lambda.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.LambdaFrameLocalSymbol">
            <summary>
            A local variable used to store a reference to the frame objects in which captured
            local variables have become fields.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LambdaRewriter.SynthesizedLambdaMethod">
            <summary>
            A method that results from the translation of a single lambda expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedSubmissionFields">
            <summary>
            Tracks synthesized fields that are needed in a submission being compiled.
            </summary>
            <remarks>
            For every other submission referenced by this submission we add a field, so that we can access members of the target submission.
            A field is also needed for the host object, if provided.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TempHelpers.StoreToTemp(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.RefKind,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Takes an expression and returns the bound local expression "temp" 
            and the bound assignment expression "temp = expr".
            </summary>
            <param name="argument"></param>
            <param name="refKind"></param>
            <param name="containingMethod"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BindingLocation">
            <summary>
            A specific location for binding.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScope">
            <summary>
            A distinct scope that may expose extension methods. For a particular Binder,  there
            are two possible scopes: one for the namespace, and another for any using statements
            in the namespace. The namespace scope is searched before the using scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScopes">
            <summary>
            An enumerable collection of extension method scopes in search
            order, from the given Binder, out through containing Binders.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtensionMethodScopeEnumerator">
            <summary>
            An enumerator over ExtensionMethodScopes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocationSpecificBinder">
            <summary>
            A simple Binder that wraps another Binder and reports a specific
            binding location, but otherwise delegates to the other Binder.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitlyTypedFieldBinder">
            <summary>
            Tracks fields that are being bound while binding their initializers.
            </summary>
            <remarks>
            Used to detect circular references like:
            var x = y;
            var y = x;
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitlyTypedLocalBinder">
            <summary>
            This binder is for binding the initializer of an implicitly typed
            local variable. While binding an implicitly typed local variable
            it is illegal to refer to the variable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ForEachEnumeratorInfo">
            <summary>
            Information to be deduced while binding a foreach loop so that the loop can be lowered
            to a while over an enumerator.  Not applicable to the array or string forms.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ForEachLoopBinder">
            <summary>
            A loop binder that (1) knows how to bind foreach loops and (2) has the foreach iteration variable in scope.
            </summary>
            <remarks>
            This binder produces BoundForEachStatements.  The lowering described in the spec is performed in ControlFlowRewriter.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.BindForEachParts(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Bind the ForEachStatementSyntax at the root of this binder.
            </summary>
            <param name="diagnostics">Will be populated with binding diagnostics.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.GetEnumeratorInfo(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            The spec describes an algorithm for finding the following types:
              1) Collection type
              2) Enumerator type
              3) Element type
              
            The implementation details are a bit difference.  If we're iterating over a string or an array, then we don't need to record anything
            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the 
            inferred type plus a ForEachEnumeratorInfo.Builder with:
              1) Collection type
              2) Element type
              3) GetEnumerator method of the collection type (return type will be the enumerator type from the spec)
              4) Current property of the enumerator type
              5) MoveNext method of the enumerator type
              
            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.
            </summary>
            <param name="collectionExpr">The expression over which to iterate.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>Partially populated (all but conversions) or null if there was an error.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.SatisfiesGetEnumeratorPattern(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder@)">
            <summary>
            Check for a GetEnumerator method on collectionExprType.  Failing to satisfy the pattern is not an error -
            it just means that we have to check for an interface instead.
            </summary>
            <param name="collectionExprType">Type of the expression over which to iterate.</param>
            <param name="diagnostics">Populated with *warnings* if there are near misses.</param>
            <param name="builder">Null if there is no such method, non-null with GetEnumeratorMethod set otherwise.</param>
            <returns>True if the method was found (still have to verify that the return (i.e. enumerator) type is acceptable).</returns>
            <remarks>
            Only adds warnings, so does not affect control flow (i.e. no need to check for failure).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.FindForEachPatternMethod(Roslyn.Compilers.CSharp.TypeSymbol,System.String,Roslyn.Compilers.CSharp.LookupResult,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Perform a lookup for the specified method on the specified type.  Perform overload resolution
            on the lookup results.
            </summary>
            <param name="patternType">Type to search.</param>
            <param name="methodName">Method to search for.</param>
            <param name="lookupResult">Passed in for reusability.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>The desired method or null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.PerformForEachPatternOverloadResolution(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            The overload resolution portion of FindForEachPatternMethod.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.SatisfiesForEachPattern(Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Called after it is determined that the expression being enumerated is of a type that
            has a GetEnumerator method.  Checks to see if the return type of the GetEnumerator
            method is suitable (i.e. has Current and MoveNext).
            </summary>
            <param name="builder">Must be non-null and contain a non-null GetEnumeratorMethod.</param>
            <param name="diagnostics">Will be populated with pattern diagnostics.</param>
            <returns>True if the return type has suitable members.</returns>
            <remarks>
            It seems that every failure path reports the same diagnostics, so that is left to the caller.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.AllInterfacesContainsIEnumerable(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.ForEachEnumeratorInfo.Builder@,System.Boolean@)">
            <summary>
            Checks if the given type implements (or extends, in the case of an interface),
            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable&lt;T&gt;,
            for at least one T.
            </summary>
            <param name="type">Type to check.</param>
            <param name="builder">Null if no interface is found, non-null with a non-null CollectionType otherwise.</param>
            <param name="foundMultiple">True if multiple T's are found.</param>
            <returns>True if some IEnumerable is found (may still be ambiguous).</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachLoopBinder.ReportPatternMemberLookupDiagnostics(Roslyn.Compilers.CSharp.LookupResult,Roslyn.Compilers.CSharp.TypeSymbol,System.String,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report appropriate diagnostics when lookup of a pattern member (i.e. GetEnumerator, Current, or MoveNext) fails.
            </summary>
            <param name="lookupResult">Failed lookup result.</param>
            <param name="patternType">Type in which member was looked up.</param>
            <param name="memberName">Name of looked up member.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated appropriately.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodGroupResolution">
            <summary>
            Packages up the various parts returned when resolving a method group. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeofBinder">
            <summary>
            This binder is for binding the argument to typeof.  It traverses
            the syntax marking each open type ("unbound generic type" in the
            C# spec) as either allowed or not allowed, so that BindType can 
            appropriately return either the corresponding type symbol or an 
            error type.  It also indicates whether the argument as a whole 
            should be considered open so that the flag can be set 
            appropriately in BoundTypeOfOperator.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeofBinder.OpenTypeVisitor">
            <summary>
            This visitor walks over a type expression looking for open types.
            Open types are allowed if an only if:
              1) There is no constructed generic type elsewhere in the visited syntax; and
              2) The open type is not used as a type argument or array/pointer/nullable
                   element type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxVisitor">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> visitor that visits only the single SyntaxNode
            passed into its <see cref="M:Roslyn.Compilers.CSharp.SyntaxVisitor.Visit(Roslyn.Compilers.CSharp.SyntaxNode)"/> method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIdentifierName(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQualifiedName(Roslyn.Compilers.CSharp.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGenericName(Roslyn.Compilers.CSharp.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeArgumentList(Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAliasQualifiedName(Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPredefinedType(Roslyn.Compilers.CSharp.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayRankSpecifier(Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNullableType(Roslyn.Compilers.CSharp.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOmittedTypeArgument(Roslyn.Compilers.CSharp.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParenthesizedExpression(Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPrefixUnaryExpression(Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPostfixUnaryExpression(Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMemberAccessExpression(Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBinaryExpression(Roslyn.Compilers.CSharp.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConditionalExpression(Roslyn.Compilers.CSharp.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitThisExpression(Roslyn.Compilers.CSharp.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBaseExpression(Roslyn.Compilers.CSharp.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLiteralExpression(Roslyn.Compilers.CSharp.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMakeRefExpression(Roslyn.Compilers.CSharp.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRefTypeExpression(Roslyn.Compilers.CSharp.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRefValueExpression(Roslyn.Compilers.CSharp.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCheckedExpression(Roslyn.Compilers.CSharp.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDefaultExpression(Roslyn.Compilers.CSharp.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeOfExpression(Roslyn.Compilers.CSharp.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSizeOfExpression(Roslyn.Compilers.CSharp.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInvocationExpression(Roslyn.Compilers.CSharp.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElementAccessExpression(Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArgumentList(Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBracketedArgumentList(Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArgument(Roslyn.Compilers.CSharp.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNameColon(Roslyn.Compilers.CSharp.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCastExpression(Roslyn.Compilers.CSharp.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAnonymousMethodExpression(Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSimpleLambdaExpression(Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInitializerExpression(Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitObjectCreationExpression(Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAnonymousObjectMemberDeclarator(Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitStackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQueryExpression(Roslyn.Compilers.CSharp.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQueryBody(Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFromClause(Roslyn.Compilers.CSharp.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLetClause(Roslyn.Compilers.CSharp.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitJoinClause(Roslyn.Compilers.CSharp.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitJoinIntoClause(Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWhereClause(Roslyn.Compilers.CSharp.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOrderByClause(Roslyn.Compilers.CSharp.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOrdering(Roslyn.Compilers.CSharp.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSelectClause(Roslyn.Compilers.CSharp.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGroupClause(Roslyn.Compilers.CSharp.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitQueryContinuation(Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOmittedArraySizeExpression(Roslyn.Compilers.CSharp.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGlobalStatement(Roslyn.Compilers.CSharp.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBlock(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLocalDeclarationStatement(Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitVariableDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitVariableDeclarator(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEqualsValueClause(Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExpressionStatement(Roslyn.Compilers.CSharp.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEmptyStatement(Roslyn.Compilers.CSharp.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLabeledStatement(Roslyn.Compilers.CSharp.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitGotoStatement(Roslyn.Compilers.CSharp.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBreakStatement(Roslyn.Compilers.CSharp.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitContinueStatement(Roslyn.Compilers.CSharp.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitReturnStatement(Roslyn.Compilers.CSharp.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitThrowStatement(Roslyn.Compilers.CSharp.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitYieldStatement(Roslyn.Compilers.CSharp.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWhileStatement(Roslyn.Compilers.CSharp.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDoStatement(Roslyn.Compilers.CSharp.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitForStatement(Roslyn.Compilers.CSharp.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitForEachStatement(Roslyn.Compilers.CSharp.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUsingStatement(Roslyn.Compilers.CSharp.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFixedStatement(Roslyn.Compilers.CSharp.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCheckedStatement(Roslyn.Compilers.CSharp.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUnsafeStatement(Roslyn.Compilers.CSharp.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLockStatement(Roslyn.Compilers.CSharp.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIfStatement(Roslyn.Compilers.CSharp.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElseClause(Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchStatement(Roslyn.Compilers.CSharp.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchSection(Roslyn.Compilers.CSharp.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSwitchLabel(Roslyn.Compilers.CSharp.SwitchLabelSyntax)">
            <summary>Called when the visitor visits a SwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTryStatement(Roslyn.Compilers.CSharp.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCatchClause(Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCatchDeclaration(Roslyn.Compilers.CSharp.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFinallyClause(Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitCompilationUnit(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExternAliasDirective(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUsingDirective(Roslyn.Compilers.CSharp.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNamespaceDeclaration(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeList(Roslyn.Compilers.CSharp.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeTargetSpecifier(Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttribute(Roslyn.Compilers.CSharp.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeArgumentList(Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAttributeArgument(Roslyn.Compilers.CSharp.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitNameEquals(Roslyn.Compilers.CSharp.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameterList(Roslyn.Compilers.CSharp.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitClassDeclaration(Roslyn.Compilers.CSharp.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitStructDeclaration(Roslyn.Compilers.CSharp.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitInterfaceDeclaration(Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEnumDeclaration(Roslyn.Compilers.CSharp.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDelegateDeclaration(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEnumMemberDeclaration(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBaseList(Roslyn.Compilers.CSharp.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeParameterConstraintClause(Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorConstraint(Roslyn.Compilers.CSharp.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitClassOrStructConstraint(Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitTypeConstraint(Roslyn.Compilers.CSharp.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitFieldDeclaration(Roslyn.Compilers.CSharp.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEventFieldDeclaration(Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitMethodDeclaration(Roslyn.Compilers.CSharp.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitOperatorDeclaration(Roslyn.Compilers.CSharp.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConversionOperatorDeclaration(Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorDeclaration(Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitConstructorInitializer(Roslyn.Compilers.CSharp.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDestructorDeclaration(Roslyn.Compilers.CSharp.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPropertyDeclaration(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEventDeclaration(Roslyn.Compilers.CSharp.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIndexerDeclaration(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAccessorList(Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitAccessorDeclaration(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParameterList(Roslyn.Compilers.CSharp.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBracketedParameterList(Roslyn.Compilers.CSharp.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitParameter(Roslyn.Compilers.CSharp.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIncompleteMember(Roslyn.Compilers.CSharp.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitSkippedTokensTrivia(Roslyn.Compilers.CSharp.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDocumentationCommentTrivia(Roslyn.Compilers.CSharp.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElement(Roslyn.Compilers.CSharp.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElementStartTag(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlElementEndTag(Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlEmptyElement(Roslyn.Compilers.CSharp.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlName(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlPrefix(Roslyn.Compilers.CSharp.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlAttribute(Roslyn.Compilers.CSharp.XmlAttributeSyntax)">
            <summary>Called when the visitor visits a XmlAttributeSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlText(Roslyn.Compilers.CSharp.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlCDataSection(Roslyn.Compilers.CSharp.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitXmlComment(Roslyn.Compilers.CSharp.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitIfDirectiveTrivia(Roslyn.Compilers.CSharp.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElifDirectiveTrivia(Roslyn.Compilers.CSharp.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitElseDirectiveTrivia(Roslyn.Compilers.CSharp.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEndIfDirectiveTrivia(Roslyn.Compilers.CSharp.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitRegionDirectiveTrivia(Roslyn.Compilers.CSharp.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitEndRegionDirectiveTrivia(Roslyn.Compilers.CSharp.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitErrorDirectiveTrivia(Roslyn.Compilers.CSharp.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitWarningDirectiveTrivia(Roslyn.Compilers.CSharp.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitBadDirectiveTrivia(Roslyn.Compilers.CSharp.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitDefineDirectiveTrivia(Roslyn.Compilers.CSharp.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitUndefDirectiveTrivia(Roslyn.Compilers.CSharp.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitLineDirectiveTrivia(Roslyn.Compilers.CSharp.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPragmaWarningDirectiveTrivia(Roslyn.Compilers.CSharp.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitPragmaChecksumDirectiveTrivia(Roslyn.Compilers.CSharp.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxVisitor.VisitReferenceDirectiveTrivia(Roslyn.Compilers.CSharp.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeofBinder.OpenTypeVisitor.Visit(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Collections.Generic.Dictionary{Roslyn.Compilers.CSharp.GenericNameSyntax,System.Boolean}@,System.Boolean@)">
            <param name="typeSyntax">The argument to typeof.</param>
            <param name="allowedMap">
            Keys are GenericNameSyntax nodes representing unbound generic types.
            Values are false if the node should result in an error and true otherwise.
            </param>
            <param name="isUnboundGenericType">True if no constructed generic type was encountered.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Imports">
            <summary>
            Represents symbols imported to the binding scope via using namespace, using alias, and extern alias.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalBinderFactory">
             <summary>
             The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated
             SyntaxNode. To do so it traverses all the statements, handling blocks and other
             statements that create scopes. For efficiency reasons, it does not traverse into
             expressions. This means that blocks within lambdas and queries are not created. 
             Blocks within lambdas are bound by their own LocalBinderFactory when they are 
             analyzed.
            
             For reasons of lifetime management, this type is distinct from the BinderFactory 
             which also creates a map from SyntaxNode to Binder. That type owns it's binders
             and that type's lifetime is that of the compilation. Therefore we do not store
             binders local to method bodies in that type's cache. 
             </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstantFieldsInProgressBinder">
            <summary>
            This binder keeps track of the set of constant fields that are currently being evaluated
            so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstantFieldsInProgress">
            <summary>
            This is used while computing the values of constant fields.  Since they can depend on each
            other, we need to keep track of which ones we are currently computing in order to avoid (and
            report) cycles.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LocalInProgressBinder">
            <summary>
            This binder keeps track of the local variable (if any) that is currently being evaluated
            so that it can be passed into the next call to LocalSymbol.GetConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupResultKind">
            <summary>
            Classifies the different ways in which a found symbol might be incorrect.
            Higher values are considered "better" than lower values. These values are used
            in a few different places:
               1) Inside a LookupResult to indicate the quality of a symbol from lookup.
               2) Inside a bound node (for example, BoundBadExpression), to indicate
                  the "binding quality" of the symbols referenced by that bound node.
               3) Inside an error type symbol, to indicate the reason that the candidate symbols
                  in the error type symbols were not good.
                  
            While most of the values can occur in all places, some of the problems are not
            detected at lookup time (e.g., NotAVariable), so only occur in bound nodes.
            </summary>
            <remarks>
            This enumeration is parallel to and almost the same as as the CandidateReason enumeration.
            Changes to one should usually result in changes to the other.
            
            There are two enumerations because:
              1) CandidateReason in language-independent, while this enum is language specific.
              2) The name "CandidateReason" didn't make much sense in the way LookupResultKind is used internally.
              3) Viable isn't used in CandidateReason, but we need it in LookupResultKind, and there isn't a 
                 a way to have internal enumeration values.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResultKindExtensions.ToCandidateReason(Roslyn.Compilers.CSharp.LookupResultKind)">
            <summary>
            Maps a LookupResultKind to a CandidateReason. Should not be called on LookupResultKind.Viable!
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BestTypeInferrer.InferBestType(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.BoundExpression},Roslyn.Compilers.CSharp.Conversions,System.Boolean@)">
            <remarks>
            This method finds the best common type of a set of expressions as per section 7.5.2.14 of the specification.
            NOTE: If some or all of the expressions have error types, we return error type as the inference result.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BestTypeInferrer.InferBestTypeForConditionalOperator(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Conversions,System.Boolean@)">
            <remarks>
            This method implements best type inference for the conditional operator ?:.
            NOTE: If either expression is an error type, we return error type as the inference result.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Conversion">
            <summary>
            Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
            associated symbol).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.Exists">
            <summary>
            Returns true if the conversion exists, either as an implicit or explicit conversion.
            </summary>
            <remarks>
            Existence does not imply validity.  For example, an ambiguous user-defined conversion exists but is not valid.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsImplicit">
            <summary>
            Returns true if the conversion is implicit, as described in section 6.1 of the C# language specification
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsExplicit">
            <summary>
            Returns true if the conversion is explicit, as described in section 6.2 of the C# language specification
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsIdentity">
            <summary>
            Returns true if the conversion is an identity conversion, as described in section 6.1.1 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNumeric">
            <summary>
            Returns true if the conversion is an implicit numeric conversion or explicit numeric conversion, 
            as described in sections 6.1.2 and 6.2.1 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsEnumeration">
            <summary>
            Returns true if the conversion is an implicit enumeration conversion or explicit enumeration conversion, 
            as described in sections 6.1.3 and 6.2.2 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNullable">
            <summary>
            Returns true if the conversion is an implicit nullable conversion or explicit nullable conversion, 
            as described in sections 6.1.4 and 6.2.3 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsReference">
            <summary>
            Returns true if the conversion is an implicit reference conversion or explicit reference conversion, 
            as described in sections 6.1.6 and 6.2.4 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsUserDefined">
            <summary>
            Returns true if the conversion is an implicit user-defined conversion or explicit user-defined conversion, 
            as described in section 6.4 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsBoxing">
            <summary>
            Returns true if the conversion is an implicit boxing conversion, 
            as described in section 6.1.7 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsUnboxing">
            <summary>
            Returns true if the conversion is an explicit unboxing conversion, 
            as described in section 6.2.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsNullLiteral">
            <summary>
            Returns true if the conversion is an implicit null literal conversion, 
            as described in section 6.1.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsDynamic">
            <summary>
            Returns true if the conversion is an implicit dynamic conversion, 
            as described in section 6.1.8 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsConstantExpression">
            <summary>
            Returns true if the conversion is an implicit constant expression conversion, 
            as described in section 6.1.9 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsAnonymousFunction">
            <summary>
            Returns true if the conversion is an implicit anonymous function conversion, 
            as described in section 6.5 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsMethodGroup">
            <summary>
            Returns true if the conversion is an implicit method group conversion, 
            as described in section 6.6 of the C# language specification.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsPointer">
            <summary>
            Returns true if the conversion is a conversion 
             a) from a pointer type to void*, 
             b) from a pointer type to another pointer type (other than void*),
             c) from the null literal to a pointer type,
             d) from an integral numeric type to a pointer type, or
             e) from a pointer type to an integral numeric type.
            Such conversions are described in section 18.4 of the C# language specification.
            </summary>
            <remarks>
            Does not return true for user-defined conversions to/from pointer types.
            Does not return true for conversions between pointer types and IntPtr/UIntPtr.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.IsIntPtr">
            <summary>
            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.
            This includes:
              IntPtr to/from int
              IntPtr to/from long
              IntPtr to/from void*
              UIntPtr to/from int
              UIntPtr to/from long
              UIntPtr to/from void*
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.Method">
            <summary>
            The conversion's Method is only valid if IsMethodGroup,
            or IsUserDefined is true,
            and indicates the method used to create the delegate (for a MethodGroup conversion),
            or the method used to perform the conversion (for a UserDefined conversion).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.ResultKind">
            <summary>
            Gives an indication of how successful the conversion was.
            Viable - found a best built-in or user-defined conversion.
            Empty - found no applicable built-in or user-defined conversions.
            OverloadResolutionFailure - found applicable conversions, but no unique best.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.UserDefinedFromConversion">
            <summary>
            Conversion applied to operand of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.UserDefinedToConversion">
            <summary>
            Conversion applied to the result of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Conversion.OriginalUserDefinedConversions">
            <summary>
            The user-defined operators that were considered when attempting this conversion
            (i.e. the arguments to overload resolution).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodTypeInferrer.GetInterfaceInferenceBound(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamedTypeSymbol},Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Return the interface with an original definition matches
            the original definition of the target. If the are no matches,
            or multiple multiple matches, the return value is null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodTypeInferrer.GetInferredTypeArguments">
            <summary>
            Return the inferred type arguments using the original type
            parameters for any type arguments that were not inferred.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAnalysisResult.HasAnyRefOmittedArgument">
            <summary>
            Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are invoking a method/property on an instance of a COM imported type.
            This property returns a flag indicating whether we had any ref omitted argument for the given call.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.None">
            <summary>
            No resolution has (yet) been determined.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.ApplicableInNormalForm">
            <summary>
            The candidate member was accepted in its normal (non-expanded) form.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.ApplicableInExpandedForm">
            <summary>
            The candidate member was accepted in its expanded form, after expanding a "params" parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.InaccessibleTypeArgument">
            <summary>
            The candidate member was rejected because an inferred type argument is inaccessible.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.NoCorrespondingParameter">
            <summary>
            The candidate member was rejected because an argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.RequiredParameterMissing">
            <summary>
            The candidate member was rejected because an required parameter had no corresponding argument.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.NameUsedForPositional">
            <summary>
            The candidate member was rejected because a named argument was used that corresponded to a previously-given positional argument.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.UseSiteError">
            <summary>
            The candidate member was rejected because it is not supported by the language or cannot be used 
            given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.BadArguments">
            <summary>
            The candidate member was rejected because an argument could not be converted to the appropriate parameter
            type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate member was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.TypeInferenceExtensionInstanceArgument">
            <summary>
            The extension method candidate was rejected because type
            inference based on the "instance" argument failed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.BadGenericArity">
            <summary>
            The candidate member was rejected because it had the wrong number of type parameters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.ConstructedParameterFailedConstraintCheck">
            <summary>
            The candidate member was rejected because it a constraint on a type parameter was not satisfied.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.LessDerived">
            <summary>
            The candidate member was rejected because another member further down in the inheritance hierarchy was
            present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberResolutionKind.Worse">
            <summary>
            The candidate member was rejected because it was considered worse that another member (according to sectino
            7.5.3.2 of the language specification).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberResolutionResult`1">
            <summary>
            Represents the results of overload resolution for a single member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberResolutionResult`1.Member">
            <summary>
            The member considered during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberResolutionResult`1.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberResolutionResult`1.IsValid">
            <summary>
            Returns true if the compiler accepted this member as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberResolutionResult`1.Result">
            <summary>
            The result of member analysis.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverloadResolutionResult`1">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.UnwrapIfParamsArray(Roslyn.Compilers.CSharp.ParameterSymbol)">
            <summary>
            If an argument fails to convert to the type of the corresponding parameter and that
            parameter is a params array, then the error message should reflect the element type
            of the params array - not the array type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OverloadResolutionResult`1.HasAnyApplicableMethod">
            <summary>
            Returns true if one or more of the methods in the group are applicable. (Note that
            Succeeded implies IsApplicable but IsApplicable does not imply Succeeded.  It is possible
            that no applicable method was better than all others.)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SingleLookupResult">
            <summary>
            Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope). The
            typical use is to represent that a particular symbol is good/bad/unavailable.
            
            For more explanation of Kind, Symbol, Error - see LookupResult.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InteractiveUsingsBinder.RebindAndAddUsings(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamespaceOrTypeAndUsingDirective},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamespaceOrTypeAndUsingDirective})">
            <summary>
            Returns a new list of usings with all namespace symbols replaced by namespace symbols updated from current compilation references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundCall.OriginalMethodsOpt">
            <summary>
            The set of method symbols from which this call's method was chosen. 
            Only kept in the tree if the call was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundIndexerAccess.OriginalIndexersOpt">
            <summary>
            The set of indexer symbols from which this call's indexer was chosen. 
            Only kept in the tree if the call was an error and overload resolution
            was unable to choose a best indexer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundBinaryOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundUnaryOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundIncrementOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundCompoundAssignmentOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BoundConversion.SynthesizedNonUserDefined(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.ConversionKind,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ConstantValue)">
            <remarks>
            This method is intended for passes other than the LocalRewriter.
            Use MakeConversion helper method in the LocalRewriter instead,
            it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BoundConversion.Synthesized(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.Conversion,System.Boolean,System.Boolean,Roslyn.Compilers.ConstantValue,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean)">
            <remarks>
            NOTE:    This method is intended for passes other than the LocalRewriter.
            NOTE:    Use MakeConversion helper method in the LocalRewriter instead,
            NOTE:    it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BoundConversion.OriginalUserDefinedConversionsOpt">
            <summary>
            The set of method symbols from which this conversion's method was chosen. 
            Only kept in the tree if the conversion was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BoundStatementExtensions.IsLabeledStatement(Roslyn.Compilers.CSharp.BoundStatement)">
            <summary>
            This method is ONLY used in Debug.Assert(...) at some flow analysis API
            Apply following attribute to hide from code coverage tools
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BoundStatementExtensions.IsLabeledStatementWithLabel(Roslyn.Compilers.CSharp.BoundStatement,Roslyn.Compilers.CSharp.LabelSymbol)">
            <summary>
            This method is ONLY used in Debug.Assert(...) at some flow analysis API
            Apply following attribute to hide from code coverage tools
            </summary>
            <param name="node"></param>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.LocalDefUseSpan.ConflictsWith(Roslyn.Compilers.CSharp.CodeGen.LocalDefUseSpan)">
            <summary>
            when current and othe use spans are regular spans we can have only 2 conflict cases:
            [1, 3) conflicts with [0, 2)
            [1, 3) conflicts with [2, 4)
            specifically:
            [1, 3) does not conflict with [0, 1)
            
            NOTE: with regular spans, it is not possible 
            to have start1 == start2 or end1 == end 
            since at the same node we can access only one real local.
            
            However at the same node we can access one or more dummy locals.
            So we can have start1 == start2 and end1 == end2 scenarios, but only if 
            other span is a span of a dummy.
            
            In such cases we consider 
               start2 == span1.start ==> start2 IS included in span1
               end2 == span1.end ==> end2 IS NOT included in span1
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.StackOptimizerPass1.ReuseOrVisit(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.CodeGen.ExprContext)">
            <summary>
            Recursively rewrites the node or simply replaces it with a dup node
            if we have just seen exactly same node.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CommandLineCompiler.OutputFileNamePlaceholder">
            <remarks>
            WARN: No one should take a dependency on this value.  It is only exposed for asserts.
            NOTE: The dot is not legal in an (unquoted) assembly name, so PEVerify should fail if it gets emitted.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CommandLineCompiler.GetOutputFilePaths(Roslyn.Compilers.Common.CommonCompilation,System.String,System.Threading.CancellationToken,System.String@,System.String@,System.String@)">
            <summary>
            Given a compilation and a destination directory, determine three names:
              1) The name with which the assembly should be output.
              2) The path of the assembly/module file.
              3) The path of the pdb file.
            
            When csc produces an executable, but the name of the resulting assembly
            is not specified using the "/out" switch, the name is taken from the name
            of the file (note: file, not class) containing the assembly entrypoint
            (as determined by binding and the "/main" switch).
            
            For example, if the command is "csc /target:exe a.cs b.cs" and b.cs contains the
            entrypoint, then csc will produce "b.exe" and "b.pdb" in the output directory,
            with assembly name "b" and module name "b.exe" embedded in the file.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CommandLineCompiler.GetOutputFileNameOrFallback">
            <summary>
            In C#, if the output file name isn't specified explicitly, then executables take their
            names from the files containing their entrypoints and libraries derive their names from 
            their first input files.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompatibilityMode">
            <summary>
            Enumeration of the different source code compatibility modes.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.None">
            <summary>
            No defined compatibility mode.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.ECMA1">
            <summary>
            The parser accepts only syntax that is included in the ISO/IEC 23270:2003 C# language specification. This
            mode represents the csc switch /langversion:ISO-1
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CompatibilityMode.ECMA2">
            <summary>
            The compiler accepts only syntax that is included in the ISO/IEC 23270:2006 C# language specification. This
            mode represents the csc switch /langversion:ISO-2
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CompilationOptions">
            <summary>
            Represents various options that affect compilation, such as 
            whether to emit an executable or a library, whether to optimize
            generated code, and so on.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationOptions.WithFileAlignment(System.Int32)">
            <summary>
            Sets the byte alignment for portable executable file sections.
            </summary>
            <param name="value">Can be one of the following values: 0, 512, 1024, 2048, 4096, 8192</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.AllowUnsafe">
            <summary>
            Allow unsafe regions (i.e. unsafe modifiers on members and unsafe blocks).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationOptions.Usings">
            <summary>
            Global namespace usings.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeSemanticModel">
            <summary>
            A binding for an attribute.  Represents the result of binding an attribute constructor and
            the positional and named arguments.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BuiltInOperators">
            <summary>
            Internal cahe of built-in operators.
            Cache is compilation-specific becuse it uses compilation-specific SpecialTypes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ForEachStatementInfo">
            <summary>
            Structure containing all semantic information about a for each statement.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ForEachStatementInfo.#ctor(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.PropertySymbol,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ForEachStatementInfo"/> structure.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementInfo.GetEnumeratorMethod">
            <summary>
            Gets the &quot;GetEnumerator&quot; method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementInfo.MoveNextMethod">
            <summary>
            Gets the &quot;MoveNext&quot; method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementInfo.CurrentProperty">
            <summary>
            Gets the &quot;Current&quot; property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementInfo.DisposeMethod">
            <summary>
            Gets the &quot;Dispose&quot; method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.QueryClauseInfo">
            <summary>
            Semantic information associated with a query clause in a C# query expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryClauseInfo.Cast">
            <summary>
            To be obsoleted.  See CastInfo.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryClauseInfo.CastInfo">
            <summary>
            The .Cast&lt;T&gt;() operation generated from the query range variable's type restriction.
            If you want the type restriction, when this is non-null use Cast.TypeArguments[0].
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryClauseInfo.Operation">
            <summary>
            To be obsoleted.  See OperationInfo.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryClauseInfo.OperationInfo">
            <summary>
            The operation (e.g. Select(), Where(), etc) that implements the given clause.
            If it is an extension method, it is returned in reduced form.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InitializerSemanticModel">
            <summary>
            A binding for a field initializer, constructor initializer, or parameter default value.  
            Represents the result of binding an initial
            value expression rather than an block (for that, use a MethodBodySemanticModel).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the syntax node, if any. Returns null if the given
            expression did not bind successfully to a single symbol. If null is returned, it may
            still be that case that we have one or more "best guesses" as to what symbol was
            intended. These best guesses are available via the CandidateSymbols property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SymbolInfo.CandidateSymbols">
            <summary>
            If the expression did not successfully resolve to a symbol, but there were one or more
            symbols that may have been considered but discarded, this property returns those
            symbols. The reason that the symbols did not successfully resolve to a symbol are
            available in the CandidateReason property. For example, if the symbol was inaccessible,
            ambiguous, or used in the wrong context.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SymbolInfo.CandidateReason">
            <summary>
             If the expression did not successfully resolve to a symbol, but there were one or more
             symbols that may have been considered but discarded, this property describes why those
             symbol or symbols were not considered suitable.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeInfo.ImplicitConversion">
            <summary>
            If the expression underwent an implicit conversion, return information about that
            conversion. Otherwise, returns an identity conversion.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedMethodMetadataCompiler">
            <summary>
            When compiling in metadata-only mode, MethodBodyCompiler is not run.  This is problematic
            because MethodBody compiler adds synthesized explicit implementations to the list of
            compiler generated definitions.  In lieu of running MethodBodyCompiler, this class performs
            a quick traversal of the symbol table and calls Module.AddCompilerGeneratedDefinition on each
            synthesized explicit implementation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolVisitor`2">
            <summary>
            Virtual dispatch based on a symbol's particular class. 
            </summary>
            <typeparam name="TArgument">Additional argument type</typeparam>
            <typeparam name="TResult">Result type</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.Visit(Roslyn.Compilers.CSharp.Symbol,`0)">
            <summary>
            Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
            Return default(TResult) if symbol is null
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)">
            <summary>
            The default Visit method called when visiting any <see cref="T:Roslyn.Compilers.CSharp.Symbol"/> and 
            if visiting specific symbol method VisitXXX is not overridden
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitAssembly(Roslyn.Compilers.CSharp.AssemblySymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/>; Override this method with
            specific implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitModule(Roslyn.Compilers.CSharp.ModuleSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/>; Override this method with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitNamespace(Roslyn.Compilers.CSharp.NamespaceSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.NamespaceSymbol"/>; Should override this method if
            want to visit members of the namespace; Calling <see cref="M:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol.GetMembers"/>
            and loop over each member; calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.Visit(Roslyn.Compilers.CSharp.Symbol,`0)"/> on it Or override this with
            specific implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitNamedType(Roslyn.Compilers.CSharp.NamedTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.NamedTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitArrayType(Roslyn.Compilers.CSharp.ArrayTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.ArrayTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitPointerType(Roslyn.Compilers.CSharp.PointerTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.PointerTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitErrorType(Roslyn.Compilers.CSharp.ErrorTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol"/> 
            Error symbol is created when there is compiler error; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitTypeParameter(Roslyn.Compilers.CSharp.TypeParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.TypeParameterSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitDynamicType(Roslyn.Compilers.CSharp.DynamicTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.DynamicTypeSymbol"/>; Override this with specific
            implementation; Calling <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitMethod(Roslyn.Compilers.CSharp.MethodSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitField(Roslyn.Compilers.CSharp.FieldSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.FieldSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitProperty(Roslyn.Compilers.CSharp.PropertySymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.PropertySymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitEvent(Roslyn.Compilers.CSharp.EventSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.EventSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitParameter(Roslyn.Compilers.CSharp.ParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.ParameterSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitLocal(Roslyn.Compilers.CSharp.LocalSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.LocalSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitLabel(Roslyn.Compilers.CSharp.LabelSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitAlias(Roslyn.Compilers.CSharp.AliasSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Roslyn.Compilers.CSharp.AliasSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.VisitRangeVariable(Roslyn.Compilers.CSharp.RangeVariableSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Roslyn.Compilers.CSharp.RangeVariableSymbol"/>; Override this with specific
            implementation; Calling default <see cref="M:Roslyn.Compilers.CSharp.SymbolVisitor`2.DefaultVisit(Roslyn.Compilers.CSharp.Symbol,`0)"/> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DocumentationCommentIDVisitor.PartVisitor">
            <summary>
            A visitor that generates the part of the documentation comment after the initial type
            and colon.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.MAX_UTF8_NAME_LENGTH">
            <summary>
            This is the maximum length of a type or member name in metadata, assuming
            the name is in UTF-8 format and not (yet) null-terminated.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.MAX_UTF8_PATH_LENGTH">
            <summary>
            This is the maximum length of a path in metadata, assuming the path is in UTF-8
            format and not (yet) null-terminated.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NameTruncation.Utf8Encoding">
            <summary>
            This is the same as the default UTF-8 encoding except that the decoder fallback
            behavior has been changed.  Instead of replacing unknown byte sequences with question
            marks, this encoding omits them completely.  Since the only unknown byte sequences
            we expect to see are partial characters on the truncation boundary (since we are
            doing the encoding ourselves), this has the effect of removing partial characters.
            
            For example, suppose you begin with the string "abc\uFFFF".  In UTF-8, this is encoded
            in six bytes (without the null terminator) - one for each of 'a', 'b', and 'c' and 
            three for '\uFFFF'.  If you truncate to 5 bytes, then you end up with 'a', 'b', 'c',
            and the first two bytes of '\uFFFF'.  The decoder replacement fallback simply deletes
            these unrecognized bytes, leaving "abc".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NameTruncation.Truncate(System.Int32,System.String,System.String@)">
            <summary>
            Truncate the given name so that it fits in metadata.
            </summary>
            <param name="maxLength">Max length for name.  (Expected to be at least 5.)</param>
            <param name="fullName">Name to truncate.</param>
            <param name="truncatedName">The name after truncation.</param>
            <returns>True if truncation was required.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedGenericMethodInstanceReference">
            <summary>
            Represents a generic method of a generic type instantiation, closed over type parameters.
            e.g. 
            A{T}.M{S}()
            A.B{T}.C.M{S}()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedMethodReference">
            <summary>
            Represents a method of a generic type instantiation.
            e.g. 
            A{int}.M()
            A.B{int}.C.M()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Location">
            <summary>
            Represents a C# location in source code or metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Location.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serializes the location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor">
            <summary>
            Describes anonymous type in terms of fields
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.Location">
            <summary> Anonymous type location </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.Fields">
            <summary> Anonymous type fields </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.Key">
            <summary>
            Anonymous type descriptor Key 
            
            The key is to be used to separate anonymous type templates in an anonymous type symbol cache. 
            The type descriptors with the same keys are supposed to map to 'the same' anonymous type 
            template in terms of the same generic type being used for their implementation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.Equals(Roslyn.Compilers.CSharp.AnonymousTypeDescriptor)">
            <summary>
            Compares two anonymous type descriptorss, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.Equals(System.Object)">
            <summary>
            Compares two anonymous type descriptorss, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.WithNewFieldsTypes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Creates a new anonymous type descriptor based on 'this' one, 
            but having field types passed as an argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousTypeDescriptor.IsGood">
            <summary> 
            Returns 'true' if all the fields are 'good' 
            This is ONLY used for debugging purpose
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ErrorPropertySymbol">
            <summary>
            When indexer overload resolution fails, we have two options:
              1) Create a BoundBadExpression with the candidates as child nodes;
              2) Create a BoundIndexerAccess with the error flag set.
              
            Option 2 is preferable, because it retains information about the arguments
            (names, ref kind, etc), and results in better output from flow analysis.
            However, we can't create a BoundIndexerAccess with a null indexer symbol,
            so we create an ErrorPropertySymbol to fill the gap.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol">
            <summary>
            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an ErrorSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ErrorInfo">
            <summary>
            The underlying error.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ResultKind">
            <summary>
            Summary of the reason why the type is bad.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this ErrorTypeSymbol, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ReadOnlyArray.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ErrorTypeSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolExtensions">
            <summary>
            SymbolExtensions for member symbols.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetParameters(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Get the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetParameterTypes(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Get the types of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetParameterRefKinds(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Get the ref kinds of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            Count the number of custom modifiers in/on the type
            and parameters (for indexers) of the specified property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.HasCustomModifiers(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetMemberArity(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Return the arity of a member.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetBaseEvent(Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            If the event is overrides another, returns the base virtual event.
            Otherwise return the original event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetOwnOrInheritedAddMethod(Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            If the event has a AddMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedGetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetOwnOrInheritedRemoveMethod(Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            If the event has a RemoveMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedSetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.ConstructIfGeneric(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Returns a constructed named type symbol if 'type' is generic, otherwise just returns 'type'
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.IsBaseTypeOf(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Is this type a base type or effective base type of the other type?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.IsAccessibleViaInheritance(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns true if the members of superType are accessible from subType due to inheritance.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.ContainingNamespaceOrType(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or null
            if the containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns true if all type parameter references within the given
            type belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Returns true if all type parameter references within the given
            types belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolExtensions.GetDocumentationCommentID(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Returns the Documentation Comment ID for the symbol.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the symbol does not support
            documentation comments.</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterDiagnosticInfo">
            <summary>
            A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors
            reported from ConstraintsHelper rather than creating Diagnostics directly.
            This decouples constraints checking from syntax and Locations, and supports
            callers that may want to create Location instances lazily or not at all.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstraintsHelper">
            <summary>
            Helper methods for generic type parameter constraints. There are two sets of methods: one
            set for resolving constraint "bounds" (that is, determining the effective base type, interface set,
            etc.), and another set for checking for constraint violations in type and method references.
            
            Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are
            resolved by each TypeParameterSymbol at, or before, one of the corresponding properties
            (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,
            inconsistent constraints, etc.) and it is the responsibility of the caller to report any such
            errors as declaration errors or use-site errors (depending on whether the type parameter
            was from source or metadata) and to ensure bounds are resolved for source type parameters
            even if the corresponding properties are never accessed directly.
            
            Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints
            overloads for any generic type or method reference from source. In some circumstances,
            references are checked at the time the generic type or generic method is bound and constructed
            by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads
            since compound types (such as A&lt;T&gt;.B&lt;U&gt; or A&lt;B&lt;T&gt;&gt;) are checked
            incrementally as each part is bound. In other cases however, constraint checking needs to be
            delayed to prevent cycles where checking constraints requires binding the syntax that is currently
            being bound (such as the constraint in class C&lt;T&gt; where T : C&lt;T&gt;). In those cases,
            the caller must lazily check constraints, and since the types may be compound types, it is
            necessary to call CheckAllConstraints.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConstraintsHelper.ResolveBounds(Roslyn.Compilers.CSharp.TypeParameterSymbol,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.TypeParameterSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Determine the effective base type, effective interface set, and set of type
            parameters (excluding cycles) from the type parameter constraints. Conflicts
            within the constraints and constraint types are returned as diagnostics.
            'inherited' should be true if the type parameters are from an overridden
            generic method. In those cases, additional constraint checks are applied.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConstraintsHelper.CheckAllConstraints(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.ConversionsBase,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Check all generic constraints on the given type and any containing types
            (such as A&lt;T&gt; in A&lt;T&gt;.B&lt;U&gt;). This includes checking constraints
            on generic types within the type (such as B&lt;T&gt; in A&lt;B&lt;T&gt;[]&gt;).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConstraintsHelper.CheckConstraints(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.ConversionsBase,Roslyn.Compilers.CSharp.TypeMap,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeParameterSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.TypeParameterDiagnosticInfo})">
            <summary>
            Check type parameter constraints for the containing type or method symbol.
            </summary>
            <param name="containingSymbol">The generic type or method.</param>
            <param name="conversions">Conversions instance.</param>
            <param name="substitution">The map from type parameters to type arguments.</param>
            <param name="typeParameters">Containing symbol type parameters.</param>
            <param name="typeArguments">Containing symbol type arguments.</param>
            <param name="diagnosticsBuilder">Diagnostics.</param>
            <returns>True if the constraints were satisfied, false otherwise.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConstraintsHelper.HasPublicParameterlessConstructor(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Return true if the class type has a public parameterless constructor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ConstraintsHelper.IsEncompassedBy(Roslyn.Compilers.CSharp.ConversionsBase,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns true if type a is encompassed by type b (spec 6.4.3),
            and returns false otherwise.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingAttributeData">
            <summary>
            Represents a retargeting custom attribute
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingAttributeData.GetSystemType(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Gets the retargeted System.Type type symbol.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>Retargeted System.Type type symbol.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol">
            <summary>
            Represents a primary module of a RetargetingAssemblySymbol. Essentially this is a wrapper around 
            another SourceModuleSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying module are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NonMissingModuleSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents
            a module that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol},Roslyn.Compilers.CSharp.SourceAssemblySymbol)">
            <summary>
            A helper method for AssemblyManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
            <param name="identities">Identities of referenced assemblies (those that are or will be emitted to metadada).</param>
            <param name="symbols">Assembly symbols that the identities are resolved against.</param>
            
            <param name="originatingSourceAssembly">
            Source assembly that triggered creation of this module symbol.
            For debug purposes only, this assembly symbol should not be persisted within
            this module symbol because the module can be shared across multiple source 
            assemblies. This method will only be called for the first one.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ModuleSymbol.GetModuleNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.ContainingAssembly">
            <summary>
            Returns the containing assembly. Modules are always directly contained by an assembly,
            so this property always returns the same as ContainingSymbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.Kind">
            <summary>
            Returns value 'NetModule' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable'
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsStatic">
            <summary>
            Returns false because module can't be declared as 'static'.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsVirtual">
            <summary>
            Returns false because module can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsOverride">
            <summary>
            Returns false because module can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsAbstract">
            <summary>
            Returns false because module can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsSealed">
            <summary>
            Returns false because module can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.IsExtern">
            <summary>
            Returns false because module can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.HasAssemblyCompilationRelaxationsAttribute">
            <summary>
            Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.HasAssemblyRuntimeCompatibilityAttribute">
            <summary>
            Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ModuleSymbol.DefaultMarshallingCharSet">
            <summary>
            Default char set for contained types, or null if not specified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.referencedAssemblySymbols">
            <summary>
            An array of AssemblySymbol objects corresponding to assemblies referenced by this module.
            The array and its content is provided by AssemblyManager and must not be modified.
            Items at the same position from this array and from GetReferencedAssemblySymbols should 
            correspond to each other. If reference is not resolved by compiler, corresponding item in 
            this array is MissingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.referencedAssemblies">
            <summary>
            An array of assembly identities for assemblies referenced by this module.
            The array and its content is provided by AssemblyManager and must not be modified.
            Items at the same position from this array and from ModuleSymbol.referencedAssemblySymbols
            should correspond to each other. This array is returned by GetReferencedAssemblies() method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol},Roslyn.Compilers.CSharp.SourceAssemblySymbol)">
            <summary>
            A helper method for AssemblyManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.SymbolMap">
            <summary>
            Retargeting map from underlying module to this one.
            
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.retargetingAssembly">
            <summary>
            Owning RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.underlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.retargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the AssemblySymbol referenced by the underlying module,
            value is the corresponding AssemblySymbol referenced by this module, and corresponding
            retargeting map for symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.#ctor(Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol,Roslyn.Compilers.CSharp.SourceModuleSymbol)">
            <summary>
            Constructor.
            </summary>
            <param name="retargetingAssembly">
            Owning assembly.
            </param>
            <param name="underlyingModule">
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.SetReferences(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.AssemblyIdentity},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol},Roslyn.Compilers.CSharp.SourceAssemblySymbol)">
            <summary>
            A helper method for AssemblyManager to set AssemblySymbols for assemblies 
            referenced by this module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.SymbolMap">
            <summary>
            Retargeting map from underlying module to the retargeting module.
            
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssembly">
            <summary>
            RetargetingAssemblySymbol owning retargetingModule.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol for retargetingModule.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the AssemblySymbol referenced by the underlying module,
            value is the corresponding AssemblySymbol referenced by the reatergeting module, and 
            corresponding retargeting map for symbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SignatureOnlyPropertySymbol">
            <summary>
            A representation of a property symbol that is intended only to be used for comparison purposes
            (esp in PropertySignatureComparer).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers">
            <summary>
            Encapsulates the MakeOverriddenOrHiddenMembers functionality for methods, properties (including indexers), 
            and events.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.MakeOverriddenOrHiddenMembersWorker(Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Walk up the type hierarchy from ContainingType and list members that this
            member either overrides (accessible members with the same signature, if this
            member is declared "override") or hides (accessible members with the same name
            but different kinds, plus members that would be in the overrides list if
            this member were not declared "override").
            
            Members in the overridden list may be non-virtual or may have different
            accessibilities, types, accessors, etc.  They are really candidates to be
            overridden.
            
            Members in the hidden list are definitely hidden.
            
            Members in the runtime overridden list are indistinguishable from the members
            in the overridden list from the point of view of the runtime (see
            FindOtherOverriddenMethodsInContainingType for details).
            </summary>
            <remarks>
            In the presence of non-C# types, the meaning of "same signature" is rather
            complicated.  If this member isn't from source, then it refers to the runtime's
            notion of signature (i.e. including return type, custom modifiers, etc).
            If this member is from source, then the process is (conceptually) as follows.
            
            1) Walk up the type hierarchy, recording all matching members with the same
               signature, ignoring custom modifiers and return type.  Stop if a hidden
               member is encountered.
            2) Apply the following "tie-breaker" rules until you have at most one member,
               a) Prefer members in more derived types.
               b) Prefer an exact custom modifier match (i.e. none, for a source member).
               c) Prefer fewer custom modifiers (values/positions don't matter, just count).
               d) Prefer earlier in GetMembers order (within the same type).
            3) If a member remains, search its containing type for other members that
               have the same C# signature (overridden members) or runtime signature
               (runtime overridden members).
            
            In metadata, properties participate in overriding only through their accessors.
            That is, property/event accessors may implicitly or explicitly override other methods
            and a property/event can be considered to override another property/event if its accessors
            override those of the other property/event.
            This implementation (like Dev10) will not follow that approach.  Instead, it is
            based on spec section 10.7.5, which treats properties as entities in their own
            right.  If all property/event accessors have conventional names in metadata and nothing
            "unusual" is done with explicit overriding, this approach should produce the same
            results as an implementation based on accessor overriding.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.MakePropertyAccessorOverriddenOrHiddenMembers(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding properties.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakePropertyAccessorOverriddenOrHiddenMembers delegates to the associated property.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a property hidden
            by the associated property.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a property (directly or indirectly) overridden by the associated property.
            
            Example 1:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public override int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set overrides A.P.set because C.P.set is the setter of C.P, which overrides B.P,
            which overrides A.P, which has A.P.set as a setter.
            
            Example 2:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public new virtual int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set does not override any method because C.P overrides B.P, which has no setter
            and does not override a property.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedProperty">The property associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Property.OverriddenOrHiddenMembers handles that.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.MakeEventAccessorOverriddenOrHiddenMembers(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding events.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakeEventAccessorOverriddenOrHiddenMembers delegates to the associated event.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a event hidden
            by the associated event.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a event (directly or indirectly) overridden by the associated event.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedEvent">The event associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Event.OverriddenOrHiddenMembers handles that.
            
            CONSIDER: It is an error for an event to have only one accessor.  Currently, we mimic the behavior for
            properties, for consistency, but an alternative approach would be to say that nothing is overridden.
            
            CONSIDER: is there a way to share code with MakePropertyAccessorOverriddenOrHiddenMembers?
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.FindOverriddenOrHiddenMembersInType(Roslyn.Compilers.CSharp.Symbol,System.Boolean,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,System.Boolean@,Roslyn.Compilers.CSharp.Symbol@,System.Int32@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Look for overridden or hidden members in a specific type.
            </summary>
            <param name="member">Member that is hiding or overriding.</param>
            <param name="memberIsFromSource">True if member is from source (member.OriginalDefinition.IsFromSource).</param>
            <param name="thisContainingType">The type that contains member (member.ContainingType).</param>
            <param name="currType">The type to search.</param>
            <param name="currTypeHasExactMatch">Will be set to true if there's an exact signature match (including custom modifiers).</param>
            <param name="currTypeBestMatch">
            A member with the same signature if currTypeHasExactMatch is true,
            a member with (a minimal number of) different custom modifiers if there is one,
            and null otherwise.</param>
            <param name="minCustomModifierCount">Running minimal custom modifier count.  May not be updated if exact match found.</param>
            <param name="hiddenBuilder">Hidden members (same name, different kind) will be added to this builder.</param>
            <remarks>
            There is some similarity between this member and TypeSymbol.FindPotentialImplicitImplementationMethodDeclaredInType.
            When making changes to this member, think about whether or not they should also be applied in TypeSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.FindRelatedMembers(System.Boolean,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol}@,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            If representative member is non-null and is contained in a constructed type, then find
            other members in the same type with the same signature.  If this is an override member,
            add them to the overridden and runtime overridden lists.  Otherwise, add them to the
            hidden list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.AddHiddenMemberIfNotDestructorOperatorOrConversion(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.Symbol)">
            <summary>
            Destructors are never considered to be hidden, so filter them out.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.FindOtherOverriddenMethodsInContainingType(Roslyn.Compilers.CSharp.Symbol,System.Boolean,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Having found the best member to override, we want to find members with the same signature on the
            best member's containing type.
            </summary>
            <param name="representativeMember">
            The member that we consider to be overridden (may have different custom modifiers from the overriding member).
            Assumed to already be in the overridden and runtime overridden lists.
            </param>
            <param name="overridingMemberIsFromSource">
            If the best match was based on the custom modifier count, rather than the custom modifiers themselves 
            (because the overriding member is in source), then we should use the count when determining whether the 
            override is ambiguous.
            </param>
            <param name="overriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) members have the same signature
            (including custom modifiers).  Return a list of such members so that we can report the ambiguity.
            </param>
            <param name="runtimeOverriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) members have the same signature
            (including custom modifiers) in metadata (no ref/out distinction).  Return a list of such members so
            that we can report the ambiguity.
            
            Even in a non-generic type, it's possible for two indexers to have the same signature.  For example,
            this would be the case if the default member of a type is "get_Item" and indexers "A" and "B", 
            with the same signature, both have an indexer called "get_Item".
            
            From: SymbolPreparer.cpp
            DevDiv Bugs 115384: Both out and ref parameters are implemented as references. In addition, out parameters are 
            decorated with OutAttribute. In CLR when a signature is looked up in virtual dispatch, CLR does not distinguish
            between these to parameter types. The choice is the last method in the vtable. Therefore we check and warn if 
            there would potentially be a mismatch in CLRs and C#s choice of the overriden method. Unfortunately we have no 
            way of communicating to CLR which method is the overriden one. We only run into this problem when the the 
            parameters are generic.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.FindOtherHiddenMembersInContainingType(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Having found that we are hiding a method with exactly the same signature
            (including custom modifiers), we want to find methods with the same signature
            on the declaring type because they will also be hidden.
            (If the declaring type is constructed, it's possible that two or more
            methods have the same signature (including custom modifiers).)
            (If the representative member is an indexer, it's possible that two or more
            properties have the same signature (including custom modifiers, even in a
            non-generic type).
            </summary>
            <param name="representativeMember">
            The member that we consider to be hidden (must have exactly the same custom modifiers as the hiding member).
            Assumed to already be in hiddenBuilder.
            </param>
            <param name="hiddenBuilder">
            Will have all other members with the same signature (including custom modifiers) as 
            representativeMember added.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.GetRuntimeOverriddenMethodIgnoringNewSlot(Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean)">
            <summary>
            Given a method, find the method that it overrides from the perspective of the CLI.
            Key differences from C#: non-virtual methods are ignored, the RuntimeSignatureComparer
            is used (i.e. consider return types, ignore ref/out distinction).
            </summary>
            <remarks>
            WARN: Must not check method.MethodKind - PEMethodSymbol.ComputeMethodKind uses this method.
            NOTE: Does not check whether the given method will be marked "newslot" in metadata (which
            would indicate that it does not override anything).
            WARN: If the method may override a source method and declaration diagnostics have yet to
            be computed, then it is important to pass ignoreInterfaceImplementationChanges: true
            (see MethodSymbol.IsMetadataVirtual for details).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersHelpers.IsOverriddenSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <remarks>
            Note that the access check is done using the original definitions.  This is because we want to avoid
            reductions in accessibility that result from type argument substitution (e.g. if an inaccessible type
            has been passed as a type argument).
            See DevDiv #11967 for an example.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EventSymbolExtensions.GetLeastOverriddenEvent(Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            Walk up OverriddenEvent and return the first EventSymbol for which OverriddenEvent is null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EventSymbolExtensions.GetBadEventUsageDiagnosticInfo(Roslyn.Compilers.CSharp.EventSymbol)">
            <summary>
            There are two BadEventUsage error codes and this method decides which one should
            be used for a given event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbolExtensions.InferExtensionMethodTypeArguments(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            If the extension method is applicable based on the "this" argument type, return
            the method constructed with the inferred type arguments. If the method is not an
            unconstructed generic method, type inference is skipped. If the method is not
            applicable, or if constraints when inferring type parameters from the "this" type
            are not satisfied, the return value is null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbolExtensions.IsRuntimeFinalizer(Roslyn.Compilers.CSharp.MethodSymbol,System.Boolean)">
            <summary>
            The runtime considers a method to be a finalizer (i.e. a method that should be invoked
            by the garbage collector) if it (directly or indirectly) overrides System.Object.Finalize.
            </summary>
            <remarks>
            As an optimization, return true immediately for metadata methods with MethodKind
            Destructor - they are guaranteed to be finalizers.
            </remarks>
            <param name="method">Method to inspect.</param>
            <param name="skipFirstMethodKindCheck">This method is used to determine the method kind of
            a PEMethodSymbol, so we may need to avoid using MethodKind until we move on to a different
            MethodSymbol.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodSymbolExtensions.ConstructIfGeneric(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Returns a constructed method symbol if 'method' is generic, otherwise just returns 'method'
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceExtent">
            <summary>
            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a
            particular module, assembly, or merged across all modules (source and metadata) in a
            particular compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.ModuleSymbol)">
            <summary>
            Create a NamespaceExtent that represents a given ModuleSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a NamespaceExtent that represents a given AssemblySymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceExtent.#ctor(Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Create a NamespaceExtent that represents a given Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Kind">
            <summary>
            Returns what kind of extent: Module, Assembly, or Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Module">
            <summary>
            If the Kind is ExtendKind.Module, returns the module symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Assembly">
            <summary>
            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceExtent.Compilation">
            <summary>
            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this
            namespace encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RangeVariableSymbol">
            <summary>
            A RangeVariableSymbol represents an identifier introduced in a query expression as the
            identifier of a "from" clause, an "into" query continuation, a "let" clause, or a "join" clause.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RangeVariableSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RangeVariableSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReducedExtensionMethodSymbol">
            <summary>
            An extension method with the "this" parameter removed.
            Used for the public binding API only, not for compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ReducedExtensionMethodSymbol.Create(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return the extension method in reduced form if the extension method
            is applicable, and satisfies type parameter constraints, based on the
            "this" argument type. Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EventSymbol">
            <summary>
            Represents an event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EventSymbol.GetFieldAttributes">
            <summary>
            Gets the attributes on event's associated field, if any.
            Returns an empty <see cref="T:Roslyn.Compilers.ReadOnlyArray`1"/> if
            there are no attributes.
            </summary>
            <remarks>
            This publicly exposes the attributes of the internal backing field.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.EventSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.Type">
            <summary>
            The type of the event. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface events explicitly implemented by this event.
            </summary>
            <remarks>
            Events imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingEventSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingEventSymbol.underlyingEvent">
            <summary>
            The underlying EventSymbol, cannot be another RetargetingEventSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceEventFieldSymbol">
            <summary>
            A delegate field associated with a <see cref="T:Roslyn.Compilers.CSharp.SourceFieldLikeEventSymbol"/>.
            </summary>
            <remarks>
            SourceFieldSymbol takes care of the initializer (plus "var" in the interactive case).
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedFieldLikeEventAccessorSymbol">
            <summary>
            Event accessor that has been synthesized for a field-like event declared in source.
            </summary>
            <remarks>
            Associated with <see cref="T:Roslyn.Compilers.CSharp.SourceFieldLikeEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceFieldLikeEventSymbol">
            <summary>
            This class represents an event declared in source without explicit accessors.
            It implicitly has an associated field (of the same name) and thread-safe accessors.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceEventSymbol">
            <summary>
            This class represents an event declared in source.  It may be either
            field-like (see SourceFieldLikeEventSymbol) or property-like (see
            SourceCustomEventSymbol).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceEventSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceEventSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceEventSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceEventSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceEventSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceEventSymbol.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the event symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceEventSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute. 
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceEventSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceCustomEventSymbol">
            <summary>
            This class represents an event declared in source with explicit accessors
            (i.e. not a field-like event).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceCustomEventAccessorSymbol">
            <summary>
            This class represents an event accessor declared in source 
            (i.e. not one synthesized for a field-like event).
            </summary>
            <remarks>
            The accessors are associated with <see cref="T:Roslyn.Compilers.CSharp.SourceCustomEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedTypeParameterSymbol">
            <summary>
            A type parameter for a synthesized class or method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterConstraintClause">
            <summary>
            A simple representation of a type parameter constraint clause
            as a set of constraint bits and a set of constraint types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEEventSymbol">
            <summary>
            The class to represent all events imported from a PE/module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PEEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this event, E, explicitly implements an interface event, IE, 
            if E.add explicitly implements IE.add and E.remove explicitly implements IE.remove.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PEPropertyOrEventHelpers">
            <summary>
            Helper methods that exist to share code between properties and events.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEAttributeData">
            <summary>
            Represents a PE custom attribute
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
            the attribute.
            </summary>
            <param name="namespaceName"></param>
            <param name="typeName"></param>
            <returns>True if the attribute data matches.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEAttributeData.IsTargetAttribute(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.AttributeDescription)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
            type symbol for the attribute.
            </summary>
            <param name="targetSymbol">Target symbol.</param>
            <param name="description">Attribute to match.</param>
            <returns>True if the attribute matches.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingModuleSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingModuleSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ModuleSymbol"/> that represents
            a module that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingNamespaceSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.NamespaceSymbol"/> that represents
            a namespace that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
            <returns>An IEnumerable containing all the namespaces that are members of this symbol.
            If this symbol has no namespace members, returns an empty IEnumerable. Never returns
            null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.Accept``2(Roslyn.Compilers.CSharp.SymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.LookupNestedNamespace(Roslyn.Compilers.ReadOnlyArray{System.String})">
            <summary>
            Lookup a nested namespace.
            </summary>
            <param name="names">
            Sequence of names for nested child namespaces.
            </param>
            <returns>
            Symbol for the most nested namespace, if found. Nothing 
            if namespace or any part of it can not be found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NamespaceSymbol.GetExtensionMethods(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.MethodSymbol},System.String,System.Int32,Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Add all extension methods in this namespace to the given list. If name or arity
            or both are provided, only those extension methods that match are included.
            </summary>
            <param name="methods">Methods list</param>
            <param name="nameOpt">Optional method name</param>
            <param name="arity">Method arity</param>
            <param name="options">Lookup options</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.Extent">
            <summary>
            Namespaces are by their nature open-ended, but a NamespaceSymbol contains a specific set
            of members. The set of members contained by a NamespaceSymbol is denoted by the Extent
            of the namespace. If a Namespace has an module Extent, it contains members of the
            namespace that are present in a particular module. If a Namespace has an compilation
            extent, it contains all members of the namespace in a compilation, including those
            defined in source and all directly referenced metadata assemblies (or added metadata
            modules). 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace has Assembly or Compilation extent, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ContainingAssembly">
            <summary>
            Containing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.AssemblySymbol"/> that represents
            an assembly that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.emittedNameToTypeMap">
            <summary>
            This is a cache similar to the one used by MetaImport::GetTypeByName
            in native compiler. The difference is that native compiler pre-populates 
            the cache when it loads types. Here we are populating the cache only
            with things we looked for, so that next time we are looking for the same 
            thing, the lookup is fast. This cache also takes care of TypeForwarders. 
            Gives about 8% win on subsequent lookups in some scenarios.     
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.LookupTopLevelMetadataType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Roslyn.Compilers.Internal.MetadataTypeName@,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            NOTE: Methods other than this one should call LookupTopLevelMetadataType, rather than this method.
            
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <remarks>
            This is the only place where we look into other assemblies for forwarding types, so this is the only
            place where we need to pass along a list of visited assemblies.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceLocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceLocalSymbol.isSpecificallyNotPinned">
            <summary>
            There are three ways to initialize a fixed statement local:
              1) with an address;
              2) with an array (or fixed-size buffer); or
              3) with a string.
            
            In the first two cases, the resulting local will be emitted with a "pinned" modifier.
            In the third case, it is not the fixed statement local but a synthesized temp that is pinned.  
            Unfortunately, we can't distinguish these cases when the local is declared; we only know
            once we have bound the initializer.
            </summary>
            <remarks>
            CompareExchange doesn't support bool, so use an int.  First bit is true/false, second bit 
            is read/unread (debug-only).
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceLocalSymbol.constantTuple">
            <summary>
            Store the constant value and the corresponding diagnostics together
            to avoid having the former set by one thread and the latter set by
            another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceLocalSymbol.MakeConstantTuple(Roslyn.Compilers.CSharp.LocalSymbol,Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Determine the constant value of this local and the corresponding diagnostics.
            Set both to constantTuple in a single operation for thread safety.
            </summary>
            <param name="inProgress">Null for the initial call, non-null if we are in the process of evaluating a constant.</param>
            <param name="boundInitValue">If we already have the bound node for the initial value, pass it in to avoid recomputing it.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLocalSymbol.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLocalSymbol.Locations">
            <summary>
            Gets the locations where the local symbol was originally defined in source.
            There should not be local symbols from metadata, and there should be only one local variable declared.
            TODO: check if there are multiple same name local variables - error symbol or local symbol?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
            <summary>
            Register COR types declared in this namespace, if any, in the COR types cache.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsRestrictedBaseType(Roslyn.Compilers.SpecialType)">
            <summary>
            Returns true if the type cannot be used as an explicit base class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetSynthesizedExplicitImplementations(System.Threading.CancellationToken)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.AddHidingAbstractDiagnostic(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Location,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag,System.Boolean@)">
            <summary>
            If necessary, report a diagnostic for a hidden abstract member.
            </summary>
            <returns>True if a diagnostic was reported.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckInterfaceUnification(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            It is invalid for a type to directly (vs through a base class) implement two interfaces that
            unify (i.e. are the same for some substitution of type parameters).
            </summary>
            <remarks>
            CONSIDER: check this while building up InterfacesAndTheirBaseInterfaces (only in the SourceNamedTypeSymbol case).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ImplementInterfaceMember(Roslyn.Compilers.CSharp.TypeSymbol.SymbolAndDiagnostics,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.SynthesizedExplicitImplementationMethod})">
            <summary>
            Though there is a method that C# considers to be an implementation of the interface method, that
            method may not be considered an implementation by the CLR.  In particular, implicit implementation
            methods that are non-virtual or that have different (usually fewer) custom modifiers than the
            interface method, will not be considered CLR overrides.  To address this problem, we either make
            them virtual (in metadata, not in C#), or we introduce an explicit interface implementation that
            delegates to the implicit implementation.
            </summary>
            <param name="implementingMemberAndDiagnostics">Returned from FindImplementationForInterfaceMemberWithDiagnostics.</param>
            <param name="interfaceMember">The interface method or property that is being implemented.</param>
            <param name="synthesizedImplementations">A list to which we should add any stubs that we generate.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsPossibleImplementationUnderRuntimeRules(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            The CLR will only look for an implementation of an interface method in a type that
              1) declares that it implements that interface; or
              2) is a base class of a type that declares that it implements the interface but not
                   a subtype of a class that declares that it implements the interface.
                   
            For example,
            
              interface I
              class A
              class B : A, I
              class C : B
              class D : C, I
            
            Suppose the runtime is looking for D's implementation of a member of I.  It will look in 
            D because of (1), will not look in C, will look in B because of (1), and will look in A
            because of (2).
            
            The key point is that it does not look in C, which C# *does*.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.IsOverrideOfPossibleImplementationUnderRuntimeRules(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might
            still be okay, but dynamic dispath might result in C#'s choice getting called anyway.
            </summary>
            <remarks>
            This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.
            
            ACASEY: What the native compiler actually does (I think) is compute the C# answer, compute the CLR answer,
            and then confirm that they override the same method.  What I've done here is check for the situations
            where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative
            check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.AddPointedAtType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Whenever a pointer type is referenced in syntax, we have to check whether
            the pointed at type is managed.  For struct types, this means checking
            whether any of the instance fields have managed types.  If one of the
            instance field types refers back to this type, then we're going to hit
            infinite recursion because we don't expose the types of instance fields
            of this type until BindType has been called on the syntax and BindType
            wants to consume the instance field types for IsManagedType (see
            BaseTypeAnalysis.IsManagedType for the actual implementation).  We break
            this cycle by having BindType store enough information to do the check
            and report a diagnostic during ForceComplete.  This method holds that
            information.
            
            WARN: lazyPointedAtTypes is consumed by CheckForPointedAtManagedTypes,
            so never call this after that method has started.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetEarlyAttributeDecodingMembers">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol.
            
            In particular, this method will return nested types and fields (other than auto-property
            backing fields).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            
            In particular, this method will return nested types and fields (other than auto-property
            backing fields).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.EffectiveAccessibility">
            <summary>
            Compute the "effective accessibility" of the current class for the purpose of warnings about unused fields.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckForPointedAtManagedTypes(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            If this is a struct type and one or more members referenced a pointer type in 
            its declaration, then the pointer type - along with the corresponding syntax -
            is stored in lazyPointedAtTypes.  Walk over that structure and report a 
            diagnostic for each managed type encountered.
            
            WARN: lazyPointedAtTypes may be incomplete if the members of this type are not
            complete, so never call this before CompletionPart.MembersCompleted is set.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.MergeIndexersAndNonIndexers(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Merge (already ordered) non-type, non-indexer members with (already ordered) indexer members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.FixPartialMember(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.CSharp.SourceMemberMethodSymbol)">
            <summary>
            Fix up a partial method by combining its defining and implementing declarations, updating the array of symbols (by name),
            and returning the combined symbol.
            </summary>
            <param name="symbols">The symbols array containing both the latent and implementing declaration</param>
            <param name="part1">One of the two declarations</param>
            <param name="part2">The other declaration</param>
            <returns>An updated symbols array containing only one method symbol representing the two parts</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckForMemberConflictWithPropertyAccessor(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the property accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.CheckForMemberConflictWithEventAccessor(Roslyn.Compilers.CSharp.EventSymbol,System.Boolean,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the event accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetAccessorOrPropertyLocation(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetAccessorOrEventLocation(Roslyn.Compilers.CSharp.EventSymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ParametersMatchPropertyAccessor(Roslyn.Compilers.CSharp.PropertySymbol,System.Boolean,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            property accessor, including the value parameter for the setter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ParametersMatchEventAccessor(Roslyn.Compilers.CSharp.EventSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            event accessor, including the value parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.lazyTypeParameterConstraints">
            <summary>
            A collection of type parameter constraints, populated when
            constraints for the first type parameter are requested.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.GetSynthesizedAttributes">
            <remarks>
            These won't be returned by GetAttributes on source methods, but they
            will be returned by GetAttributes on metadata symbols.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.BaseType">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.EnumValueField">
            <summary>
            For enum types, returns the synthesized instance field used
            for generating metadata. Returns null for non-enum types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceNamedTypeSymbol.MembersAndInitializers">
            <summary>
            Encapsulates information about the non-type members of a (i.e. this) type.
              1) For non-initializers, symbols are created and stored in a list.
              2) For fields, the symbols are stored in (1) and the initializers are
                   stored with other initialized fields from the same syntax tree with
                   the same static-ness.
              3) For indexers, syntax (weak) references are stored for later binding.
            </summary>
            <remarks>
            CONSIDER: most types won't have indexers, so we could move the indexer list
            into a subclass to spare most instances the space required for the field.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedBackingFieldSymbol">
            <summary>
            Represents a compiler generated backing field for an automatically implemented property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypedConstant">
            <summary>
            <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/> represents a constant value used as an argument to a custom attribute. 
            The <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/> can represent a primitive type, an enum type, a <see cref="T:System.Type"/> 
            or an array of <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>s. 
            </summary>
            <remarks>
            Kind            Value                                   Type
            Primitive       Boxed value, string or null             <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> for the boxed value
            Enum            Boxed value of the underlying type      <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> for enum
            Type            <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> or null        <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> for <see cref="T:System.Type"/>
            Array           <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>[] or null   <see cref="T:Roslyn.Compilers.CSharp.ArrayTypeSymbol"/>
            Error           null                                    <see cref="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol"/> or null
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypedConstant.ToString">
            <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
            <returns>A System.String that represents the current TypedConstant.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Kind">
            <summary>
            Returns the kind of the <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Type">
            <summary>
            Returns the <see cref="T:Roslyn.Compilers.CSharp.TypeSymbol"/> of the <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>, 
            or null if the type can't be determined (error).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Value">
            <summary>
            Returns the value of a non-array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. Throws if called on an array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypedConstant.Values">
            <summary>
            Returns the value of an array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>. Throws if called on a non-array <see cref="T:Roslyn.Compilers.CSharp.TypedConstant"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterBounds">
            <summary>
            The effective "bounds" of a type parameter: the constraint types, effective
            interface set, and effective base type, determined from the declared
            constraints, with any cycles removed. The fields are exposed by the
            TypeParameterSymbol as ConstraintTypes, Interfaces, and BaseType.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.TypeParameterBounds.ConstraintTypes">
            <summary>
            The type parameters, classes, and interfaces explicitly declared as
            constraint types on the containing type parameter, with cycles removed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.TypeParameterBounds.Interfaces">
            <summary>
            The set of interfaces explicitly declared on the containing type
            parameter and any type parameters on which the containing
            type parameter depends, with duplicates removed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsValidAttributeParameterType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Determines if the given type is a valid attribute parameter type
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetAttributeParameterTypedConstantKind(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Gets the typed constant kind for the given attribute parameter type.
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns>TypedConstantKind for the attribute parameter type</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsExpressionTree(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            return true if the type is constructed from System.Linq.Expressions.Expression`1
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetDefaultValue(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return the default value constant for the given type,
            or null if the default value is not a constant.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.VisitType``1(Roslyn.Compilers.CSharp.TypeSymbol,System.Func{Roslyn.Compilers.CSharp.TypeSymbol,``0,System.Boolean},``0)">
            <summary>
            Visit the given type and, in the case of compound types, visit all "sub type"
            (such as A in A[], or { A&lt;T&gt;, T, U } in A&lt;T&gt;.B&lt;U&gt;) invoking 'predicate'
            with the type and 'arg' at each sub type. If the predicate returns true for any type,
            traversal stops and that type is returned from this method. Otherwise if traversal
            completes without the predicate returning true for any type, this method returns null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ContainsTypeParameter(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeParameterSymbol)">
            <summary>
            (null TypeParameterSymbol "parameter"): Checks if the given type is a type parameter 
            or its referent type is a type parameter (array/pointer) or contains a type parameter (aggregate type)
            (non-null TypeParameterSymbol "parameter"): above + also checks if the type parameter
            is the same as "parameter"
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ContainsDynamic(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return true if the type contains any dynamic type reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNonErrorGuess(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Guess the non-error type that the given type was intended to represent.
            If the type itself is not an error type, then it will be returned.
            Otherwise, the underlying type (if any) of the error type will be
            returned.
            </summary>
            <remarks>
            Any non-null type symbol returned is guaranteed not to be an error type.
            
            It is possible to pass in a constructed type and received back an 
            unconstructed type.  This can occur when the type passed in was
            constructed from an error type - the underlying definition will be
            available, but there won't be a good way to "re-substitute" back up
            to the level of the specified type.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNonErrorTypeKindGuess(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Guess the non-error typekind that the given type was intended to represent,
            if possible. If not, return TypeKind.Error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsValidSwitchGoverningType(Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean)">
            <summary>
            Returns true if the type is a valid switch expression type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsRestrictedType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Returns true if the type is one of the restricted types, namely: System.TypedReference, 
            System.ArgIterator, or System.RuntimeArgumentHandle.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsIntrinsicType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            The type is one of the simple types defined in Dev10 C#, see "predeftype.h"/simple
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.MarkCheckedIfNecessary(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol}@)">
            <summary>
            Add this instance to the set of checked types. Returns true
            if this was added, false if the type was already in the set.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.ComputeHashCode(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Compute a hash code for the constructed type. The return value will be
            non-zero so callers can used zero to represent an uninitialized value.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsSameType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Determines if two type symbols represent the same type, according to the language
            semantics.
            </summary>
            <param name="t1">First type.</param>
            <param name="t2">Second type.</param>
            <param name="ignoreCustomModifiers">True to compare without regard to custom modifiers, false by default.</param>
            <param name="ignoreDynamic">True to ignore the distinction between object and dynamic, false by default.</param>
            <returns>True if the types are equivalent.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.IsSameTypeIgnoring(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Logical equality on TypeSymbols that ignores custom modifiers and/or the object/dynamic distinction.
            Differs from IsSameType for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            Ported from VB.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.CustomModifierCount(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Count the custom modifiers within the specified TypeSymbol.
            Potentially non-zero for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.HasCustomModifiers(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Check for custom modifiers within the specified TypeSymbol.
            Potentially true for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            A much less efficient implementation would be CustomModifierCount() == 0.
            CONSIDER: Could share a backing method with CustomModifierCount.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.CanUnifyWith(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return true if this type can unify with the specified type
            (i.e. is the same for some substitution of type parameters).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeSymbolExtensions.GetNextBaseType(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol},Roslyn.Compilers.CSharp.Compilation,System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.Symbol}@)">
            <summary>
            Used when iterating through base types in contexts in which the caller needs to avoid cycles and can't use BaseType
            (perhaps because BaseType is in the process of being computed)
            </summary>
            <param name="type"></param>
            <param name="basesBeingResolved"></param>
            <param name="compilation"></param>
            <param name="visited"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.#ctor(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Int32,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.CloneNodeAsRoot``1(``0,Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Creates a clone of a red node that can be used as a root of given syntaxTree.
            New node has no parents, position == 0, and syntaxTree as specified.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetCachedSlot(System.Int32)">
            <summary>
            Gets a node at given node index without forcing its creation.
            If node was not created it would return null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetNodeSlot(System.Int32)">
            <summary>
            Gets node at given node index. 
            This WILL force node creation if node has not yet been created.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetSlot(System.Int32)">
            <summary>
            Same as GetNodeSlot, but can also return a token. This is used in uncommon cases where
            we do not know if slot is a node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Serialize the syntax node into a byte stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DeserializeFrom(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Deserialize a syntax node from the byte stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            This function calculates the offset of a child at given position. It is very common that
            some children to the left of the given index already know their positions so we first
            check if that is the case. In a worst case the cost is O(n), but it is not generally an
            issue because number of children in regular nodes is fixed and small. In a case where
            the number of children could be large (lists) this function is overridden with more
            efficient implementations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Determines whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLocation">
            <summary>
            Gets a <see cref="P:Roslyn.Compilers.CSharp.SyntaxNode.Location"/> for this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetReference">
            <summary>
            Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstDirective(System.Func{Roslyn.Compilers.CSharp.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLastDirective(System.Func{Roslyn.Compilers.CSharp.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.HasAnnotations(System.Type)">
            <summary>
            Determines whether this node has annotations of the specified type.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotations(System.Type)">
            <summary>
            Gets all annotations of the specified type attached to this node.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotatedNodesAndTokens(System.Type)">
            <summary>
            Gets all nodes and tokens with an annotation of the specified type.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotatedNodesAndTokens(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Gets all nodes and tokens with the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotatedTrivia(System.Type)">
            <summary>
            Finds all trivia with an annotation of the specified type.
            The type must be a strict sub type of SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetAnnotatedTrivia(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Gets all trivia with the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in document order. This list does not contain tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodesAndTokens">
            <summary>
            Gets the list of child nodes and tokens of this node in document order, where each element
            is a SyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes that have type TNode and satisfies the predicate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) that have type TNode and satisfies the predicate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodes(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodes(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndSelf(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search
            descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia
            are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndTokens(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search
            descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia
            are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search
            descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia
            are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search
            descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia
            are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantNodesAndTokensAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search
            descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia
            are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetFirstToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="predicate">Only tokens for which this predicate returns true are included.  Pass null to include
            all tokens.</param>
            <param name="stepInto">Steps into trivia if this is not null.  Only trivia for which this delegate returns
            true are included.</param> 
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last non-zero-width token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantTokens(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant tokens under this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant tokens under this node with a full span that intersects the
            specified span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindToken(System.Int32,System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
              then EoF is returned. 
            
            2) If node.FullSpan.Contains(position) the token that contains given position is
               returned. If stepInto is not Nothing, then structured trivia that satisfies the
               condition will also be visited during the search.
            
            3) Otherwise an IndexOutOfRange is thrown
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
               then EoF is returned. 
            
             2) If node.FullSpan.Contains(position) then the token that contains given position is
                returned.
            
             3) Otherwise an ArgumentOutOfRangeException is thrown
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindTrivia(System.Int32,System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantTrivia(System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            A list of all trivia for all descendant tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.DescendantTrivia(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            A list of all trivia for all descendant tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.ChildNodesAndTokensCore">
            <summary>
            The list of child nodes and tokens of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNode.EquivalentToCore(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.SyntaxTree">
            <summary>
            Returns SyntaxTree that owns the node or null if node does not belong to a SyntaxTree
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Kind">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/>  of the non-terminal.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Position">
            <summary>
            The character position of this node relative to the beginning of the file, not including
            leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.ContainsDirectives">
            <summary>
            Determines whether this node has any descendant preprocessor directives. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any
            diagnostics on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.ContainsAnnotations">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.HasStructuredTrivia">
            <summary>
            Determines whether a descendant trivia of this node is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is
            somewhat more efficient.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.KindCore">
            <summary>
            An integer representing the language specific kind of node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNode.ParentCore">
            <summary>
            The node that holds this node in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AttributeSyntax.GetErrorDisplayName">
            <summary>
            Return the name used in syntax for the attribute. This is typically the class
            name without the "Attribute" suffix. (For certain diagnostics, the native
            compiler uses the attribute name from syntax rather than the class name.)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DiagnosticList">
            <summary>
            A list of <see cref="T:Roslyn.Compilers.CSharp.Diagnostic"/> objects.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.GetEnumerator">
            <summary>
            Returns an enumerator over this list of diagnostics.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Count">
            <summary>
            Returns the count of diagnostic instances in this list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Item(System.Int32)">
            <summary>
            Returns the diagnostic instance at the specified index in this list.
            </summary>
            <param name="index">The index of the diagnostic.</param>
            <returns>The specified diagnostic.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator">
            <summary>
            An enumerator for diagnostic lists.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.MoveNext">
            <summary>
            Moves the enumerator to the next diagnostic instance in the diagnostic list.
            </summary>
            <returns>Returns true if enumerator moved to the next diagnostic, false if the
            enumerator was at the end of the diagnostic list.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DiagnosticList.Enumerator.Current">
            <summary>
            The current diagnostic that the enumerator is pointing at.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list including separators but not including 
            the first node's leading trivia and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including separators, 
            the first node's leading trivia, and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including separators including separators,
            the first node's leading trivia, and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.Add(`0[])">
            <summary>
            Add one or more nodes to the end of the list.
            </summary>
            <returns>A new list with the nodes added.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1.Insert(System.Int32,`0[])">
            <summary>
            Insert one or more nodes in the list at the specified index.
            </summary>
            <returns>A new list with the nodes inserted.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.NameSyntax.GetUnqualifiedName">
            <summary>
            Returns the unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified. 
            </summary>
            <returns>The unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified.
            If called on an instance of <see cref="T:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax"/> returns the value of the <see cref="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.Name"/> property.
            If called on an instance of <see cref="T:Roslyn.Compilers.CSharp.QualifiedNameSyntax"/> returns the value of the <see cref="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.Right"/> property.
            If called on an instance of <see cref="T:Roslyn.Compilers.CSharp.SimpleNameSyntax"/> returns the instance itself.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Determines if the node is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Determines if the token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Determines if the trivia is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.IsPartOfStructuredTrivia(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Determines if the node or token is a descendant of a structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceNodes``2(``0,System.Collections.Generic.IEnumerable{``1},System.Func{``1,``1,Roslyn.Compilers.CSharp.SyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node rewritten with replaced descendants.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceToken``1(``0,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken},System.Func{Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token rewritten with replaced trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia``1(``0,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with a new trivia
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
            <param name="token">The original token.</param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new tree of nodes with the specified old trivia replaced with computed new trivia.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTrivia">The trivia to be replaced; descendants of the root node.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTrivia,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
            <param name="token">The original token.</param>
            <param name="oldTrivia">The trivia to be replaced; descendants of the root token.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceNode``1(``0,Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.SyntaxRemoveOptions,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTriviaList},System.Func{Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="node">The node to remove.</param>
            <param name="options">Options that determine how the node's trivia is treated.</param>
            <param name="keepLeadingTrivia">A function that determines which parts of the leading trivia are kept in the result.</param>
            <param name="keepTrailingTrivia">A function that determines which parts of the trailing trivia are kept in the result.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.ReplaceNodes``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxNode},Roslyn.Compilers.SyntaxRemoveOptions,System.Func{Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTriviaList},System.Func{Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxTriviaList})">
            <summary>
            Creates a new tree of nodes with the specified nodes removed.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node from which to remove a descendant node from.</param>
            <param name="nodes">The nodes to remove.</param>
            <param name="options">Options that determine how the nodes' trivia is treated.</param>
            <param name="keepLeadingTrivia">A function that determines which parts of the leading trivia are kept in the result.</param>
            <param name="keepTrailingTrivia">A function that determines which parts of the trailing trivia are kept in the result.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)">
            <summary>
            Creates a new syntax node with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <typeparam name="TNode">The type of the node.</typeparam>
            <param name="node">The node to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.NormalizeWhitespace(Roslyn.Compilers.CSharp.SyntaxToken,System.String,System.Boolean)">
            <summary>
            Creates a new token with all whitespace and end of line trivia replaced with regularly
            formatted trivia.
            </summary>
            <param name="token">The token to format.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxExtensions.NormalizeWhitespace(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Boolean)">
            <summary>
            Creates a new list of trivia with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="trivia">The list of trivia.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LanguageVersion">
            <summary>
            Specifies the language version.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp1">
            <summary>
            C# language version 1.0.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp2">
            <summary>
            C# language version 2.0.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp3">
            <summary>
            C# language version 3.0.
            </summary>
            <remarks> Features: LINQ.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp4">
            <summary>
            C# language version 4.0.
            </summary>
            <remarks> Features: dynamic.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp5">
            <summary>
            C# language version 5.0.
            </summary>
            <remarks> Features: async.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LanguageVersion.CSharp6">
            <summary> C# language version 6.0.
            </summary>
             <remarks>
             Features: using of a static class.
             </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParseOptions">
            <summary>
            This class stores several source parsing related options and offers access to their values.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ParseOptions.Default">
            <summary>
            The default parse options.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ParseOptions.Compatibility">
            <summary>
            Gets the compatibility mode.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ParseOptions.LanguageVersion">
            <summary>
            Gets the language version.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParseOptions.PreprocessorSymbolNames">
            <summary>
            Gets the names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.Blender.newPosition">
            <summary>
            newPosition represents the position we are in the final IText.  As we consume and reuse
            nodes from the old tree we will update our position in the new text accordingly.
            Likewise, when we must lex tokens out of the new tree we will update as well.
            
            NOTE(cyrusn): We do not need an oldPosition because it is redundant given the
            oldTreeCursor.  The oldPosition is implicitly defined by the position of the cursor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Blender.ExtendToAffectedRange(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.TextChangeRange)">
            <summary>
            Affected range of a change is the range within which nodes can be affected by a change
            and cannot be reused. Because of lookahead effective range of a change is larger than
            the change itself.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.Blender.Cursor">
            <summary>
            THe cursor represents a location in the tree that we can move around to indicate where
            we are in the original tree as we're incrementally parsing.  When it is at a node or
            token, it can either move forward to that entity's next sibling.  It can also move down
            to a node's first child or first token.
            
            Once the cursor hits the end of file, it's done.  Note: the cursor will skip any other
            zero length nodes in the tree.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LexerCache.IdentityDictionary`1">
            <summary>
            This is basically a hash-set of strings that is searchable by  
            strings, string sub ranges, character array ranges or string-builder.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LexerCache.TextMap`1">
            <summary>
            This is basically a hash-set of strings that is searchable by  
            strings, string sub ranges, character array ranges or string-builder.  
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.AddSkippedSyntax(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Boolean)">
            <summary>
            Converts skippedSyntax node into tokens and adds these as trivia on the target token.
            Also adds the first error (in depth-first preorder) found in the skipped syntax tree to the target token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.FindOffset(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Int32@)">
            <summary>
            This function searches for the given location node within the subtree rooted at root node. 
            If it finds it, the function computes the offset span of that child node within the root and returns true, 
            otherwise it returns false.
            </summary>
            <param name="root">Root node</param>
            <param name="location">Node to search in the subtree rooted at root node</param>
            <param name="offset">Offset of the location node within the subtree rooted at child</param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.IsInteractive">
            <summary>
            Interactive code - global statements, member declarations and expressions allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxParser.IsScript">
            <summary>
            Script - global statements and member declarations allowed, but not expressions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.CompileSynthesizedExplicitImplementations(Roslyn.Compilers.CSharp.SourceNamedTypeSymbol,Roslyn.Compilers.CSharp.TypeCompilationState)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MethodBodyCompiler.HasThisConstructorInitializer(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Returns true if the method is a constructor and has a this() constructor initializer.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Accessibility">
            <summary>
            Represents the accessibility of a symbol. Note: This enum is ordered by effective
            accessibility.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Accessibility.NotApplicable">
            <summary>
            Indicates that accessibility is not applicable to this kind of symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Accessibility.ProtectedAndInternal">
            <summary>
            Not supported in C#, but should be supported for symbols imported from reference
            assemblies in other languages.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.VarianceSafety">
            <summary>
            This class groups together all of the functionality needed to check for error CS1961, ERR_UnexpectedVariance.
            Its functionality is accessible through the NamedTypeSymbol extension method CheckInterfaceVarianceSafety and
            the MethodSymbol extension method CheckMethodVarianceSafety (for checking delegate Invoke).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckInterfaceVarianceSafety(Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckMethodVarianceSafety(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckPropertyVarianceSafety(Roslyn.Compilers.CSharp.PropertySymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckEventVarianceSafety(Roslyn.Compilers.CSharp.EventSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckParametersVarianceSafety(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol},Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method/property parameter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.CheckTypeParametersVarianceSafety(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeParameterSymbol},Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method type parameters.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.IsVarianceUnsafe(Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Returns true if the type is output-unsafe or input-unsafe, as defined in the C# spec.
            Roughly, a type is output-unsafe if it could not be the return type of a method and
            input-unsafe if it could not be a parameter type of a method.
            </summary>
            <remarks>
            This method is intended to match spec section 13.1.3.1 as closely as possible 
            (except that the output-unsafe and input-unsafe checks are merged).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.IsVarianceUnsafe(Roslyn.Compilers.CSharp.NamedTypeSymbol,System.Boolean,System.Boolean,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            3) T is an interface, class, struct, or delegate type <![CDATA[S<A_1, ..., A_k>]]> constructed
            from a generic type <![CDATA[S<X_1, ..., X_k>]]> where for at least one A_i one
            of the following holds:
                a) X_i is covariant or invariant and A_i is output-unsafe [input-unsafe]
                b) X_i is contravariant or invariant and A_i is input-unsafe [output-unsafe] (note: spec has "input-safe", but it's a typo)
            </summary>
            <remarks>
            Slight rewrite to make it more idiomatic for C#:
                a) X_i is covariant and A_i is input-unsafe
                b) X_i is contravariant and A_i is output-unsafe
                c) X_i is invariant and A_i is input-unsafe or output-unsafe
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.VarianceSafety.AddVarianceError(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.TypeParameterSymbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.MessageID)">
            <summary>
            Add an ERR_UnexpectedVariance diagnostic to the diagnostic bag.
            </summary>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="unsafeTypeParameter">Type parameter that is not variance safe.</param>
            <param name="context">Context in which type is not variance safe (e.g. method).</param>
            <param name="expectedVariance">Desired variance of type.</param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AbstractTypeMap">
            <summary>
            Abstract base class for mutable and immutable type maps.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteMemberType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Substitute for a type declaration.  May use alpha renaming if the container is substituted.
            </summary>
            <param name="previous"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteNamedType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.
            </summary>
            <param name="previous"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Perform the substitution on the given type.  Each occurrence of the type parameter is
            replaced with its corresponding type argument from the map.
            </summary>
            <param name="previous">The type to be rewritten.</param>
            <returns>The type with type parameters replaced with the type arguments.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteTypes(System.Collections.Generic.IList{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Perform the substitution on every member of the list, returning a new list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteTypesDistinct(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.TypeSymbol})">
            <summary>
            Substitute types, and return the results without duplicates, preserving the original order.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AbstractTypeMap.SubstituteNamedTypes(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MutableTypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverriddenOrHiddenMembersResult">
            <summary>
            Groups the information computed by MakeOverriddenOrHiddenMembers.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Name">
            <summary>
            Gets the name of this label
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsExtern">
            <summary>
            Returns false because label can't be defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsSealed">
            <summary>
            Returns false because label can't be sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsAbstract">
            <summary>
            Returns false because label can't be abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsOverride">
            <summary>
            Returns false because label can't be overridden.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsVirtual">
            <summary>
            Returns false because label can't be virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.IsStatic">
            <summary>
            Returns false because label can't be static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because label can't be used outside the member body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>.
            It should be the <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Roslyn.Compilers.CSharp.LabelSymbol"/>.
            It should be the <see cref="T:Roslyn.Compilers.CSharp.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabelSymbol.Kind">
            <summary>
            Returns value 'Label' of the <see cref="T:Roslyn.Compilers.CSharp.SymbolKind"/>
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder">
            <summary>
            This subclass of MetadataDecoder is specifically for finding
            method symbols corresponding to method MemberRefs.  The parent 
            implementation is unsuitable because it requires a PEMethodSymbol
            for context when decoding method type parameters and no such
            context is available because it is precisely what we are trying
            to find.  Since we know in advance that there will be no context
            and that signatures decoded with this class will only be used
            for comparison (when searching through the methods of a known
            TypeSymbol), we can return indexed type parameters instead.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder">
            <summary>
            Helper class to resolve metadata tokens and signatures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.moduleSymbol">
            <summary>
            ModuleSymbol for the module - source of metadata.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.typeContextOpt">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.methodContextOpt">
            <summary>
            Method context for resolving generic method type arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.GetWinMdAssembliesIndex">
            <summary>
            When we load a winmd file we also need to load a bunch
            of extra assemblies for type projection
            
            This returns the starting index of these assemblies.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
            <param name="referencedAssemblyIndex"></param>
            <param name="emittedName"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a type defined in this module.
            This method will be called only if the type we are
            looking for hasn't been loaded yet. Otherwise, MetadataDecoder
            would have found the type in TypeDefRowIdToTypeMap based on its 
            TypeDef row id. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.SubstituteTypeParameters(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol[],System.Boolean[])">
            <summary>
            Produce constructed type symbol.
            </summary>
            <param name="genericTypeDef">
            Symbol for generic type.
            </param>
            <param name="arguments">
            Generic type arguments, including those for nesting types.
            </param>
            <param name="refersToNoPiaLocalType">
            Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
            </param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssemblies(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is defined in the specified assemblies. The check is performed recursively. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(Roslyn.Compilers.Internal.MetadataTypeName@,System.Boolean,Roslyn.Compilers.CSharp.TypeSymbol,System.String,System.String,System.String,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.AssemblySymbol})">
            <summary>
            Find canonical type for NoPia embedded type.
            </summary>
            <param name="name"></param>
            <param name="isInterface"></param>
            <param name="baseType"></param>
            <param name="interfaceGuid"></param>
            <param name="scope"></param>
            <param name="identifier"></param>
            <param name="referringAssembly"></param>
            <param name="lookupIn"></param>
            <returns>
            Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
            </returns>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.containingType">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
            <summary>
            We know that we'll never have a method context because that's what we're
            trying to find.  Instead, just return an indexed type parameter that will
            make comparison easier.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
            <summary>
            This override changes two things:
                1) Return type arguments instead of type parameters.
                2) Handle non-PE types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.MethodRefMetadataDecoder.FindMethodBySignature(Roslyn.Compilers.CSharp.TypeSymbol,System.UInt32)">
            <summary>
            Search through the members of a given type symbol to find the method that matches a particular
            signature.
            </summary>
            <param name="targetTypeSymbol">Type containing the desired method symbol.</param>
            <param name="targetMemberRefToken">A MemberRef token that can be used to obtain the name and signature of the method</param>
            <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodKind">
            <summary>
            Represents the kind of a method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.AnonymousFunction">
            <summary>
            An anonymous method or lambda expression
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Constructor">
            <summary>
            An instance constructor. The return type is always void.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Conversion">
            <summary>
            A user-defined conversion.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.DelegateInvoke">
            <summary>
            The invoke method of a delegate.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Destructor">
            <summary>
            A destructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.EventAdd">
            <summary>
            The implicitly-defined add method associated with an event.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.EventRemove">
            <summary>
            The implicitly-defined remove method associated with an event.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.ExplicitInterfaceImplementation">
            <summary>
            An explicit interface implementation method. The ImplementedMethods
            property can be used to determine which method is being implemented.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Operator">
            <summary>
            A user-defined operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.Ordinary">
            <summary>
            A normal method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.PropertyGet">
            <summary>
            The implicitly-defined get method associated with a property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.PropertySet">
            <summary>
            The implicitly-defined set method associated with a property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.ReducedExtension">
            <summary>
            An extension method with the "this" parameter removed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MethodKind.StaticConstructor">
            <summary>
            A static constructor. The return type is always void.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SignatureOnlyParameterSymbol">
            <summary>
            Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetBaseProperty(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property is overrides another, returns the base virtual property.
            Otherwise return the original property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetOwnOrInheritedGetMethod(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property has a GetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PropertySymbolExtensions.GetOwnOrInheritedSetMethod(Roslyn.Compilers.CSharp.PropertySymbol)">
            <summary>
            If the property has a SetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertySymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertySymbol.underlyingProperty">
            <summary>
            The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertySymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberSignatureComparer">
            <summary>
            C#4 10.6: The name, the type parameter list and the formal parameter list of a method define
            the signature (3.6) of the method. Specifically, the signature of a method consists of its
            name, the number of type parameters and the number, modifiers, and types of its formal
            parameters. For these purposes, any type parameter of the method that occurs in the type of
            a formal parameter is identified not by its name, but by its ordinal position in the type
            argument list of the method. The return type is not part of a methods signature, nor are
            the names of the type parameters or the formal parameters.
            
            C#4 3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            
            C#4 3.6: We implement the rules for ref/out by mapping both to ref.  The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.ExplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member explicitly implements another,
            according the C# definition.
            The member signatures are compared without regard to name (including the interface part, if any)
            and the return types must match.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpImplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member implicitly implements another,
            according to the C# definition.
            The member names, parameters, and (return) types must match.  Custom modifiers are ignored.
            </summary>
            <remarks>
            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)
            we allow inexact matching of custom modifiers when computing implicit member implementations.  Consider the
            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its
            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.
            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,
            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpCloseImplicitImplementationComparer">
            <summary>
            This instance is used as a fallback when it is determined that one member does not implicitly implement
            another.  It applies a looser check to determine whether the proposed implementation should be reported
            as "close".
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.DuplicateSourceComparer">
            <summary>
            This instance is used to determine if two C# member declarations in source conflict.
            Names, arities, and parameter types are considered.
            Return types, type parameter constraints, custom modifiers, and parameter ref kinds, etc are ignored.
            </summary>
            <remarks>
            This does the same comparison that MethodSignature used to do.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpOverrideComparer">
            <summary>
            This instance is used to check whether one member overrides another, according to the C# definition.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpAccessorOverrideComparer">
            <summary>
            This instance is used to check whether one property or event overrides another, according to the C# definition.
            NOTE: C# ignores accessor member names.
            CAVEAT: considers return types so that getters and setters will be treated the same.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpCustomModifierOverrideComparer">
            <summary>
            Same as CSharpMethodOverrideComparer except that it pays attention to custom modifiers and return type.  
            Normally, the return type isn't considered during overriding, but this comparer is actually used to find
            exact matches (i.e. before tie-breaking takes place amongst close matches).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.RuntimeSignatureComparer">
            <summary>
            This instance is intended to reflect the definition of signature equality used by the runtime (ECMA 335 Section 8.6.1.6).
            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores
            the difference between RefKind.Out and RefKind.Ref.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.RuntimeImplicitImplementationComparer">
            <summary>
            This instance is the same as RuntimeSignatureComparer.
            CONSIDER: just use RuntimeSignatureComparer?
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.CSharpSignatureAndConstraintsAndReturnTypeComparer">
            <summary>
            This instance is used to search for members that have the same name, parameters, (return) type, and constraints (if any)
            according to the C# definition.  Custom modifiers are ignored.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.RetargetedExplicitImplementationComparer">
            <summary>
            This instance is used to search for members that have identical signatures in every regard.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MemberSignatureComparer.LookupHidingComparer">
            <summary>
            This instance is used when trying to lookup in the scope of a type parameter, to see if a
            method found in a class constraint hides a method found in an interface constraint..
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MemberSignatureComparer.AreConstraintTypesSubset(System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol},System.Collections.Generic.HashSet{Roslyn.Compilers.CSharp.TypeSymbol},Roslyn.Compilers.CSharp.TypeParameterSymbol)">
            <summary>
            Returns true if the first set of constraint types
            is a subset of the second set.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SignatureOnlyMethodSymbol">
            <summary>
            A representation of a method symbol that is intended only to be used for comparison purposes
            (esp in MethodSignatureComparer).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceLabelSymbol.switchCaseLabelConstant">
            <summary>
            Switch case labels have a constant expression associated with them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceLabelSymbol.SwitchCaseLabelConstant">
            <summary>
            If the label is a switch case label, returns the associated constant value with
            case expression, otherwise returns null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceEnumConstantSymbol">
            <summary>
            Represents a constant field of an enum.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ExplicitInterfaceHelpers.FindExplicitImplementationCollisions(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Given a member, look for other members contained in the same type with signatures that will
            not be distinguishable by the runtime.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.lazyTypeParameterConstraints">
            <summary>
            A collection of type parameter constraints, populated when
            constraints for the first type parameter is requested.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.otherPartOfPartial">
            <summary>
            If this symbol represents a partial method definition or implementation part, its other part (if any).
            This should be set, if at all, before this symbol appears among the members of its owner.  
            The implementation part is not listed among the "members" of the enclosing type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.constraintClauseBinder">
            <summary>
            A binder to use for binding generic constraints. The field is only non-null while the .ctor
            is executing, and allows constraints to be bound before the method is added to the
            containing type. (Until the method symbol has been added to the container, we cannot
            get a binder for the method without triggering a recursive attempt to bind the method.)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.CopyMethodCustomModifiers(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.TypeSymbol@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol}@,System.Boolean)">
            <remarks>
            Ref params are written using (ReadOnly)Interlocked.Exchange.
            NOTE: Exchange rather than CompareExchange since we're overwriting, not initializing.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.PartialMethodChecks(Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Report differences between the defining and implementing
            parts of a partial method. Diagnostics are reported on the
            implementing part, matching Dev10 behavior.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.HaveSameConstraints(Roslyn.Compilers.CSharp.SourceMemberMethodSymbol,Roslyn.Compilers.CSharp.SourceMemberMethodSymbol)">
            <summary>
            Returns true if the two partial methods have the same constraints.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.OtherPartOfPartial">
            <summary>
            If this is a partial implementation part returns the definition part and vice versa.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.IsPartialDefinition">
            <summary>
            Returns true if this symbol represents a partial method definition (the part that specifies a signature but no body).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.IsPartialImplementation">
            <summary>
            Returns true if this symbol represents a partial method implementation (the part that specifies both signature and body).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.IsPartialWithoutImplementation">
            <summary>
            True if this is a partial method that doesn't have an implementation part.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.SourcePartialDefinition">
            <summary>
            Returns the implementation part of a partial method definition, 
            or null if this is not a partial method or it is the definition part.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceMemberMethodSymbol.SourcePartialImplementation">
            <summary>
            Returns the definition part of a partial method implementation, 
            or null if this is not a partial method or it is the implementation part.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertyAccessorSymbol.LocalAccessibility">
            <summary>
            Return Accessibility declared locally on the accessor, or
            NotApplicable if no accessibility was declared explicitly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolKind">
            <summary>
            Represents the different kinds of symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TempLocalSymbol">
            <summary>
            TempLocalSymbol is special kind of LocalSymbol that can have ref kind.
            
            The semantics of LHS ByRef local is roughly the same as of a ByRef argument
               EmitAssignment will do EmitAddress for RHS and then assign.
                                                
            The semantics of RHS ByRef local is roughly the same as of a ByRef parameter
               EmitExpression   will load the value which local is refering to.
               EmitAddress      will load the actual local.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupOptions">
            <summary>
            Options that can be used to modify the symbol lookup mechanism. 
            </summary>
            <remarks>
            Multiple options can be combined together.  LookupOptions.AreValid checks for valid combinations.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.Default">
            <summary>
            Consider all symbols, using normal accessibility rules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.NamespaceAliasesOnly">
            <summary>
            Consider only namespace aliases and extern aliases.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.NamespacesOrTypesOnly">
            <summary>
            Consider only namespaces and types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustBeInvocableMember">
            <summary>
            Only  consider symbols that are invocable members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustBeInstance">
            <summary>
            Consider only symbols that are instance members. Valid with IncludeExtensionMethods
            since extension methods are invoked on an instance.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustNotBeInstance">
            <summary>
            Do not consider symbols that are instance members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.MustNotBeNamespace">
            <summary>
            Do not consider symbols that are namespaces.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.IgnoreAccessibility">
            <summary>
            Ignore accessibility checking when determining if a symbol is a match.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.AllMethodsOnArityZero">
            <summary>
            Consider methods of any arity when arity zero is specified. Because type parameters can be inferred, it is
            often desired to consider generic methods when no type arguments were present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.LabelsOnly">
            <summary>
            Look only for label symbols.  This must be exclusive of all other options.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.UseBaseReferenceAccessibility">
            <summary>
            Usually, when determining if a member is accessible, both the type of the receiver
            and the type containing the access are used.  If this flag is specified, then only
            the containing type will be used (i.e. as if you've written base.XX).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.IncludeExtensionMethods">
            <summary>
            Include extension methods.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.AttributeTypeOnly">
            <summary>
            Consider only attribute types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.LookupOptions.VerbatimNameAttributeTypeOnly">
            <summary>
            Consider lookup name to be a verbatim identifier.
            If this flag is specified, then only one lookup is performed for attribute name: lookup with the given name,
            and attribute name lookup with "Attribute" suffix is skipped.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupOptionExtensions.AreValid(Roslyn.Compilers.CSharp.LookupOptions)">
            <summary>
            Are these options valid in their current combination?
            </summary>
            <remarks>
            Some checks made here:
            
            - Default is valid.
            - If LabelsOnly is set, it must be the only option.
            - If one of MustBeInstance or MustNotBeInstance are set, the other one must not be set.
            - If any of MustNotBeInstance, MustBeInstance, or MustNotBeNonInvocableMember are set,
              the options are considered valid.
            - Otherwise, only one of NamespaceAliasesOnly, NamespacesOrTypesOnly, or AllMethodsOnArityZero must be set.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AccessCheck">
            <summary>
            Contains the code for determining C# accessibility rules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an optional qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
            if it failed the "through type" check.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.AccessCheck.IsSymbolAccessibleCore(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.TypeSymbol,System.Boolean@,Roslyn.Compilers.CSharp.Compilation,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol
            or an AssemblySymbol. 
            
            Note that NamedTypeSymbol, if available, is the type that is associated with the binder 
            that found the 'symbol', not the inner-most type that contains the access to the
            'symbol'.
            
            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that
            expression. This is needed to properly do protected access checks. Sets
            "failedThroughTypeCheck" to true if this protected check failed.
            
            NOTE(cyrusn): I expect this function to be called a lot.  As such, i do not do any memory
            allocations in the function itself (including not making any iterators).  This does mean
            that certain helper functions that we'd like to call are inlined in this method to
            prevent the overhead of returning collections or enumerators.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InContainerBinder">
            <summary>
            A binder that places the members of a symbol in scope.  If there is a container declaration
            with using directives, those are merged when looking up names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InContainerBinder.#ctor(Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Creates a binder for a container with imports (usings and extern aliases) that can be
            retrieved from <paramref name="declarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InContainerBinder.#ctor(Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol,Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.Imports)">
            <summary>
            Creates a binder with given imports.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.WithClassTypeParametersBinder">
            <summary>
            A binder that places class/interface/struct/delegate type parameters in scope
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InMethodBinder">
            <summary>
            A binder for a method body, which places the method's parameters in scope
            and notes if the method is an iterator method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.WithMethodTypeParametersBinder">
            <summary>
            A binder that places method type parameters in scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EmitResult">
            <summary>
            The result of the Compilation Emit operation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ReflectionEmitResult">
            <summary>
            The result of emitting a compilation to a dynamic module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExecutableCodeBinder">
            <summary>
            This binder owns and lazily creates the map of SyntaxNodes to Binders associated with
            the syntax with which it is created. This binder is not created in reaction to any
            specific syntax node type. It is inserted into the binder chain
            between the binder which it is constructed with and those that it constructs via
            the LocalBinderFactory. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Declaration">
            <summary>
            A Declaration summarizes the declaration structure of a source file. Each entity declaration
            in the program that is a container (specifically namespaces, classes, interfaces, structs,
            and delegate declarations) is represented by a node in this tree.  At the top level, the
            compilation unit is treated as a declaration of the unnamed namespace.
            
            Special treatment is required for namespace declarations, because a single namespace
            declaration can declare more than one namespace.  For example, in the declaration
            
                namespace A.B.C {}
                
            we see that namespaces A and B and C are declared.  This declaration is represented as three
            declarations. All three of these ContainerDeclaration objects contain a reference to the
            syntax tree for the declaration.
            
            A "single" declaration represents a specific namespace or type declaration at a point in
            source code. A "root" declaration is a special single declaration which summarizes the
            contents of an entire file's types and namespaces.  Each source file is represented as a tree
            of single declarations.
            
            A "merged" declaration merges together one or more declarations for the same symbol.  For
            example, the root namespace has multiple single declarations (one in each source file) but
            there is a single merged declaration for them all.  Similarly partial classes may have
            multiple declarations, grouped together under the umbrella of a merged declaration.  In the
            common trivial case, a merged declaration for a single declaration contains only that single
            declaration.  The whole program, consisting of the set of all declarations in all of the
            source files, is represented by a tree of merged declarations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitAddress(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Emits address as in &amp; 
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Emits address of a temp.
            Used in cases where taking address directly is not possible 
            (typically because expression does not have a home)
            
            Introduce a temp which it will return.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitSequenceAddress(Roslyn.Compilers.CSharp.BoundSequence,System.Boolean)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Checks if expression directly or indirectly represents a value with its own home. In
            such cases it is possible to get a reference without loading into a temporary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.HasHome(Roslyn.Compilers.CSharp.BoundFieldAccess)">
            <summary>
            Special HasHome for fields. Fields have homes when they are writeable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitFieldAddress(Roslyn.Compilers.CSharp.BoundFieldAccess)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitReceiverRef(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Emits receiver in a form that allows member accesses ( O or &amp; ). For verifiably
            reference types it is the actual reference. For generic types it is a address of the
            receiver with readonly intent. For the value types it is an address of the receiver.
            
            isAccessConstrained indicates that receiver is a target of a constrained callvirt
            in such case it is unnecessary to box a receier that is typed to a type parameter
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitInstanceFieldAddress(Roslyn.Compilers.CSharp.BoundFieldAccess)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitVectorInitializers(Roslyn.Compilers.CSharp.ArrayTypeSymbol,Roslyn.Compilers.CSharp.BoundArrayInitialization)">
            <summary>
            Emits appropriate initialization sequence for the array on the stack.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.AsConstOrDefault(Roslyn.Compilers.CSharp.BoundExpression,System.Boolean@)">
            <summary>
            Returns a constant value that corresponds to a single initializer.
            If expression is not a constant, a default value is returned.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.ShouldEmitBlockInitializer(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.BoundArrayInitialization)">
            <summary>
            Decides if we can/should emit initializer via a metadata block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Roslyn.Compilers.CSharp.BoundExpression)">
            <summary>
            Used to decide if we need to emit call or callvirt.
            It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
            There are cases where it really can be null, but we do not care.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.MayUseCallForStructMethod(Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Used to decide if we need to emit 'call' or 'callvirt' for structure method.
            It basically checks if the method overrides any other and method's defining type
            is not a 'special' or 'special-by-ref' type. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            When array operation get long or ulong arguments the args should be 
            cast to native int.
            Note that the cast is always checked.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitVectorElementStore(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Emit an element store instruction for a single dimensional array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitConditionalOperator(Roslyn.Compilers.CSharp.BoundConditionalOperator,System.Boolean)">
            <summary>
            Emit code for a conditional (aka ternary) operator.
            </summary>
            <remarks>
            (b ? x : y) becomes
                push b
                if pop then goto TRUE
                push y
                goto DONE
              TRUE:
                push x
              DONE:
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.CodeForJump(Roslyn.Compilers.CSharp.BoundBinaryOperator,System.Boolean,Roslyn.Compilers.CodeGen.ILOpCode@)">
            <summary>
            Produces opcode for a jump that corresponds to given opearation and sense.
            Also produces a reverse opcode - opcode for the same condition with inverted sense.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.EmitStringCompareAndBranch(Roslyn.Compilers.CodeGen.LocalDefinition,Roslyn.Compilers.ConstantValue,System.Object,System.Object[])">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
            <param name="arguments">Additional arguments for the delegate</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.GetLocal(Roslyn.Compilers.CSharp.BoundLocal)">
            <summary>
            Gets already declared and initialized local.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.FreeLocal(Roslyn.Compilers.CSharp.LocalSymbol)">
            <summary>
            Releases a local.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.AllocateTemp(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Allocates a temp without identity.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.FreeTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
            <summary>
            Frees a temp.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.FreeOptTemp(Roslyn.Compilers.CodeGen.LocalDefinition)">
            <summary>
            Frees an optional temp.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.CodeGen.CodeGenerator.indirectReturnState">
            <summary>
            In some cases returns are handled as gotos to return epilogue.
            This is used to track the state of the epilogue.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.CSharp.ScriptEngine">
            <summary>
            Represents a runtime execution context for C# scripts.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CSharp.ScriptEngine.ValidateReferences(Roslyn.Compilers.Common.CommonCompilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Checks that the compilation doesn't have any references whose name start with the reserved prefix.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SymbolDisplay">
            <summary>
            A static class which is used to display symbol content based on specific <see cref="T:Roslyn.Compilers.SymbolDisplayFormat"/> 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToDisplayString(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.SymbolDisplayFormat,System.IFormatProvider)">
            <summary>
            Convert a symbol to a string that can be displayed to the user.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <param name="formatProvider">For formatting values within the symbol - null is passed to
            IFormattable.ToString, which treats it as CultureInfo.CurrentCulture.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToMinimalDisplayString(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.Common.CommonLocation,Roslyn.Compilers.Common.ISemanticModel,Roslyn.Compilers.SymbolDisplayFormat,System.IFormatProvider)">
            <summary>
            Convert a symbol to a string that can be displayed to the user. May be tailored to a
            specific location in the source code.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="location">A location in the source code (context).</param>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <param name="formatProvider">For formatting values within the symbol - null is passed to
            IFormattable.ToString, which treats it as CultureInfo.CurrentCulture.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToDisplayParts(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SymbolDisplay.ToMinimalDisplayParts(Roslyn.Compilers.Common.ISymbol,Roslyn.Compilers.Common.CommonLocation,Roslyn.Compilers.Common.ISemanticModel,Roslyn.Compilers.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. May be tailored
            to a specific location in the source code. Useful for colorizing the display string.
            </summary>
            <param name="symbol">Symbol to be displayed.</param>
            <param name="location">A location in the source code (context).</param>
            <param name="semanticModel">Binding information (for determining names appropriate to
            the context).</param>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.MinimallyQualifiedFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.FieldInitializer">
            <summary>
            Represents a field initializer or a global statement in script code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.FieldInitializer.Field">
            <summary>
            The field being initialized or null if this is a global statement.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.FieldInitializer.Syntax">
            <summary>
            A reference to <see cref="T:Roslyn.Compilers.CSharp.EqualsValueClauseSyntax"/> or <see cref="T:Roslyn.Compilers.CSharp.GlobalStatementSyntax"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterBuilder">
            <summary>
            A context for binding type parameter symbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedParameterSymbol">
            <summary>
            Represents a simple compiler generated parameter of a given type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SynthesizedParameterSymbol.DeriveParameters(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            For each parameter of a source method, construct a corresponding synthesized parameter
            for a destination method.
            </summary>
            <param name="sourceMethod">Has parameters.</param>
            <param name="destinationMethod">Needs parameters.</param>
            <returns>Synthesized parameters to add to destination method.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeKind">
            <summary>
            Represents the different kinds of types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AliasSymbol">
            <summary>
            Symbol representing a using alias appearing in a compilation unit or within a namespace
            declaration. Generally speaking, these symbols do not appear in the set of symbols reachable
            from the unnamed namespace declaration.  In other words, when a using alias is used in a
            program, it acts as a transparent alias, and the symbol to which it is an alias is used in
            the symbol table.  For example, in the source code
            <pre>
            namespace NS
            {
                using o = System.Object;
                partial class C : o {}
                partial class C : object {}
                partial class C : System.Object {}
            }
            </pre>
            all three declarations for class C are equivalent and result in the same symbol table object
            for C. However, these using alias symbols do appear in the results of certain SemanticModel
            APIs. Specifically, for the base clause of the first of C's class declarations, the
            following APIs may produce a result that contains an AliasSymbol:
            <pre>
                SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindExpression(SyntaxNode location, ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindType(SyntaxNode location, ExpressionSyntax type);
                SemanticInfo SemanticModel.BindNamespaceOrType(SyntaxNode location, ExpressionSyntax type);
            </pre>
            Also, the following are affected if container==null (and, for the latter, when arity==null
            or arity==0):
            <pre>
                IList&lt;string&gt; SemanticModel.LookupNames(SyntaxNode location, NamespaceOrTypeSymbol container = null, LookupOptions options = LookupOptions.Default, List&lt;string> result = null);
                IList&lt;Symbol&gt; SemanticModel.LookupSymbols(SyntaxNode location, NamespaceOrTypeSymbol container = null, string name = null, int? arity = null, LookupOptions options = LookupOptions.Default, List&lt;Symbol> results = null);
            </pre>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute.
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasSymbol.ContainingSymbol">
            <summary>
            Using aliases in C# are always contained within a namespace declaration, or at the top
            level within a compilation unit, within the implicit unnamed namespace declaration.  We
            return that as the "containing" symbol, even though the alias isn't a member of the
            namespace as such.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CompilationUnitSyntax.GetReferenceDirectives">
            <summary>
            Returns #r directives specified in the compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExpressionStatementSyntax.AllowsAnyExpression">
            <summary>
            Returns true if the <see cref="P:Roslyn.Compilers.CSharp.ExpressionStatementSyntax.Expression"/> property is allowed by the rules of the
            language to be an arbitrary expression, not just a statement expression.
            </summary>
            <remarks>
            True if, for example, this expression statement represents the last expression statement
            of the interactive top-level code.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode.EnumerateNodes">
            <summary>
            Enumerates all nodes of the tree rooted by this node (including this node).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.FlowAnalysisPass.Rewrite(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.BoundBlock,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            The flow analysis pass.  This pass reports required diagnostics for unreachable
            statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze),
            and inserts a final return statement if the end of a void-returning method is reachable.
            </summary>
            <param name="method">the method to be analyzed</param>
            <param name="block">the method's body</param>
            <param name="diagnostics">the receiver of the reported diagnostics</param>
            <returns>the rewritten block for the method (with a return statement possibly inserted)</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this object. Does not get
            errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method is called, all
            declarations are analyzed for diagnostics. Calling this a second time will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors involving compiling
            method bodies or initializers, in addition to the errors returned by GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the process of obtaining the
            diagnostics.</param>
            <remarks>
            Because this method must semantically all method bodies and initializers to check for diagnostics, it may
            take a significant amount of time. Unlike GetDeclarationDiagnostics, diagnostics for method bodies and
            initializers are not cached, the any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the enclosing binder associated with the node
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.ClassifyConversion(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was converted to a given
            type.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree associated with this
            object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
            kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
            property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a type), use
            Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.ClassifyConversionForCast(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was converted to a given
            type using an explicit cast.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree associated with this
            object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was possible, and if so, what
            kind of conversion it was. If no conversion was possible, a Conversion object with a false "Exists "
            property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a type), use
            Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for the declaration
            assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.  
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Roslyn.Compilers.CSharp.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="typeParameter"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this object is associated with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTreeSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ControlFlowAnalysis">
            <summary>
            This class implements the region control flow analysis operations. Region control flow
            analysis provides information about statements which enter and leave a region. The analysis
            is done lazily. When created, it performs no analysis, but simply caches the arguments.
            Then, the first time one of the analysis results is used it computes that one result and
            caches it. Each result is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.EntryPoints">
            <summary>
            A collection of statements outside the region that jump into the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.ExitPoints">
            <summary>
            A collection of statements inside the region that jump to locations outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Returns true if and only if the endpoint of the last statement in the region is reachable or the region contains no
            statements.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.ReturnStatements">
            <summary>
            A collection of return (or yield break) statements found within the region that return from the enclosing method or lambda.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ControlFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DeclarationTable">
            <summary>
            A declaration table is a device which keeps track of type and namespace declarations from
            parse trees. It is optimized for the case where there is one set of declarations that stays
            constant, and a specific root namespace declaration corresponding to the currently edited
            file which is being added and removed repeatedly. It maintains a cache of information for
            "merging" the root declarations into one big summary declaration; this cache is efficiently
            re-used provided that the pattern of adds and removes is as we expect.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DeclarationTreeBuilder.CreateScriptRootDeclaration(Roslyn.Compilers.CSharp.CompilationUnitSyntax)">
            <summary>
            Creates a root declaration that contains a Script class declaration (possibly in a namespace) and namespace declarations.
            Top-level declarations in script code are nested in Script class.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayTypeSymbol">
            <summary>
            An ArrayTypeSymbol represents an array type, such as int[] or object[,].
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="compilation">The compilation in which the type is constructed.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="declaringAssembly">The assembly "declaring"/using the array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.CSharp.Symbol}.ModifierInfo},Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Create a new ArrayTypeSymbol of rank 1.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="declaringAssembly">The assembly "declaring"/using the array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier},System.Int32,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="array">The core library type "System.Array".</param>
            <param name="ilist">The core library type "IList".</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ArrayTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Int32,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="array">The core library type "System.Array".</param>
            <param name="ilist">The core library type "IList".</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of the array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Emit.Module.assemblySymbolMapper">
            <summary>
            Used to translate assembly symbols to assembly references in scenarios when the physical assemblies 
            being emitted don't correspond to the assembly symbols 1:1. This happens, for example, in interactive sessions where
            multiple code submissions might be compiled into a single dynamic assembly or into multiple assemblies 
            depending on properties of the code being emitted. If null we map assembly symbol exactly to its assembly name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedTypes(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated types.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedMethods(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated methods.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Emit.Module.GetCompilerGeneratedFields(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns null if there are no compiler generated fields.
            </summary>
            <param name="container"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.Module.CompilerGeneratedDefinitions">
            <summary>
            Captures the set of compiler generated definitions that should be added to a type
            during emit process.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Emit.Assembly.metadataName">
            <summary>
            The behavior of the C# command-line compiler is as follows:
              1) If the /out switch is specified, then the explicit assembly name is used.
              2) Otherwise,
                 a) if the assembly is executable, then the assembly name is derived from
                    the name of the file containing the entrypoint;
                 b) otherwise, the assembly name is derived from the name of the first input
                    file.
            
            Since we don't know which method is the entrypoint until well after the
            SourceAssemblySymbol is created, in case 2a, its name will not reflect the
            name of the file containing the entrypoint.  We leave it to our caller to
            provide that name explicitly.
            </summary>
            <remarks>
            In cases 1 and 2b, we expect (metadataName == sourceAssembly.MetadataName).
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CustomModifier">
            <summary>
            Represents a custom modifier (modopt/modreq).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without 
            being aware of the meaning of the modification, modopt vs. modreq. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericMethodInstanceReference">
            <summary>
            Represents a reference to a generic method instantiation, closed over type parameters,
            e.g. MyNamespace.Class.Method{T}()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is nested in a non-generic type.
            e.g. A.B{int}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation.
            Subclasses represent nested and namespace types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.GenericNamespaceTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is not nested.
            e.g. MyNamespace.A{int}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.PointerTypeSymbol.#ctor(Roslyn.Compilers.CSharp.TypeSymbol,System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.CSharp.Symbol}.ModifierInfo})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedFieldReference">
            <summary>
            Represents a reference to a field of a generic type instantiation.
            e.g.
            A{int}.Field
            A{int}.B{string}.C.Field
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedGenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
            e.g. 
            A{int}.B{string}
            A.B{int}.C.D{string}
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Emit.SpecializedNestedTypeReference">
            <summary>
            Represents a reference to a type nested in an instantiation of a generic type.
            e.g. 
            A{int}.B
            A.B{int}.C.D
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Diagnostic">
            <summary>
            A diagnostic, along with the location where it occurred.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Diagnostic.Location">
            <summary>
            The primary location of the diagnostic.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Diagnostic.AdditionalLocations">
            <summary>
            Get additional locations related to the diagnostic. Typically these are the locations of
            symbols that are mentioned in the message.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.SealDiagnostics(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
            implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
            </summary>
            <param name="diagBag"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.GetDiagnostics(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Get all the diagnostics in the diagnostic bag, as an enumerable of Diagnostic. DiagnosticBag
            implements IEnumerable&lt;IDiagnostic&gt; instead of IEnumerable&lt;Diagnostic&gt;.
            </summary>
            <param name="diagBag"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.DiagnosticBagExtensions.Add(Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.ErrorCode,Roslyn.Compilers.CSharp.Location,System.Object[])">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.MessageID,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.ErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.GetMessage(Roslyn.Compilers.CSharp.XmlParseErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ErrorFacts.PreventsSuccessfulDelegateConversion(Roslyn.Compilers.CSharp.ErrorCode)">
            <summary>
            When converting an anonymous function to a delegate type, there are some diagnostics
            that will occur regardless of the delegate type - particularly those that do not
            depend on the substituted types (e.g. name uniqueness).  Even though we need to
            produce a diagnostic in such cases, we do not need to abandon overload resolution -
            we can choose the overload that is best without regard to such diagnostics.
            </summary>
            <returns>True if seeing the ErrorCode should prevent a delegate conversion
            from completing successfully.</returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MetadataLocation">
            <summary>
            A program location in metadata.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoLocation">
            <summary>
            A class that represents no location at all. Useful for errors in command line options, for example.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CharacterInfo">
            <summary>
            Defines a set of methods to determine how Unicode characters are treated by the C# compiler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsHexDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a hexadecimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the character is a hexadecimal digit 0-9, A-F, a-f.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsDecDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a decimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the Unicode character is a decimal digit.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.HexValue(System.Char)">
            <summary>
            Returns the value of a hexadecimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.DecValue(System.Char)">
            <summary>
            Returns the value of a decimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsWhitespace(System.Char)">
            <summary>
            Returns true if the Unicode character represents a whitespace.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsNewLine(System.Char)">
            <summary>
            Returns true if the Unicode character is a newline character.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsIdentifierStartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be the starting character of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.ContainsDroppedIdentifierCharacters(System.String)">
            <summary>
            Spec section 2.4.2 says that identifiers are compared without regard
            to leading "@" characters or unicode formatting characters.  As in dev10,
            this is actually accomplished by dropping such characters during parsing.
            Unfortunately, metadata names can still contain these characters and will
            not be referenceable from source if they do (lookup will fail since the
            characters will have been dropped from the search string).
            See DevDiv #14432 for more.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsXmlNameStartChar(System.Char)">
            <summary>
            Determines whether this Unicode character can start a XMLName.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.CharacterInfo.IsXmlNameChar(System.Char)">
            <summary>
            Determines if this Unicode character can be part of an XML Name.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.DirectiveParser.ParseErrorOrWarningDirective(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,System.Boolean)">
            <summary>
            An error/warning directive tells the compiler to indicate a syntactic error/warning
            at the current location.
            
            Format: #error Error message string
            Resulting message: from the first non-whitespace character after the directive
            keyword until the end of the directive (aka EOD) at the line break or EOF.
            Resulting span: [first non-whitespace char, EOD)
            
            Examples (pipes indicate span):
            #error |foo|
            #error  |foo|
            #error |foo |
            #error |foo baz|
            #error |//foo|
            #error |/*foo*/|
            #error |/*foo|
            </summary>
            <param name="hash">The '#' token.</param>
            <param name="keyword">The 'error' or 'warning' token.</param>
            <param name="isActive">True if the error/warning should be recorded.</param>
            <returns>An ErrorDirective or WarningDirective node.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanExternAliasDirective">
            <summary>
            Returns true if the lookahead tokens compose extern alias directive.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.SkipBadListTokensWithExpectedKindHelper(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxListBuilder,System.Func{Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser,System.Boolean},System.Func{Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser,System.Boolean},Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode@)">
            <remarks>
            WARNING: it is possible that "list" is really the underlying builder of a SeparateSyntaxListBuilder,
            so it is important that we not add anything to the list.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.IsTrueIdentifier">
            <summary>
            True if current identifier token is not really some contextual keyword
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(System.Boolean)">
            <summary>
            Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.
            </summary>
            <remarks>
            Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.IsPossibleTypedIdentifierStart(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,Roslyn.Compilers.CSharp.InternalSyntax.SyntaxToken,System.Boolean)">
            <returns>
            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),
            false if it definitely can't be,
            null if we need to scan further to find out.
            </returns>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NotType">
            <summary>
            Definitely not a type name.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.MustBeType">
            <summary>
            Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrExpression">
            <summary>
            Might be a generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NonGenericTypeOrExpression">
            <summary>
            Might be a non-generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.AliasQualifiedName">
            <summary>
            A type name with alias prefix (Alias::Name)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.NullableType">
            <summary>
            Nullable type (ending with ?).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.InternalSyntax.LanguageParser.ScanTypeFlags.PointerOrMultiplication">
            <summary>
            Might be a pointer type or a multiplication.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.ScanEndOfLine">
            <summary>
            Scans a new-line sequence (either a single new-line character or a CR-LF combo).
            </summary>
            <returns>A trivia node with the new-line text</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.ScanWhitespace">
            <summary>
            Scans all of the whitespace (not new-lines) into a trivia node until it runs out.
            </summary>
            <returns>A trivia node with the whitespace text</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlToken">
            <summary>
            Lexer entry point for LexMode.XmlDocComment
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlElementTagToken">
            <summary>
            Lexer entry point for LexMode.XmlElementTag
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlAttributeTextToken">
            <summary>
            Lexer entry point for LexMode.XmlAttributeText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlCDataSectionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCDataSectionText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlCommentTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCommentText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlProcessingInstructionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlProcessingInstructionText
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlDocCommentLeadingTrivia(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.Lexer.LexXmlWhitespaceAndNewLineTrivia(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.CompileSynthesizedMethodMetadata(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.Emit.Module,System.Threading.CancellationToken)">
            <summary>
            Traverse the symbol table and call Module.AddCompilerGeneratedDefinition for each
            synthesized explicit implementation stub that has been generated (e.g. when the real
            implementation doesn't have the appropriate custom modifiers).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindRegularCSharpFieldInitializers(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.FieldInitializer}},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundInitializer},Roslyn.Compilers.DiagnosticBag,System.Boolean,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Imports}@)">
            <summary>
            In regular C#, all field initializers are assignments to fields and the assigned expressions
            may not reference instance members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindScriptFieldInitializers(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.FieldInitializer}},Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CSharp.BoundInitializer},Roslyn.Compilers.DiagnosticBag,System.Boolean,Roslyn.Utilities.ConsList{Roslyn.Compilers.CSharp.Imports}@)">
            <summary>
            In script C#, some field initializers are assignments to fields and others are global
            statements.  There are no restrictions on accessing instance members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Compiler.BindConstructorInitializer(Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.DiagnosticBag,Roslyn.Compilers.CSharp.Compilation)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol.
            </summary>
            <param name="constructor">Constructor method.</param>
            <param name="diagnostics">Accumulates errors (e.g. access "this" in constructor initializer).</param>
            <param name="compilation">Used to retrieve binder.</param>
            <returns>A bound expression for the constructor initializer call.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.ClassifyConversion(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.ClassifyConversionForCast(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.ClassifyImplicitConversion(Roslyn.Compilers.CSharp.BoundExpression,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any built-in or user-defined implicit conversion.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.ResolveDelegateMethodGroup(Roslyn.Compilers.CSharp.Binder,Roslyn.Compilers.CSharp.BoundMethodGroup,Roslyn.Compilers.CSharp.MethodSymbol)">
            <summary>
            Resolve method group based on the optional delegate invoke method.
            If the invoke method is null, ignore arguments in resolution.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Conversions.GetDelegateInvokeMethodIfAvailable(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Return the Invoke method symbol if the type is a delegate
            type and the Invoke method is available, otherwise null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.NamedTypeSymbol,Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within named type 'within'.  If 'symbol' is accessed off
            of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
            properly do protected access checks.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SemanticFacts.IsSymbolAccessible(Roslyn.Compilers.CSharp.Symbol,Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SynthesizedEntryPointSymbol">
            <summary>
            Represents an interactive code entry point that is inserted into the compilation if there is not an existing one. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourcePropertySymbol.sourceName">
            <summary>
            Set in constructor, might be changed while decoding <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Roslyn.Compilers.CSharp.Accessibility,Roslyn.Compilers.CSharp.Accessibility)">
            <summary>
            Return true if the accessor accessibility is more restrictive
            than the property accessibility, otherwise false.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.CopyPropertyCustomModifiers(Roslyn.Compilers.CSharp.PropertySymbol,Roslyn.Compilers.CSharp.TypeSymbol@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.CustomModifier}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CSharp.ParameterSymbol}@,System.Boolean)">
            <remarks>
            TODO: if this is eventually performed lazily (i.e. outside the constructor),
            as in SourceMemberMethodSymbol, then the assignments should be replaced with
            CompareExchanges.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourcePropertySymbol.MakeSynthesizedSealedAccessor">
            <remarks>
            Only non-null for sealed properties without both accessors.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name that will be
            emitted (based on IndexerNameAttribute, or the default "Item").
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.IsIndexer">
            <remarks>
            Even though it is declared with an IndexerDeclarationSyntax, an explicit
            interface implementation is not an indexer because it will not cause the
            containing type to be emitted with a DefaultMemberAttribute (and even if
            there is another indexer, the name of the explicit implementation won't
            match).  This is important for roundtripping.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.SynthesizedSealedAccessorOpt">
            <summary>
            If this property is sealed, then we have to emit both accessors - regardless of whether
            they are present in the source - so that they can be marked final. (i.e. sealed).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the Obsolete attribute. 
            This property returns Unknown if the Obsolete Attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourcePropertySymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IndexedTypeParameterSymbol">
            <summary>
            Indexed type parameters are used in place of type parameters for method signatures.  There is
            a unique mapping from index to a single IndexedTypeParameterSymbol.  
            
            They don't have a containing symbol or locations.
            
            They do not have constraints, variance, or attributes. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.IndexedTypeParameterSymbol.Take(System.Int32)">
            <summary>
            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
            for the same position.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxList`1">
            <summary>
             Represents a read-only list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.ToString">
            <summary>
            Returns the string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes in this list, not including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.ToFullString">
            <summary>
            Returns the full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes in this list including 
            the first node's leading trivia and the last node's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.Add(`0[])">
            <summary>
            Add one or more nodes to the end of the list.
            </summary>
            <returns>A new list with the nodes added.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.Insert(System.Int32,`0[])">
            <summary>
            Insert one or more nodes in the list at the specified index.
            </summary>
            <returns>A new list with the nodes inserted.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.First">
            <summary>
            The first node in the list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.FirstOrDefault">
            <summary>
            The first node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.Last">
            <summary>
            The last node in the list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.LastOrDefault">
            <summary>
            The last node in the list or default if the list is empty.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.Any">
            <summary>
            True if the list has at least one node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.GetEnumerator">
            <summary>
            Get's the enumerator for this list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList`1.IndexOf(`0)">
            <summary>
            The index of the node in this list, or -1 if the node is not in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxList`1.Count">
            <summary>
            The number of nodes in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxList`1.Item(System.Int32)">
            <summary>
            Gets the node at the specified index.
            </summary>
            <param name="index">The zero-based index of the node to get or set.</param>
            <returns>The node at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">"&gt;<paramref name="index"/>is out of bounds.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxList.GetRedElement(Roslyn.Compilers.CSharp.SyntaxNode@,System.Int32)">
            <summary>
            This works the same as GetRedOnly, but intended to be used in lists
            The only difference is that the public parent of the node is not the list, 
            but the list's parent. (element's grand parent).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeExtensions.CanHaveAssociatedLocalBinder(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            This method is used to keep the code that generates binders in sync
            with the code that searches for binders.  We don't want the searcher
            to skip over any nodes that could have associated binders, especially
            if changes are made later.
            
            "Local binder" is a vague term that refers to binders that represent
            scopes for names (e.g. BlockBinders) rather than binders that tweak
            default behaviors (e.g. FieldInitializerBinders).  Local binders are
            created by LocalBinderFactory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Given an initializer expression infer the name of anonymous property.
            Returns None if unsuccessfull
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxRewriter">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxVisitor`1"/> which descends an entire <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> graph and
            may replace or remove visited SyntaxNodes in depth-first order.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTokenList">
            <summary>
             Represents a read-only list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>.
            </summary>
            <summary>
             Represents a read-only list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.ToString">
            <summary>
            Returns the string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The string representation of the tokens in this list, not including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.ToFullString">
            <summary>
            Returns the full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the tokens in this list including 
            the first token's leading trivia and the last token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Add(Roslyn.Compilers.CSharp.SyntaxToken[])">
            <summary>
            Add one or more tokens to the end of the list.
            </summary>
            <returns>A new list with the tokens added.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Insert(System.Int32,Roslyn.Compilers.CSharp.SyntaxToken[])">
            <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
            <returns>A new list with the tokens inserted.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.First">
            <summary>
            Returns the first token in the list.
            </summary>
            <returns>The first token in the list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.FirstOrDefault">
            <summary>
            Returns the first token in the list or a default token if the list is empty.
            </summary>
            <returns>default(<see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>) if source is empty; otherwise, the first token in the
            list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Last">
            <summary>
            Returns the last token in the list.
            </summary>
            <returns> The last token in the list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.LastOrDefault">
            <summary>
            Returns the last token in the list of a default token if the list is empty.
            </summary>
            <returns>default(<see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>) if list is empty; otherwise, the last token in the
            list.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Any">
            <summary>
            Tests whether the list is non-empty.
            </summary>
            <returns>True if the list contains any tokens.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Tests whether a list contains tokens of a particular kind.
            </summary>
            <param name="kind">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/> to test for.</param>
            <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxToken[],System.Int32,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/> to an <see cref="T:System.Array"/>.
            </summary>
            <param name="offset">The starting index in the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/></param>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied
            from <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>. The Array must have zero-based indexing.</param>
            <param name="arrayOffset">The zero-based index in <paramref name="array"/>at which copying begins.</param>
            <param name="count">The number of items to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetGreenNodeAt(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Int32)">
            <summary>
            get the green node at the given slot
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Reverse">
            <summary>
            return reversed enumerable
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetEnumerator">
            <summary>
            Returns an enumerator for the tokens in the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Equality(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for equality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the two <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>s are equal.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>
            Compares <paramref name="left"/> and <paramref name="right"/> for inequality.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Equals(System.Object)">
            <summary>
            Compares this <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/> with the <paramref name="obj"/> for equality.
            </summary>
            <returns>True if the two objects are equal.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.CSharp.SyntaxTokenList">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Count">
            <summary>
            Returns the number of tokens in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Item(System.Int32)">
            <summary>
            Gets the token at the specified index.
            
            don't use this in a loop. use enumerator instead
            </summary>
            <param name="index">The zero-based index of the token to get or set.</param>
            <returns>The token at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">"&gt;<paramref name="index"/>is out of bounds.</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator">
            <summary>
            A structure for enumerating the a <see cref="T:Roslyn.Compilers.CSharp.SyntaxTokenList"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next token in the collection.
            </summary>
            <returns>true if the enumerator was successfully advanced to the next element; false if the enumerator
            has passed the end of the collection.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTokenList.Enumerator.Current">
            <summary>
            Gets the current element in the collection.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTokenList.Reversed">
            <summary>
            reversed enumerable
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTriviaList">
            <summary>
            A List of SyntaxTrivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.IndexOf(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Returns the index of the given SyntaxTrivia.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.ToString">
            <summary>
            Returns the string representation of the trivia in this list, not including 
            the first trivia's leading sub-trivia or the last trivia's trailing sub-trivia
            if they are structured.
            </summary>
            <returns>
            The string representation of the trivia in this list, not including 
            the first trivia's leading sub-trivia or the last trivia's trailing sub-trivia
            if they are structured.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.ToFullString">
            <summary>
            Returns the full string representation of the trivia in this list including 
            the first trivia's leading sub-trivia and the last trivia's trailing sub-trivia
            even if they are structured.
            </summary>
            <returns>
            The full string representation of the trivia in this list including 
            the first trivia's leading sub-trivia and the last trivia's trailing sub-trivia
            even if they are structured.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.First">
            <summary>
            Returns the first SyntaxTrivia in the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.FirstOrDefault">
            <summary>
            Returns the first SyntaxTrivia in the list or the default value of SyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Last">
            <summary>
            Returns the last SyntaxTrivia in the list. May throw ArgumentOutOfRange exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.LastOrDefault">
            <summary>
            Returns the last SyntaxTrivia in the list or the default value of SyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Does this list contain any item of the given kind.
            </summary>
            <param name="kind"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Reverse">
            <summary>
            return reversed enumerable
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.GetEnumerator">
            <summary>
            Get an enumerator for this list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxTrivia[],System.Int32,System.Int32)">
            <summary>
            Copy count number of items starting at offset from this list into array starting at arrayOffset.
            </summary>
            <param name="offset"></param>
            <param name="array"></param>
            <param name="arrayOffset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.GetGreenNodeAt(System.Int32)">
            <summary>
            get the green node at the specific slot
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.GetGreenNodeAt(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode,System.Int32)">
            <summary>
            get the green node at the specific slot
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Equals(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Compares equality between this list and other list.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Equality(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Are two SyntaxTriviaLists, left and right equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Are two SyntaxTriviaLists, left and right not equal.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxTrivia)~Roslyn.Compilers.CSharp.SyntaxTriviaList">
            <summary>
            Implicitly converts SyntaxTrivia to SyntaxTriviaList.
            </summary>
            <param name="trivia"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Implicit(Roslyn.Compilers.CSharp.SyntaxTriviaList)~Roslyn.Compilers.Common.CommonSyntaxTriviaList">
            <summary>
            Implicitly converts SyntaxTriviaList to CommonSyntaxTriviaList
            </summary>
            <param name="triviaList"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxTriviaList)~Roslyn.Compilers.CSharp.SyntaxTriviaList">
            <summary>
            Explicitly converts CommonSyntaxTriviaList to SyntaxTriviaList
            </summary>
            <param name="commonTriviaList"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Equals(System.Object)">
            <summary>
            Is this list equal to the passed in object.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.op_Addition(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Adds two SyntaxTriviaLists, list1 and list2 into a new SyntaxTriviaList and returns it.
            </summary>
            <param name="list1"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxTriviaList.Empty">
            <summary>
            Default instance of SyntaxTriviaList.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Count">
            <summary>
            Count of items in the list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Item(System.Int32)">
            <summary>
            Returns the SyntaxTrivia at this index.
            
            don't use this in a loop. use enumerator instead
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.ContainsDiagnostics">
            <summary>
            Does any SyntaxTrivia in this list has diagnostics.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator">
            <remarks>
            We could implement the enumerator using the indexer of the SyntaxTriviaList, but then
            every node's offset would be computed separately.  Since we know that we will be accessing
            the nodes in order, we can maintain a running offset value ourselves and avoid this
            overhead.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator.MoveNext">
            <summary>
            Move to the next item in the list.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTriviaList.Enumerator.Current">
            <summary>
            The SyntaxTrivia item at the current location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTriviaList.Reversed">
            <summary>
            reversed enumerable
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConcurrentHashSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupPosition">
            <summary>
            This class contains a variety of helper methods for determining whether a
            position is within the scope (and not just the span) of a node.  In general,
            general, the scope extends from the first token up to, but not including,
            the last token.  For example, the open brace of a block is within the scope
            of the block, but the close brace is not.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInBlock(System.Int32,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>
            A position is considered to be inside a block if it is on or after
            the open brace and strictly before the close brace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInStatementScope(System.Int32,Roslyn.Compilers.CSharp.StatementSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupPosition.IsInCatchClauseScope(System.Int32,Roslyn.Compilers.CSharp.CatchClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SequenceExtensions.AtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32,System.Func{``0,System.Boolean})">
            <summary>
             Takes a sequence and a predicate, and counts hits and misses. If the sequence
             has hitThreshold hits, returns true, otherwise, returns false. Gives up
             if there are missThreshold misses.
             </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.CanUnify(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.CanUnifyHelper(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MutableTypeMap@)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
            <param name="t1">LHS</param>
            <param name="t2">RHS</param>
            <param name="substitution">
            Substitutions performed so far (or null for none).
            Keys are type parameters, values are types (possibly type parameters).
            Will be updated with new subsitutions by the callee.
            Should be ignored when false is returned.
            </param>
            <returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
            <remarks>
            Derived from Dev10's BSYMMGR::UnifyTypes.
            Two types will not unify if they have different custom modifiers.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.TypeUnification.Contains(Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.TypeParameterSymbol)">
            <summary>
            Return true if the given type contains the specified type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DiagnosticsPass">
            <summary>
            This pass detects and reports diagnostics that do not affect lambda convertability.
            These are mainly warnings or early detection of diagnostics that would otherwise be noticed
            later (such as restrictions on the forms of supported expression lambdas).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SubstitutedNestedTypeSymbol">
            <summary>
            A named type symbol that results from substituting a new owner for a type declaration.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SubstitutedNamedTypeSymbol">
            <summary>
            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they
            have type parameters substituted.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructedNamedTypeSymbol">
            <summary>
            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MergedNamespaceSymbol">
            <summary>
            A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
            namespaces. Any sub-namespaces with the same names are also merged if they have two or more
            instances.
            
            Merged namespaces are used to merged the symbols from multiple metadata modules and the
            source "module" into a single symbol tree that represents all the available symbols. The
            compiler resolves names against this merged set of symbols.
            
            Typically there will not be very many merged namespaces in a Compilation: only the root
            namespaces and namespaces that are used in multiple referenced modules. (Microsoft, System,
            System.Xml, System.Diagnostics, System.Threading, ...)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.Create(Roslyn.Compilers.CSharp.NamespaceExtent,Roslyn.Compilers.CSharp.NamespaceSymbol,System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.NamespaceSymbol},System.String)">
            <summary>
            Create a possibly merged namespace symbol. If only a single namespace is passed it, it
            is just returned directly. If two or more namespaces are passed in, then a new merged
            namespace is created with the given extent and container.
            </summary>
            <param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
            <param name="containingNamespace">The containing namespace to used, IF a merged
            namespace is created.</param>
            <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it
            is returned. The merged namespace symbol may hold onto the array.</param>
            <param name="nameOpt">An optional name to give the resulting namespace.</param>
            <returns>A namespace symbol representing the merged namespace.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
            <summary>
            Method that is called from the CachingLookup to lookup the children of a given name.
            Looks in all the constituent namespaces.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MergedNamespaceSymbol.SlowGetChildNames">
            <summary>
            Method that is called from the CachingLookup to get all child names. Looks in all
            constituent namespaces.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol">
            <summary>
            Represents an assembly imported from a PE.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol">
            <summary>
            Represents source or metadata assembly.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.cachedSpecialTypes">
            <summary>
            How many Cor types have we cached so far.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.lazySpecialTypeMembers">
            <summary>
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Roslyn.Compilers.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.MakeFinalIVTDetermination(Roslyn.Compilers.CSharp.AssemblySymbol)">
            <summary>
            Determine whether this assembly has been granted access to <paramref name="potentialGiverOfAccess"></paramref>.
            Assumes that the public key has been determined. The result will be cached.
            </summary>
            <param name="potentialGiverOfAccess"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.assembly">
            <summary>
            An Assembly object providing metadata for the assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.documentationProvider">
            <summary>
            A DocumentationProvider that provides XML documentation comments for this assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.modules">
            <summary>
            The list of contained PEModuleSymbol objects.
            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
            can return it from Modules property as is.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.lazyCustomAttributes">
            <summary>
            Assembly's custom attributes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEAssemblySymbol.lazyContainsExtensionMethods">
            <summary>
            Lazily initialized by MightContainExtensionMethods property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEFieldSymbol">
            <summary>
            The class to represent all fields imported from a PE/module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol">
            <summary>
            The base class to represent a namespace imported from a PE/module. Namespaces that differ
            only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.lazyNamespaces">
            <summary>
            A map of namespaces immediately contained within this namespace 
            mapped by their name (case-sensitively).
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.lazyTypes">
            <summary>
            A map of types immediately contained within this namespace 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Initializes namespaces and types maps with information about 
            namespaces and types immediately contained within this namespace.
            </summary>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups must be sorted by
            their key in case-sensitive manner. Empty string must be used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            must be in several first IGroupings.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}}})">
            <summary>
            Create symbols for nested namespaces and initialize namespaces map.
            </summary>
            <param name="childNamespaces"></param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Create symbols for nested types and initialize types map.
            </summary>
            <param name="typeGroups"></param>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
            <summary>
            Returns PEModuleSymbol containing the namespace.
            </summary>
            <returns>PEModuleSymbol containing the namespace.</returns>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEGlobalNamespaceSymbol.moduleSymbol">
            <summary>
            The module containing the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEMethodSymbol">
            <summary>
            The class to represent all methods imported from a PE/module.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol,Roslyn.Compilers.CSharp.MethodKind)">
            <summary>
            Associate the method with a particular property. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEMethodSymbol.SetAssociatedEvent(Roslyn.Compilers.CSharp.Metadata.PE.PEEventSymbol,Roslyn.Compilers.CSharp.MethodKind)">
            <summary>
            Associate the method with a particular event. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol">
            <summary>
            Represents a net-module imported from a PE. Can be a primary module of an assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.assemblySymbol">
            <summary>
            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.module">
            <summary>
            A Module object providing metadata.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.globalNamespace">
            <summary>
            Global namespace.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.lazySystemTypeSymbol">
            <summary>
            Cache the symbol for well-known type System.Type because we use it frequently
            (for attributes).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.TypeDefRowIdToTypeMap">
            <summary>
            This is a map from TypeDef row id to the target TypeSymbol. 
            It is used by MetadataDecoder to speed-up type reference resolution
            for metadata coming from this module. The map is lazily populated
            as we load types from the module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.TypeRefRowIdToTypeMap">
            <summary>
            This is a map from TypeRef row id to the target TypeSymbol. 
            It is used by MetadataDecoder to speed-up type reference resolution
            for metadata coming from this module. The map is lazily populated
            by MetadataDecoder as we resolve TypeRefs from the module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.lazyCustomAttributes">
            <summary>
            Module's custom attributes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol.lazyAssemblyAttributes">
            <summary>
            Module's assembly attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol">
            <summary>
            The class to represent all types imported from a PE/module.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyNestedTypes">
            <summary>
            A map of types immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyMemberNames">
            <summary>
            A set of all the names of the members in this type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyMembers">
            <summary>
            A map of members immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyKind">
            <summary>
            Lazily initialized by TypeKind property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENamedTypeSymbol.lazyContainsExtensionMethods">
            <summary>
            Lazily initialized by MightContainExtensionMethods property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol">
            <summary>
            The class to represent all, but Global, namespaces imported from a PE/module.
            Namespaces that differ only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.containingNamespaceSymbol">
            <summary>
            The parent namespace. There is always one, Global namespace contains all
            top level namespaces. 
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.name">
            <summary>
            The name of the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.typesByNS">
            <summary>
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            
            This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
            as soon as symbols for children are created.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Roslyn.Compilers.CSharp.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}})">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Name of the namespace, must be not empty.
            </param>
            <param name="containingNamespace">
            Containing namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            </param>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEParameterSymbol">
            <summary>
            The class to represent all method parameters imported from a PE/module.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Metadata.PE.PEParameterSymbol.#ctor(Roslyn.Compilers.CSharp.Metadata.PE.PEModuleSymbol,Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol,System.Int32,System.UInt32,Roslyn.Compilers.MetadataReader.MetadataDecoder{Roslyn.Compilers.CSharp.TypeSymbol,Roslyn.Compilers.CSharp.MethodSymbol,Roslyn.Compilers.CSharp.AssemblySymbol,Roslyn.Compilers.CSharp.Symbol}.ParamInfo)">
            <summary>
            Construct a parameter symbol for a property loaded from metadata.
            </summary>
            <param name="moduleSymbol"></param>
            <param name="containingSymbol"></param>
            <param name="ordinal"></param>
            <param name="paramRid">The property parameter doesn't have a name in metadata,
            so this is the RowID of a corresponding accessor parameter, if there is one,
            or of the ParamInfo passed in, otherwise).</param>
            <param name="parameter"></param>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol">
            <summary>
            The class to represent all properties imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name we imported.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol.IsIndexer">
            <remarks>
            This property can return true for bogus indexers.
            Rationale: If a type in metadata has a single, bogus indexer
            and a source method tries to invoke it, then Dev10 reports a bogus
            indexer rather than lack of an indexer.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Metadata.PE.PEPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this property, P, explicitly implements an interface property, IP, 
            if any of the following is true:
            
            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set
            2) P.get explicitly implements IP.get and there is no IP.set
            3) P.set explicitly implements IP.set and there is no IP.get
            
            Extra or missing accessors will not result in errors, P will simply not report that
            it explicitly implements IP.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Metadata.PE.PETypeParameterSymbol">
            <summary>
            The class to represent all generic type parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol">
            <summary>
            A <see cref="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol"/> is a special kind of <see cref="T:Roslyn.Compilers.CSharp.ErrorTypeSymbol"/> that represents
            a type symbol that was attempted to be read from metadata, but couldn't be
            found, because:
              a) The metadata file it lives in wasn't referenced
              b) The metadata file was referenced, but didn't contain the type
              c) The metadata file was referenced, contained the correct outer type, but
                 didn't contains a nested type in that outer type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.Arity">
            <summary>
            Get the arity of the missing type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel">
            <summary>
            Represents not nested missing type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel.lazyTypeId">
            <summary>
            CorLibTypes.TypeId
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
            <summary>
            This is the FULL namespace name (e.g., "System.Collections.Generic")
            of the type that couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MissingMetadataTypeSymbol.Nested">
            <summary>
            Represents nested missing type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaAmbiguousCanonicalTypeSymbol">
            <summary>
            A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type was ambiguous.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaIllegalGenericInstantiationSymbol">
            <summary>
            A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents a
            generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NoPiaMissingCanonicalTypeSymbol">
            <summary>
            A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type couldn't be found.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol">
            <summary>
            Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
            symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
            
            For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
            In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
            C1 by AssemblyManager.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying assembly are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.underlyingAssembly">
            <summary>
            The underlying AssemblySymbol, it leaks symbols that should be retargeted.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.modules">
            <summary>
            The list of contained ModuleSymbol objects. First item in the list
            is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
            from underlyingAssembly.Modules list, the rest are PEModuleSymbols for 
            added modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by AssemblyManager and must not be modified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.NoPiaUnificationMap">
            <summary>
            A map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.#ctor(Roslyn.Compilers.CSharp.SourceAssemblySymbol,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="underlyingAssembly">
            The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
            </param>
            <param name="isLinked">
            Assembly is /l-ed by compilation that is using it as a reference.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Lookup declaration for FX type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
            <summary>
            The underlying AssemblySymbol.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol">
            <summary>
            Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol.underlyingField">
            <summary>
            The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingFieldSymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol">
            <summary>
            Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.underlyingMethod">
            <summary>
            The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodSymbol.lazyReturnTypeCustomAttributes">
            <summary>
            Retargeted return type custom attributes
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol">
            <summary>
            Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamedTypeSymbol.underlyingType">
            <summary>
            The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol">
            <summary>
            Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingNamespaceSymbol.underlyingNamespace">
            <summary>
            The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingParameterSymbol">
            <summary>
            Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
            another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingParameterSymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingMethodParameterSymbol.retargetingMethod">
            <summary>
            Owning RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingPropertyParameterSymbol.retargetingProperty">
            <summary>
            Owning RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol">
            <summary>
            Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol.retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol.underlyingTypeParameter">
            <summary>
            The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Retargeting.RetargetingTypeParameterSymbol.lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BaseTypeAnalysis.IsManagedType(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            IsManagedType is simple for most named types:
                enums are not managed;
                non-enum, non-struct named types are managed;
                generic types and their nested types are managed;
                type parameters are managed;
                all special types have spec'd values (basically, (non-string) primitives) are not managed;
            
            Only structs are complicated, because the definition is recursive.  A struct type is managed
            if one of its instance fields is managed.  Unfortunately, this can result in infinite recursion.
            If the closure is finite, and we don't find anything definitely managed, then we return true.
            If the closure is infinite, we disregard all but a representative of any expanding cycle.
            
            Intuitively, this will only return true if there's a specific type we can point to that is would
            be managed even if it had no fields.  e.g. struct S { S s; } is not managed, but struct S { S s; object o; }
            is because we can point to object.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.BaseTypeAnalysis.IsManagedTypeHelper(Roslyn.Compilers.CSharp.NamedTypeSymbol)">
            <summary>
            Returns a boolean value if we can determine whether the type is managed
            without looking at its fields and Unset otherwise.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExtendedErrorTypeSymbol">
            <summary>
            An error type, used to represent the type of a type binding
            operation when binding fails.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ExtendedErrorTypeSymbol.ExtractNonErrorType(Roslyn.Compilers.CSharp.TypeSymbol)">
            <summary>
            If (we believe) we know which symbol the user intended, then we should retain that information
            in the corresponding error symbol - it can be useful for deciding how to handle the error.
            For example, we might want to know whether (we believe) the error type was supposed to be an
            interface, so that we can put it in a derived type's interface list, rather than in the base
            type slot.
            
            Sometimes we will return the original definition of the intended symbol.  For example, if we see 
            <![CDATA[IFoo<int>]]> and we have an IFoo with a different arity or accessibility 
            (e.g. <![CDATA[IFoo<int>]]> was constructed from an error symbol based on <![CDATA[IFoo<T>]]>), 
            then we'll return <![CDATA[IFoo<T>]]>, rather than trying to construct a corresponding closed
            type (which may not be difficult/possible in the case of nested types or mismatched arities).
            
            NOTE: Any non-null type symbol returned is guaranteed not to be an error type.
            </summary>
            <remarks>
            TypeSymbolExtensions.GetNonErrorGuess is a more discoverable version of this functionality.
            However, the real definition is in this class so that it can access the private field 
            nonErrorGuessType.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupFilter">
            <summary>
            represents one-to-one symbol -> SingleLookupResult filter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LookupResult">
            <summary>
            A LookupResult summarizes the result of a name lookup within a scope It also allows
            combining name lookups from different scopes in an easy way.
            
            A LookupResult can be ONE OF:
               empty - nothing found.
               a viable result - this kind of result prevents lookup into further scopes of lower priority.
                                 Viable results should be without error; ambiguity is handled in the caller.
                                 (Note that handling multiple "viable" results is not the same as in the VB compiler)
               a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                                 a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                                 non-viable results.
               a non-viable result - a result that means that the search continues into further scopes of lower priority for
                                     a viable or non-accessible result. An error is attached with the error that indicates
                                     why the result is non-viable.  A typical readon would be that it is the wrong kind of symbol.
            
            Note that the class is poolable so its instances can be obtained from a pool vai GetInstance.
            Also it is a good idea to call Free on instances after they no longer needed.
            
            The typical pattern is "caller allocates / caller frees" -
               
               var result = LookupResult.GetInstance();
             
               scope.Lookup(result, "foo");
               ... use result ...
                    
               result.Clear();
               anotherScope.Lookup(result, "moo");
               ... use result ...
            
               result.Free();   //result and its content is invalid after this
               
            
            
            </summary>
            <remarks>
            Currently LookupResult is intended only for name lookup, not for overload resolution. It is
            not clear if overload resolution will work with the structure as is, require enhancements,
            or be best served by an alternate mechanism.
            
            We might want to extend this to a more general priority scheme.
            
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(Roslyn.Compilers.CSharp.SingleLookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.LookupResult.SetFrom(Roslyn.Compilers.CSharp.LookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LookupResult.SingleSymbolOrDefault">
            <summary>
            Return the single symbol if there is exactly one, otherwise null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LookupResult.IsMultiViable">
            <summary>
            Is the result viable with one or more symbols?
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LookupResult.IsSingleViable">
            <summary>
            NOTE: Even there is a single viable symbol, it may be an error type symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceAssemblySymbol">
            <summary>
            Represents an assembly built by compiler.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.lazyAssemblyIdentity">
            <summary>
            Assembly's identity.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.modules">
            <summary>
            A list of modules the assembly consists of. 
            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.lazyCustomAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.lazyNetModuleAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data from added netmodules.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.UnassignedFieldsMap">
            <summary>
            Map for storing effectively private or effectively internal fields declared in this assembly but never initialized nor assigned.
            Each {symbol, bool} key-value pair in this map indicates the following:
             (a) Key: Unassigned field symbol.
             (b) Value: True if the unassigned field is effectively internal, false otherwise.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.UnreadFields">
            <summary>
            private fields declared in this assembly but never read
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.TypesReferencedInExternalMethods">
            <summary>
            We imitate the native compiler's policy of not warning about unused fields
            when the enclosing type is used by an extern method for a ref argument.
            Here we keep track of those types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.FirstInCycleConstants">
            <summary>
            Constants declared in this assembly that are lexically first in a minimal cycle.
            </summary>
            <remarks>
            There are two reasons to store this on the assembly, rather than the field:
            
            1) Most fields will not be first-in-cycle constants, so having a flag on each one
            would be wasteful.
            
            2) An individual field may not know that it is a first-in-cycle constant until 
            some other field that depends on it is evaluated (e.g. if it is not first in one
            cycl but is first in another an the former is found first, then the field will
            be "complete" before the second cycle is found.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceAssemblySymbol.unusedFieldWarnings">
            <summary>
            The warnings for unused fields.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.ReportDiagnosticsForSynthesizedAttributes(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            We're going to synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.ReportDiagnosticsForUnsafeSynthesizedAttributes(Roslyn.Compilers.CSharp.Compilation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            If this compilation allows unsafe code (note: allows, not contains), then when we actually emit the assembly/module, 
            we're going to synthesize SecurityPermissionAttribute/UnverifiableCodeAttribute.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceAssemblySymbol.ContainsExtensionMethods">
            <summary>
            Returns true if and only if at least one type within the assembly contains
            extension methods. Note, this method is expensive since it potentially
            inspects all types within the assembly. The expectation is that this method is
            only called at emit time, when all types have been or will be traversed anyway.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAssemblySymbol.Compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAssemblySymbol.Flags">
            <summary>
            This represents what the user claimed in source through the AssemblyFlagsAttribute.
            It may be modified as emitted due to presence or absence of the public key.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAssemblySymbol.InternalsAreVisible">
            <summary>
            True if internals are exposed at all.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            This property shouldn't be accessed during binding as it can lead to attribute binding cycle.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceAssemblySymbol.UnusedFieldWarnings">
            <summary>
            Get the warnings for unused fields.  This should only be fetched when all method bodies have been compiled.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceModuleSymbol">
            <summary>
            Represents the primary module of an assembly being built by compiler.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.assemblySymbol">
            <summary>
            Owning assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.sources">
            <summary>
            The declarations corresponding to the source files of this module.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.lazyCustomAttributesBag">
            <summary>
            Module's custom attributes 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SourceModuleSymbol.name">
            <summary>
            The name (contains extension)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceModuleSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceModuleSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceModuleSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceModuleSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceTypeParameterSymbolBase.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Roslyn.Compilers.CSharp.SourceTypeParameterSymbolBase.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SourceTypeParameterSymbolBase.CheckConstraintTypeConstraints(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Check constraints of generic types referenced in constraint types. For instance,
            with "interface I&lt;T&gt; where T : I&lt;T&gt; {}", check T satisfies constraints
            on I&lt;T&gt;. Those constraints are not checked when binding ConstraintTypes
            since ConstraintTypes has not been set on I&lt;T&gt; at that point.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OverriddenMethodTypeParameterMapBase">
            <summary>
            A map shared by all type parameters for an overriding method or a method
            that explicitly implements an interface. The map caches the overridden method
            and a type map from overridden type parameters to overriding type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SourceOverriddenMethodTypeParameterSymbol">
            <summary>
            A type parameter for a method that either overrides a base
            type method or explicitly implements an interface method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SourceOverriddenMethodTypeParameterSymbol.OverriddenTypeParameter">
            <summary>
            The type parameter to use for determining constraints. If there is a base
            method that the owner method is overriding, the corresponding type
            parameter on that method is used. Otherwise, the result is null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList">
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A list of child SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.node">
            <summary>
            The underlying syntax node
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.count">
            <summary>
            The count of elements in this list
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.#ctor(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.CountNodes(Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode)">
            <summary>
            Counts the nodes.
            </summary>
            <param name="green">The green.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.ItemInternal(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reverse">
            <summary>
            Returns the reversed list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.GetEnumerator">
            <summary>
            Gets an enumerator that iterates through the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Count">
            <summary>
            Gets the count of elements in this list
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Node">
            <summary>
            Gets the underlying node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> at the specified index.
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is out of range</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator">
            <summary>
            An enumerator for the ChildSyntaxList
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.MoveNext">
            <summary>
            Moves the next.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.Reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Enumerator.Current">
            <summary>
            Gets the element this enumerator instance is pointing to.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl"/> class.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed">
            <summary>
            A reversed list of child SyntaxNodeOrToken structs.
            </summary>
            <summary>
            A reversed list of child SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.node">
            <summary>
            The underlying syntax node
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.count">
            <summary>
            The count of elements in this list
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed"/> struct.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="count">The count of elements in this list.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator">
            <summary>
            Enumerator or the Reversed list 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator"/> struct.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.Current">
            <summary>
            Gets the element the enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ChildSyntaxList.Reversed.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element the enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StructuredTriviaSyntax">
            <summary>
            It's a non terminal Trivia SyntaxNode that has a tree underneath it.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StructuredTriviaSyntax.Roslyn#Compilers#Common#IStructuredTriviaSyntax#ParentTrivia">
            <summary>
            Get parent trivia.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxWalker">
            <summary>
            Represents a <see cref="T:Roslyn.Compilers.CSharp.SyntaxVisitor"/> that descends an entire <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> graph
            visiting each SyntaxNode and its child SyntaxNodes and <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>s in depth-first order.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SeparatedSyntaxListBuilder`1.UnderlyingBuilder">
            <summary>
            WARN WARN WARN: This should be used with extreme caution - the underlying builder does
            not give any indication that it is from a separated syntax list but the constraints
            (node, token, node, token, ...) should still be maintained.
            </summary>
            <remarks>
            In order to avoid creating a separate pool of SeparatedSyntaxListBuilders, we expose
            our underlying SyntaxListBuilder to SyntaxListPool.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CSharpLineDirectiveMap">
            <summary>
            Adds C# specific parts to the line directive map.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.Syntax">
            <summary>
            A class containing factory methods for constructing syntax nodes, tokens and trivia.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.CarriageReturnLineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing both the carriage return and line feed
            characters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.LineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single line feed character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.CarriageReturn">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single carriage return character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.Space">
            <summary>
             A trivia with kind WhitespaceTrivia containing a single space character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.Tab">
            <summary>
            A trivia with kind WhitespaceTrivia containing a single tab character.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticCarriageReturnLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not
            preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used
            to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticCarriageReturn">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia
            are used to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticSpace">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticTab">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.Syntax.ElasticMarker">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included
            automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic
            markers with appropriate trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndOfLine(System.String,System.Boolean)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. 
            </summary>
            <param name="text">The text of the trivia. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
            <param name="elastic">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote
            trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Whitespace(System.String,System.Boolean)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
            <param name="elastic">If true, the trivia produced is an elastic trivia. Elastic trivia are used to denote
            trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Comment(System.String)">
            <summary>
            Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified
            text.
            </summary>
            <param name="text">The entire text of the comment including the leading '//' token for single line comments
            or stop or start tokens for multiline comments.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DisabledText(System.String)">
            <summary>
            Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that
            is not considered active.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PreprocessingMessage(System.String)">
            <summary>
            Creates a trivia with kind PreprocessingMessageTrivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SyntaxTrivia(Roslyn.Compilers.CSharp.SyntaxKind,System.String)">
            <summary>
            Trivia nodes represents parts of the program text that are not parts of the
            syntactic grammar, such as spaces, newlines, comments, preprocessors
            directives, and disabled code.
            </summary>
            <param name="kind">
            A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
            WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,
            DocumentationCommentExteriorTrivia, DisabledTextTrivia.
            </param>
            <param name="text">
            The actual text of this token.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text
            can be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Token(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MissingToken(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MissingToken(Roslyn.Compilers.CSharp.SyntaxTriviaList,Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(System.String)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Identifier(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentiferToken containing the specified text.
            </summary>
            <param name="contextualKind">An alternative SyntaxKind that can be inferred for this token in special
            contexts. These are usually keywords.</param>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="valueText">The text of the identifier name without escapes or leading '@' character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.
            </summary>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Int32,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.
            </summary>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.UInt32,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.
            </summary>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Int64,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.
            </summary>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.UInt64,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte floating point value.
            </summary>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Single,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte floating point value.
            </summary>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Double,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from a decimal value.
            </summary>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Decimal,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from a string value.
            </summary>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from a character value.
            </summary>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(System.String,System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Literal(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.Char,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BadToken(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind BadToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the bad token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlTextLiteral(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlTextNewLine(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralNewLineToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text new line value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEntity(Roslyn.Compilers.CSharp.SyntaxTriviaList,System.String,System.String,Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlEntityLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml entity value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DocumentationCommentExterior(System.String)">
            <summary>
            Creates a trivia with kind DocumentationCommentExteriorTrivia.
            </summary>
            <param name="text">The raw text of the literal.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1">
            <summary>
            Creates an empty list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(``0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">The single element node.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(``0[])">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">An array of element nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList">
            <summary>
            Creates an empty list of tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Creates a singleton list of tokens.
            </summary>
            <param name="token">The single token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(Roslyn.Compilers.CSharp.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TokenList(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Trivia(Roslyn.Compilers.CSharp.StructuredTriviaSyntax)">
            <summary>
            Creates a trivia from a StructuredTriviaSyntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList">
            <summary>
            Creates an empty list of trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Creates a singleton list of trivia.
            </summary>
            <param name="trivia">A single trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(Roslyn.Compilers.CSharp.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TriviaList(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxTrivia})">
            <summary>
            Create a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1">
            <summary>
            Create an empty separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(``0)">
            <summary>
            Create a singleton separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">A single node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(Roslyn.Compilers.CSharp.SyntaxNodeOrToken[])">
            <summary>
            Create a singleton separated list from a sequence of nodes or tokens, alternating between nodes and
            separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">An array of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxNodeOrToken})">
            <summary>
            Create a singleton separated list from a sequence of nodes or tokens, alternating between nodes and
            separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SeparatedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.SyntaxToken})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
            <param name="separators">A sequence of token to be interleaved between the nodes. The number of tokens must
            be one less than the number of nodes.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IdentifierName(System.String)">
            <summary>
            Creates an IdentifierNameSyntax node.
            </summary>
            <param name="name">The identifier name.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseLeadingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTrailingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia using the parsing rules for trailing trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseToken(System.String,System.Int32)">
            <summary>
            Parse a C# language token.
            </summary>
            <param name="text">The text of the token including leading and trailing trivia.</param>
            <param name="offset">Optional offset into text.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTokens(System.String,System.Int32,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a sequence of C# language tokens.
            </summary>
            <param name="text">The text of all the tokens.</param>
            <param name="initialTokenPosition">An integer to use as the starting position of the first token.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">Parse options.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseName(System.String,System.Int32)">
            <summary>
            Parse a NameSyntax node using the grammar rule for names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseTypeName(System.String,System.Int32)">
            <summary>
            Parse a TypeNameSyntax node using the grammar rule for type names.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseExpression(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.
            </summary>
            <param name="text">The text of the expression.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseStatement(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a StatementSyntaxNode using grammar rule for statements.
            </summary>
            <param name="text">The text of the statement.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseCompilationUnit(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a
            SyntaxTree instance, using SyntaxTree.ParseCompilationUnit instead.
            </summary>
            <param name="text">The text of the compilation unit.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseParameterList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a ParameterListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseBracketedParameterList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a BracketedParameterListSyntax node.
            </summary>
            <param name="text">The text of the bracketed parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseArgumentList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse an ArgumentListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseBracketedArgumentList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse a BracketedArgumentListSyntax node.
            </summary>
            <param name="text">The text of the bracketed argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParseAttributeArgumentList(System.String,System.Int32,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Parse an AttributeArgumentListSyntax node.
            </summary>
            <param name="text">The text of the attribute argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MakeIText(System.String,System.Int32)">
            <summary>
            Helper method for wrapping a string in an IText.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AreEquivalent(Roslyn.Compilers.CSharp.SyntaxTree,Roslyn.Compilers.CSharp.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="oldTree">The original tree.</param>
            <param name="newTree">The new tree.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AreEquivalent(Roslyn.Compilers.CSharp.SyntaxNode,Roslyn.Compilers.CSharp.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GetStandAloneExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GetNonGenericExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Converts a generic name expression into one without the generic arguments.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IsCompleteSubmission(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Determines whether the given text is considered a syntactically complete submission.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Block(Roslyn.Compilers.CSharp.StatementSyntax[])">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Block(System.Collections.Generic.IEnumerable{Roslyn.Compilers.CSharp.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IdentifierName(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new IdentifierNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QualifiedName(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QualifiedName(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GenericName(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeArgumentListSyntax)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GenericName(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GenericName(System.String)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeArgumentList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax})">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AliasQualifiedName(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AliasQualifiedName(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AliasQualifiedName(System.String,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PredefinedType(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PredefinedTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ArrayRankSpecifierSyntax})">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayType(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayRankSpecifier(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayRankSpecifier(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax})">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PointerType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PointerType(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NullableType(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NullableType(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OmittedTypeArgument(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OmittedTypeArgument">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PrefixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PrefixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PostfixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PostfixUnaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MemberAccessExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MemberAccessExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BinaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BinaryExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConditionalExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConditionalExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThisExpression(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThisExpression">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseExpression(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseExpression">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LiteralExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LiteralExpression(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MakeRefExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MakeRefExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefTypeExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefTypeExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefValueExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RefValueExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefaultExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefaultExpression(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeOfExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeOfExpression(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SizeOfExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SizeOfExpression(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InvocationExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InvocationExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElementAccessExpression(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElementAccessExpression(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArgumentList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax})">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedArgumentList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ArgumentSyntax})">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Argument(Roslyn.Compilers.CSharp.NameColonSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Argument(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameColon(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameColon(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameColon(System.String)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CastExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CastExpression(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousMethodExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousMethodExpression(Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousMethodExpression">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SimpleLambdaExpression(Roslyn.Compilers.CSharp.ParameterSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SimpleLambdaExpression(Roslyn.Compilers.CSharp.ParameterSyntax,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParenthesizedLambdaExpression(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InitializerExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InitializerExpression(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax})">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ObjectCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ArgumentListSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ObjectCreationExpression(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ArgumentListSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ObjectCreationExpression(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousObjectMemberDeclarator(Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousObjectMemberDeclarator(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AnonymousObjectCreationExpression(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax})">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArrayTypeSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayTypeSyntax,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ArrayCreationExpression(Roslyn.Compilers.CSharp.ArrayTypeSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ImplicitArrayCreationExpression(Roslyn.Compilers.CSharp.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StackAllocArrayCreationExpression(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryExpression(Roslyn.Compilers.CSharp.FromClauseSyntax,Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Creates a new QueryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryBody(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.QueryClauseSyntax},Roslyn.Compilers.CSharp.SelectOrGroupClauseSyntax,Roslyn.Compilers.CSharp.QueryContinuationSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryBody(Roslyn.Compilers.CSharp.SelectOrGroupClauseSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FromClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FromClause(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FromClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FromClause(System.String,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LetClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LetClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LetClause(System.String,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinClause(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinClause(System.String,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinIntoClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinIntoClause(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.JoinIntoClause(System.String)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhereClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhereClause(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OrderByClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OrderByClause(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Ordering(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Ordering(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SelectClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SelectClause(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GroupClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GroupClause(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryContinuation(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryContinuation(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.QueryContinuation(System.String,Roslyn.Compilers.CSharp.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OmittedArraySizeExpression(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OmittedArraySizeExpression">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GlobalStatement(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new GlobalStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Block(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.StatementSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Block(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LocalDeclarationStatement(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LocalDeclarationStatement(Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LocalDeclarationStatement(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.VariableDeclaratorSyntax})">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclaration(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclarator(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BracketedArgumentListSyntax,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclarator(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.VariableDeclarator(System.String)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EqualsValueClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EqualsValueClause(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExpressionStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExpressionStatement(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EmptyStatement(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EmptyStatement">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LabeledStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LabeledStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LabeledStatement(System.String,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GotoStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GotoStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.GotoStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BreakStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BreakStatement">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ContinueStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ContinueStatement">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReturnStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReturnStatement(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThrowStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ThrowStatement(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.YieldStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.YieldStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhileStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WhileStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DoStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DoStatement(Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForStatement(Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForStatement(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForEachStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForEachStatement(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ForEachStatement(Roslyn.Compilers.CSharp.TypeSyntax,System.String,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingStatement(Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingStatement(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FixedStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FixedStatement(Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CheckedStatement(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UnsafeStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UnsafeStatement(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LockStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LockStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax,Roslyn.Compilers.CSharp.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseClause(Roslyn.Compilers.CSharp.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.SwitchSectionSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchStatement(Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.SwitchSectionSyntax})">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchStatement(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchSection(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.SwitchLabelSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.StatementSyntax})">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchSection">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchLabel(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new SwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SwitchLabel(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new SwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TryStatement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.CatchClauseSyntax},Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TryStatement(Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.CatchClauseSyntax},Roslyn.Compilers.CSharp.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TryStatement(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.CatchClauseSyntax})">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.CatchDeclarationSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchClause(Roslyn.Compilers.CSharp.CatchDeclarationSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchClause">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CatchDeclaration(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FinallyClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FinallyClause(Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CompilationUnit(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CompilationUnit(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax})">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.CompilationUnit">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExternAliasDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExternAliasDirective(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExternAliasDirective(System.String)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingDirective(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingDirective(Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UsingDirective(Roslyn.Compilers.CSharp.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NamespaceDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NamespaceDeclaration(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.UsingDirectiveSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax})">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NamespaceDeclaration(Roslyn.Compilers.CSharp.NameSyntax)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeList(Roslyn.Compilers.CSharp.AttributeTargetSpecifierSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeTargetSpecifier(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeTargetSpecifier(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Attribute(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.AttributeArgumentListSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Attribute(Roslyn.Compilers.CSharp.NameSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgumentList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeArgumentSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgumentList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.AttributeArgumentSyntax})">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgument(Roslyn.Compilers.CSharp.NameEqualsSyntax,Roslyn.Compilers.CSharp.NameColonSyntax,Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AttributeArgument(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameEquals(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameEquals(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.NameEquals(System.String)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterSyntax})">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameter(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameter(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameter(System.String)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax})">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassDeclaration(System.String)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StructDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StructDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax})">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StructDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.StructDeclaration(System.String)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InterfaceDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InterfaceDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.MemberDeclarationSyntax})">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InterfaceDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.InterfaceDeclaration(System.String)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BaseListSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax})">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumDeclaration(System.String)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DelegateDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DelegateDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax})">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DelegateDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DelegateDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,System.String)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumMemberDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumMemberDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EnumMemberDeclaration(System.String)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BaseList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterConstraintClause(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterConstraintClause(Roslyn.Compilers.CSharp.IdentifierNameSyntax,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterConstraintClause(Roslyn.Compilers.CSharp.IdentifierNameSyntax)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeParameterConstraintClause(System.String)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorConstraint(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorConstraint">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassOrStructConstraint(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ClassOrStructConstraint(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.TypeConstraint(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new TypeConstraintSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.FieldDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventFieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.VariableDeclarationSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventFieldDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventFieldDeclaration(Roslyn.Compilers.CSharp.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.NameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ExplicitInterfaceSpecifier(Roslyn.Compilers.CSharp.NameSyntax)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MethodDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MethodDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeParameterListSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax},Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MethodDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.MethodDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,System.String)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.OperatorDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConversionOperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConversionOperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConversionOperatorDeclaration(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.ConstructorInitializerSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorDeclaration(System.String)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorInitializer(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ConstructorInitializer(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DestructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DestructorDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ParameterListSyntax,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DestructorDeclaration(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DestructorDeclaration(System.String)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PropertyDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PropertyDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PropertyDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,System.String)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EventDeclaration(Roslyn.Compilers.CSharp.TypeSyntax,System.String)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IndexerDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BracketedParameterListSyntax,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IndexerDeclaration(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.ExplicitInterfaceSpecifierSyntax,Roslyn.Compilers.CSharp.BracketedParameterListSyntax,Roslyn.Compilers.CSharp.AccessorListSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IndexerDeclaration(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AccessorDeclarationSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorList(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AccessorDeclarationSyntax})">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorDeclaration(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.BlockSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorDeclaration(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.AccessorDeclaration(Roslyn.Compilers.CSharp.SyntaxKind,Roslyn.Compilers.CSharp.BlockSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ParameterList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax})">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedParameterList(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BracketedParameterList(Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ParameterSyntax})">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Parameter(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.EqualsValueClauseSyntax)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.Parameter(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IncompleteMember(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.AttributeListSyntax},Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IncompleteMember(Roslyn.Compilers.CSharp.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SkippedTokensTrivia(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.SkippedTokensTrivia">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DocumentationCommentTrivia(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlNodeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DocumentationCommentTrivia(Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlNodeSyntax})">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElement(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlNodeSyntax},Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElement(Roslyn.Compilers.CSharp.XmlElementStartTagSyntax,Roslyn.Compilers.CSharp.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementStartTag(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementStartTag(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax})">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementStartTag(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementEndTag(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlElementEndTag(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEmptyElement(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax},Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEmptyElement(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxList{Roslyn.Compilers.CSharp.XmlAttributeSyntax})">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlEmptyElement(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlName(Roslyn.Compilers.CSharp.XmlPrefixSyntax,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlName(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlName(System.String)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlPrefix(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlPrefix(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlPrefix(System.String)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlAttribute(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlAttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlAttribute(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlAttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlAttribute(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlAttributeSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlText(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlText">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlCDataSection(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlCDataSection(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlProcessingInstruction(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlNameSyntax,Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlProcessingInstruction(Roslyn.Compilers.CSharp.XmlNameSyntax)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlComment(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxTokenList,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.XmlComment(Roslyn.Compilers.CSharp.SyntaxTokenList)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.IfDirectiveTrivia(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElifDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.ExpressionSyntax,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElifDirectiveTrivia(Roslyn.Compilers.CSharp.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ElseDirectiveTrivia(System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndIfDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndIfDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RegionDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.RegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndRegionDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.EndRegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ErrorDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ErrorDirectiveTrivia(System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WarningDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.WarningDirectiveTrivia(System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BadDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.BadDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefineDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefineDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.DefineDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UndefDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UndefDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.UndefDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LineDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LineDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.LineDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaWarningDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaWarningDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SeparatedSyntaxList{Roslyn.Compilers.CSharp.ExpressionSyntax},System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaWarningDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaChecksumDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.PragmaChecksumDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReferenceDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.Syntax.ReferenceDirectiveTrivia(Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsGlobalMemberDeclaration(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Member declarations that can appear in global code (other than type declarations).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsAliasQualifier(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Returns true if the node is the alias of an AliasQualifiedNameSyntax
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInvoked(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an invocation expression
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInTypeOnlyContext(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if the node is in a tree location that is expected to be a type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsInNamespaceOrTypeContext(Roslyn.Compilers.CSharp.ExpressionSyntax)">
            <summary>
            Returns true if a node is in a tree location that is expected to be either a namespace or type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxFacts.IsNamedArgumentName(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Is the node the name of a named argument of an invocation, object creation expression, 
            constructor initializer, or element access, but not an attribute.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken">
            <summary>
            This structure is a union of either a SyntaxNode or a SyntaxToken.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.ToString">
            <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
            <returns>The string representation of this node or token, not including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.ToFullString">
            <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.GetFirstChildIndexSpanningPosition(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            binary search of nodes to find the slot.  Consider unifying this with that
            implementation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.HasAnnotations(System.Type)">
            <summary>
            Determines whether this node or token has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this node or token as the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.GetAnnotations(System.Type)">
            <summary>
            Gets all annotations of the specified type attached to this node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.GetLocation">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for this node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.Language">
            <summary>
            The language name that this node or token is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.HasStructuredTrivia">
            <summary>
            Determine whether any of this node or token's descendant trivia is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrToken.ContainsAnnotations">
            <summary>
            Determines whether this node or token (or any sub node, token or trivia) has annotations.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList">
            <summary>
            A list of <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> structures.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._node">
            <summary>
            The underlying field
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._position">
            <summary>
            The character position 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList._index">
            <summary>
            The index from the parent's children list of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.#ctor(Roslyn.Compilers.CSharp.SyntaxNode,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList"/> structure.
            </summary>
            <param name="node">The underlying syntax node.</param>
            <param name="index">The index.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.ToString">
            <summary>
            Returns the string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The string representation of the nodes and tokens in this list, not including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.ToFullString">
            <summary>
            Returns the full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </summary>
            <returns>
            The full string representation of the nodes and tokens in this list including the first node or token's leading trivia 
            and the last node or token's trailing trivia.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.First">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.FirstOrDefault">
            <summary>
            Gets the first SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Last">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.LastOrDefault">
            <summary>
            Gets the last SyntaxNodeOrToken structure from this list if present, else default(SyntaxNodeOrToken).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.IndexOf(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Returns the index from the list for the given nodeOrToken.
            </summary>
            <param name="nodeOrToken">The node or token to search for in the list.</param>
            <returns>The index of the found nodeOrToken, or -1 if it wasn't found</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Any">
            <summary>
            Indicates whether there is any element in the list.
            </summary>
            <returns><c>true</c> if there are any elements in the list, else <c>false</c>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Any(Roslyn.Compilers.CSharp.SyntaxKind)">
            <summary>
            Indicates whether there is any element in the list of the given kind.
            </summary>
            <returns><c>true</c> if there are any elements in the list of the given kind, else <c>false</c>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.CopyTo(System.Int32,Roslyn.Compilers.CSharp.SyntaxNodeOrToken[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.CopyTo(System.Int32,Roslyn.Compilers.ArrayElement{Roslyn.Compilers.CSharp.InternalSyntax.SyntaxNode}[],System.Int32,System.Int32)">
            <summary>
            Copies a given count of elements into the given array at specified offsets.
            </summary>
            <param name="offset">The offset to start copying from.</param>
            <param name="array">The array to copy the elements into.</param>
            <param name="arrayOffset">The array offset to start writing to.</param>
            <param name="count">The count of elements to copy.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.System#Collections#Generic#IEnumerable{Roslyn#Compilers#CSharp#SyntaxNodeOrToken}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Equality(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList,Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator ==.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.op_Inequality(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList,Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Implements the operator !=.
            </summary>
            <param name="left">The left SyntaxNodeOrTokenList</param>
            <param name="right">The right SyntaxNodeOrTokenList</param>
            <returns>
            <c>true</c> if both lists not equal, else <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Equals(Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            <c>true</c> if the current object is equal to the <paramref name="other"/> parameter; otherwise,
            <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
              <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.AsSeparatedList``1">
            <summary>
            Returns this list as a <see cref="T:Roslyn.Compilers.CSharp.SeparatedSyntaxList`1"/>.
            </summary>
            <typeparam name="TOther">The type of the list elements in the separated list.</typeparam>
            <returns></returns>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Node">
            <summary>
            Gets the underlying syntax node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Count">
            <summary>
            Gets the count of nodes in this list
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.CSharp.SyntaxNodeOrToken"/> at the specified index. 
            </summary>
            
            <exception cref="T:System.IndexOutOfRangeException"><paramref name="index"/> is out of range.</exception>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator">
            <summary>
            Enumerator for lists of SyntaxNodeOrToken structs.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxNodeOrTokenList.Enumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the struct that this enumerator instance is currently pointing to.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Represents a token in the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.HasAnnotations(System.Type)">
            <summary>
            Determines whether this token has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this token has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetAnnotations(System.Type)">
            <summary>
            Gets all annotations of the specified type attached to this token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.ToFullString">
            <summary>
            Returns the full string representation of this token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this token including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of both leading and trailing trivia for the token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithLeadingTrivia(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as leading trivia.
            </summary>
            <param name="trivia">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxTriviaList"/> to add as leading trivia.</param>
            <returns>A new token with leading trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithTrailingTrivia(Roslyn.Compilers.CSharp.SyntaxTriviaList)">
            <summary>
            Clones the token and adds the <paramref name="trivia"/> as trailing trivia.
            </summary>
            <param name="trivia">The <see cref="T:Roslyn.Compilers.CSharp.SyntaxTriviaList"/> to add as trailing trivia.</param>
            <returns>A new token with trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Equality(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if <paramref name="a"/> equals <paramref name="b"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Inequality(Roslyn.Compilers.CSharp.SyntaxToken,Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if <paramref name="a"/> is not equal to <paramref name="b"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.Equals(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Returns true if this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> equals <paramref name="other"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.Equals(System.Object)">
            <summary>
            Returns true if this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> equals <paramref name="obj"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            True is <paramref name="other"/> is equivalent to this <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>.  Two tokens are equivalent
            if they are the same kind, have the same text and have the same full width.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetHashCode">
            <summary>
            Serves as a hash function for the <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.Common.CommonSyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxToken)~Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Implicit(Roslyn.Compilers.CSharp.SyntaxToken)~Roslyn.Compilers.Common.CommonSyntaxNodeOrToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> to a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)~Roslyn.Compilers.CSharp.SyntaxToken">
            <summary>
            Converts a <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> to a <see cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/>
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.CopyAnnotationsTo(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="token" />.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetLocation">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for this token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">If true then search inside trailing trivia and skipped token trivia may be
            returned.</param>
            <param name="includeDirectives">If true then search inside trailing trivia and directive trivia may be
            returned</param>
            <param name="includeDocumentationComments">if true then search inside trailing trivia and document comment
            trivia may be returned.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetNextToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token after this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">If true then search inside leading trivia and skipped token trivia may be
            returned.</param>
            <param name="includeDirectives">If true then search inside leading trivia and directive trivia may be
            returned</param>
            <param name="includeDocumentationComments">if true then search inside leading trivia and document comment
            trivia may be returned.</param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxToken.GetPreviousToken(System.Func{Roslyn.Compilers.CSharp.SyntaxToken,System.Boolean},System.Func{Roslyn.Compilers.CSharp.SyntaxTrivia,System.Boolean})">
            <summary>
            Returns the token before this token in the syntax tree.
            </summary>
            <param name="predicate">Delegate applied to each token.  The token is returned if the predicate returns
            true.</param>
            <param name="stepInto">Delegate applied to trivia.  If this delegate is present then trailing trivia is
            included in the search.</param>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Kind">
            <summary>
            The token's <see cref="T:Roslyn.Compilers.CSharp.SyntaxKind"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Language">
            <summary>
            The language name that this token is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see cref="P:Roslyn.Compilers.CSharp.SyntaxToken.Kind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Text">
            <summary>
            The text of the token as it appeared in the source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Value">
            <summary>
            The value designated by the token, if it is a literal (e.g. true, false, 12, "foo").  For
            example, the sequence of letters of an identifier, excluding the escape character if it
            was escaped in the source, or the characters of a string excluding the quotes and with
            escape sequences translated.  For constants, ValueText is the canonical form of the
            designated value (e.g. leading zeroes are dropped).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ValueText">
            <summary>
            The string text of the value of the token.  For example, the sequence of letters of an
            identifier, excluding the escape character if it was escaped in the source, or the
            characters of a string excluding the quotes and with escape sequences translated.  For
            constants, ValueText is the canonical form of the designated value (e.g. leading zeroes
            are dropped).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Parent">
            <summary>
            The immediately enclosing <see cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxToken.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.FullSpan">
            <summary>
            The absolute span of characters of the token, including surrounding trivia that is
            attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Span">
            <summary>
            The span of characters of the token, excluding trivia surrounding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.FullWidth">
            <summary>
            The full width of the token, including surrounding trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.Width">
            <summary>
            The width of the token, excluding trivia surrounding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.LeadingWidth">
            <summary>
            The width of trivia attached to and preceding the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.TrailingWidth">
            <summary>
            The width of trivia attached to and following the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ContainsDiagnostics">
            <summary>
            True if any diagnostics are associated with the token in the context of its parse tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ContainsAnnotations">
            <summary>
            Determines whether this token or any of its trivia has annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.ContainsDirectives">
            <summary>
            True if any directives are associated with the token in the context of its parse tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasStructuredTrivia">
            <summary>
            True if any trivia of this token is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasLeadingTrivia">
            <summary>
            True if the token has preceding trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that precedes and is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.HasTrailingTrivia">
            <summary>
            True if the token has trailing trivia that is attached to the token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that follows and is attached to the token.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTree">
            <summary>
            The parsed representation of a C# source document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.CloneNodeAsRoot``1(``0)">
            <summary>
            Produces a clone of a SyntaxNode which will have current syntax tree as its parent.
            
            Caller must guarantee that if the same instance of SyntaxNode makes multiple calls 
            to this function, only one result is observable.
            </summary>
            <typeparam name="T">Type of the syntax node.</typeparam>
            <param name="node">The original syntax node.</param>
            <returns>A clone of the original syntax node that has current SyntaxTree as its parent.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.TryGetRoot(Roslyn.Compilers.CSharp.CompilationUnitSyntax@)">
            <summary>
            Gets the root node of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetReference(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.IsEquivalentTo(Roslyn.Compilers.CSharp.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.Create(Roslyn.Compilers.CSharp.CompilationUnitSyntax,System.String,Roslyn.Compilers.CSharp.ParseOptions)">
            <summary>
            Create a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.ParseText(System.String,System.String,Roslyn.Compilers.CSharp.ParseOptions,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.ParseText(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.CSharp.ParseOptions,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.ParseFile(System.String,Roslyn.Compilers.CSharp.ParseOptions,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source file.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.WithChangedText(Roslyn.Compilers.IText)">
            <summary>
            Create a new syntax based off this tree using a new source text. 
            
            If the new source text is a minor change from the current source text an incremental parse will occur
            reusing most of the current syntax tree internal data.  Otherwise, a full parse will using the new
            source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChangedSpans(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Produces a pessimistic list of spans that denote the regions of text in this tree that
            are changed from the text of the old tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list is pessimistic because it may claim more or larger regions than actually changed.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChanges(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetChangeRanges(Roslyn.Compilers.CSharp.SyntaxTree)">
            <summary>
            Gets a list of text change ranges that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLineSpan(Roslyn.Compilers.TextSpan,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/> for a <see cref="T:Roslyn.Compilers.TextSpan"/>. FileLinePositionSpans are used
            primarily for diagnostics and source locations.
            </summary>
            <param name="span">The source <see cref="T:Roslyn.Compilers.TextSpan"/> to convert.</param>
            <param name="usePreprocessorDirectives">An indicator that determines whether preprocessor #line directives
            are used to alter the resulting line span.</param>
            <param name="cancellationToken">The cancellation token.</param> 
            <returns>A resulting <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLineSpanAndIsHidden(Roslyn.Compilers.TextSpan,System.Boolean@)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/> for a <see cref="T:Roslyn.Compilers.TextSpan"/>. FileLinePositionSpans are used
            primarily for diagnostics and source locations.
            </summary>
            <param name="span">The source <see cref="T:Roslyn.Compilers.TextSpan"/> to convert.</param>
            <param name="isHiddenPosition">Returns a boolean indicating whether this span is considered hidden or not.</param>
            <returns>A resulting <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetLocation(Roslyn.Compilers.TextSpan)">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for the specified text span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(Roslyn.Compilers.CSharp.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SyntaxTrivia">
            <summary>
            Represents "trivia" in the syntax model. Trivia represent parts of the source code that are
            largely insignificant to the semantic understanding of the code. Trivia includes whitespace,
            comments, directives, text skipped as a result of #if directives, and tokens skipped by the
            parser for error recovery. Trivia are always directly parents by a token. Each token may
            have multiple leading trivia nodes and multiple trailing trivia nodes. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.HasAnnotations(System.Type)">
            <summary>
            Determines whether this trivia has annotations of the specified type.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetAnnotations(System.Type)">
            <summary>
            Gets all the annotations of the specified type attached to this trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.ToString">
            <summary> 
            Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
            will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.ToFullString">
            <summary> 
            Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
            include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The full string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetStructure">
            <summary>
            Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to 
            determine if this trivia has structure.
            </summary>
            <returns>
            A SyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. 
            If this trivia node does not have structure, returns null.
            </returns>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.CopyAnnotationsTo(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="trivia" />.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.EquivalentTo(Roslyn.Compilers.CSharp.SyntaxTrivia)">
            <summary>
            Determines whether this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.op_Implicit(Roslyn.Compilers.CSharp.SyntaxTrivia)~Roslyn.Compilers.Common.CommonSyntaxTrivia">
            <summary>
            Converts this SyntaxTrivia to a CommonSyntaxTrivia representing the same piece of trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxTrivia)~Roslyn.Compilers.CSharp.SyntaxTrivia">
            <summary>
            Converts a CommonSyntaxTrivia into a SyntaxTrivia representing the same piece of trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetLocation">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.CSharp.Location"/> for this trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CSharp.SyntaxTrivia.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Token">
            <summary>
            The parent token that this trivia is attached to, either as leading or trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxTrivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.IsDirective">
            <summary>
            Returns true if this trivia is a directive (#if, #region, etc.)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Kind">
            <summary>
            Returns the kind of this trivia. The kind distinguishes between different sorts of trivia, such as spaces,
            newlines, comments, each sort of directive, disabled code, skipped tokens.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Language">
            <summary>
            The language name that this trivia is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.FullWidth">
            <summary>
            The complete width of the node in characters, including leading and trailing trivia.
            </summary>
            <remarks>The FullWidth property returns the same value as FullSpan.Length, but is somewhat more
            efficient.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia.
            </summary>
            <remarks>
            The Width property returns the same value as Span.Length, but is somewhat more efficient.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.ContainsAnnotations">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens, or trivia have any annotations on them.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SyntaxTrivia.HasStructure">
            <summary>
            Returns true if this trivia node has structure that is exposed through the GetStructure() method.
            </summary>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.RefOrOutKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifer name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousMethodExpressionSyntax.Block">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the property being initialized.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the property is initialized with.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectPropertyInitializerSyntax representing the list of object property initializers.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumMemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IncompleteMemberSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InternalSyntax.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.RefOrOutKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifer name.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousMethodExpressionSyntax.Block">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the property being initialized.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the property is initialized with.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectPropertyInitializerSyntax representing the list of object property initializers.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label. For default label the property returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Roslyn.Compilers.CSharp.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IncompleteMemberSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Roslyn.Compilers.CSharp.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
    </members>
</doc>
