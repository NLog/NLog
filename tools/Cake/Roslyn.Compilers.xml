<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Roslyn.Compilers</name>
    </assembly>
    <members>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3">
            <summary>
            The base class for language specific assembly managers.
            </summary>
            <typeparam name="TCompilation">Language specific representation for a compilation</typeparam>
            <typeparam name="TAssemblySymbol">Language specific representation for an assembly symbol.</typeparam>
            <typeparam name="TModuleSymbol">Language specific representation for a module symbol</typeparam>
        </member>
        <member name="F:Roslyn.Compilers.CommonAssemblyManager`3.UnknownAssemblyName">
            <summary>
            The name to be used as an assembly name in case a netmodule is 
            being built and '/moduleassemblyname' was not provided 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CheckPropertiesConsistency(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.MetadataReference,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.WeakIdentityPropertiesEquivalent(Roslyn.Compilers.AssemblyIdentity,Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Called to compare two weakly named identities with the same name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.ResolveMetadataReferences(`0,System.Collections.Generic.List{Roslyn.Compilers.MetadataReference},System.Collections.Generic.IDictionary{System.String,Roslyn.Compilers.MetadataReference}@,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.MetadataReference}@,System.Collections.Generic.List{Roslyn.Compilers.CommonAssemblyManager{`0,`1,`2}.AssemblyData},System.Collections.Generic.List{Roslyn.Compilers.MetadataReader.Module},Roslyn.Compilers.DiagnosticBag)">
             <summary>
             Resolves given metadata references to assemblies and modules.
             </summary>
             <param name="compilation">The compilation whose references are being resolved.</param>
             <param name="references">List where to store resolved references. References from #r directives will follow references passed to the compilation constructor.</param>
             <param name="boundReferenceDirectiveMap">Maps #r values to successuflly resolved metadata references. Does not contain values that failed to resolve.</param>
             <param name="boundReferenceDirectives">Unique metadata references resolved from #r directives.</param>
             <param name="assemblies">List where to store information about resolved assemblies to.</param>
             <param name="modules">List where to store information about resolved modules to.</param>
             <param name="diagnostics">Diagnostic bag where to report resolution errors.</param>
             <returns>
             Maps index to <paramref name="references"/> to an index of a resolved assembly or module in <paramref name="assemblies"/> or <paramref name="modules"/>, respectively.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.ResolveReferenceDirective(System.String,Roslyn.Compilers.Common.CommonLocation,`0)">
            <summary>
            For each given directive return a bound PE reference, or null if the binding fails.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.ResolveReferencedAssembly(Roslyn.Compilers.AssemblyIdentity,Roslyn.Compilers.CommonAssemblyManager{`0,`1,`2}.AssemblyData[],System.Int32@)">
            <summary>
            Used to match AssemblyRef with AssemblyDef.
            </summary>
            <param name="definitions">Array of definition identities to match against.</param>
            <param name="reference">Reference identity to resolve.</param>
            <param name="versionDifference">
            Undefined if returned value is -1.
            Otherwise:
               0 if the reference is equivalent to the returned definition.
              -1 if version of the matched definition is lower than version of the reference, but the reference otherwise matches the definition.
              +1 if version of the matched definition is higher than version of the reference, but the reference otherwise matches the definition.
            </param>
            <returns>
            Returns an index the reference is bound to:
              Index >= 0 when reference is bound to an assembly with index (I)
              Index = -1 when reference cannot be resolved
            </returns>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceBinding">
            <summary>
            Used for result of the Bind method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceBinding.AssemblySymbol">
            <summary>
            Suitable AssemblySymbol instance for the corresponding assembly, 
            null reference if none is available/found.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceBinding.ReferenceBinding">
            <summary>
            Result of resolving assembly references of the corresponding assembly 
            against provided set of assemblies. Essentially, this is an array returned by
            AssemblyData.BindAssemblyReferences method. 
            
            Each element (ReferenceBinding[i]) is an index of the AssemblyData object in 
            the input array of the Bind method, which describes the assembly the
            corresponding reference (AssemblyReferences[i]) is bound to:
             Index >= 0 when reference is bound to an assembly with index (Index)
             Index = -1 When reference cannot be resolved
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceCandidate">
            <summary>
            Private helper class to capture information about AssemblySymbol instance we 
            should check for suitability. Used by the Bind method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceCandidate.AssemblyIndex">
            <summary>
            An index of the AssemblyData object in the input array. AssemblySymbol instance should 
            be checked for suitability against assembly described by that object, taking into account 
            assemblies described by other AssemblyData objects in the input array.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceCandidate.AssemblySymbol">
            <summary>
            AssemblySymbol instance to check for suitability.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyReferenceCandidate.#ctor(System.Int32,`1)">
            <summary>
            Convenience constructor to initialize fields of this structure.
            </summary>
            <param name="index">Value for AssemblyIndex field.</param>
            <param name="sym">Value for AssemblySymbol field.</param>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3.MetadataReferenceEqualityComparer">
            <summary>
            Decides whether 2 references are interchangeable when used in the same compilation.
            PE references are interchangeable if they have the same non-null full path, compilation references if they refer to the same compilation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData">
            <summary>
            Information about an assembly, used as an input for the Binder class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData.IsMatchingAssembly(`1)">
            <summary>
            Check if provided AssemblySymbol is created for assembly described by this instance. 
            This method is expected to return true for every AssemblySymbol returned by 
            AvailableSymbols property.
            </summary>
            <param name="assembly">
            The AssemblySymbol to check.
            </param>
            <returns>Boolean.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData.BindAssemblyReferences(Roslyn.Compilers.CommonAssemblyManager{`0,`1,`2}.AssemblyData[],Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Resolve assembly references against assemblies described by provided AssemblyData objects. 
            In other words, match assembly identities returned by AssemblyReferences property against 
            assemblies described by provided AssemblyData objects.
            </summary>
            <param name="assemblies">
            An array of AssemblyData objects to match against.
            </param>
            <param name="diagnostics">TODO (tomat): remove</param>
            <returns>
            An array of indexes, each element (result[i]) is an index of the assembly the
            corresponding reference (AssemblyReferences[i]) is bound to:
             Index >= 0 when reference is bound to an assembly with index (Index)
             Index = -1 When reference cannot be resolved
             
            The array must have the same size as the one returned by AssemblyReferences.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData.Identity">
            <summary>
            Identity of the assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData.AssemblyReferences">
            <summary>
            Identity of assemblies referenced by this assembly.
            References should always be returned in the same order.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonAssemblyManager`3.AssemblyData.AvailableSymbols">
            <summary>
            The sequence of AssemblySymbols the Binder can choose from.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder">
            <summary>
            The purpose of this class is, for the given set of AssemblyData objects, do the following:
               1) Resolve references from each assembly against other assemblies in the set.
               2) Choose suitable AssemblySymbol instance for each AssemblyData object.
               
            The only entry point for consumers is the Bind method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.Bind(`1,Roslyn.Compilers.CommonAssemblyManager{`0,`1,`2}.AssemblyData[],Roslyn.Compilers.DiagnosticBag)">
             <summary>
             For the given set of AssemblyData objects, do the following:
                1) Resolve references from each assembly against other assemblies in the set.
                2) Choose suitable AssemblySymbol instance for each AssemblyData object.
             </summary>
             <param name="assemblyBeingBuilt">
             An AssemblySymbol instance for the assembly we are building. 
             
             If non-null reference is provided, the first element (index==0) of the assemblies array
             should describe this assembly and its AvailableSymbols property should return sequence,
             which contains exactly one item and that item is this instance. One can think about the
             rest of the items in assemblies array as assembly references given to the compiler to
             build executable for the assemblyBeingBuilt. 
             </param>
             <param name="assemblies">
             The set of AssemblyData objects describing assemblies, for which this method should
             resolve references and find suitable AssemblySymbols. This array is not modified by the
             method.
             </param>
             <param name="diagnostics">TODO (tomat): remove</param>
             <returns>
             An array of Binding structures describing the result. It has the same amount of items as
             the input assemblies array, Binding structure for each input AssemblyData object resides
             at the same position.
             
             Each Binding structure contains the following data:
             
             -    Suitable AssemblySymbol instance for the corresponding assembly, 
                 null reference if none is available/found.
            
             -    Result of resolving assembly references of the corresponding assembly 
                 against provided set of assemblies. Essentially, this is an array returned by
                 AssemblyData.BindAssemblyReferences method. 
                 Each element (ReferenceBinding[i]) is an index of the AssemblyData object in 
                 the input assemblies array, which describes the assembly the
                 corresponding reference (AssemblyReferences[i]) is bound to:
                      Index >= 0 when reference is bound to an assembly with index (Index)
                      Index = -1 When reference cannot be resolved
             </returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.InternalsMayBeVisibleToAssemblyBeingCompiled(System.String,Roslyn.Compilers.MetadataReader.Assembly)">
            <summary>
            Determines if it is possible that <paramref name="assembly"/> gives internals
            access to assembly <paramref name="compilationName"/>. It does not make a conclusive
            determination of visibility because the compilation's strong name key is not supplied.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.GetActualBoundReferencesUsedBy(`1)">
            <summary>
            Return AssemblySymbols referenced by the input AssemblySymbol. The AssemblySymbols must correspond 
            to the AssemblyNames returned by AssemblyData.AssemblyReferences property. If reference is not 
            resolved, null reference should be returned in the corresponding item. 
            </summary>
            <param name="assemblySymbol"></param>
            The target AssemblySymbol instance.
            <returns>
            An array of AssemblySymbols referenced by the input AssemblySymbol.
            Implementers may return cached array, Binder does not mutate it.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.GetNoPiaResolutionAssemblies(`1)">
            <summary>
            Return collection of assemblies involved in canonical type resolution of
            NoPia local types defined within target assembly. In other words, all 
            references used by previous compilation referencing the target assembly.
            </summary>
            <param name="candidateAssembly"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.IsLinked(`1)">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAssemblyManager`3.CommonAssemblyBinder.GetCorLibrary(`1)">
            <summary>
            Get Assembly used as COR library for the candidate.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonCompilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonCompilation.RetargetingAssemblySymbols">
            <summary>
            The list of RetargetingAssemblySymbol objects created for this Compilation. 
            RetargetingAssemblySymbols are created when some other compilation references this one, 
            but the other references provided are incompatible with it. For example, compilation C1 
            references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this
            case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.AssemblySymbol, but reference a special RetargetingAssemblySymbol created
            for C1 by AssemblyManager.
             
            WeakReference is used to allow RetargetingAssemblySymbols to be collected when they become unused.
            
            The cache must be locked for the duration of read/write operations, 
            see AssemblyManager.CacheLockObject property.
            
            Internal for testing.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CacheRetargetingAssemblySymbol(Roslyn.Compilers.Common.IAssemblySymbol)">
            <summary>
            Adds given retargeting assembly for this compilation into the cache.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonCompilation.lazyBoundReferenceDirectiveMap">
            <summary>
            Maps reference string used in #r directive to a resolved metadata reference.
            If multiple #r's use the same value as a reference the resolved metadata reference is the same as well.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonCompilation.lazyBoundReferenceDirectives">
            <summary>
            Array of unique bound #r references in the order they appear in the source code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonCompilation.LexicalOrderSymbolComparer">
            <summary>
            This is a special symbol comparer, which is supposed to be used for sorting original 
            definition symbols (explicitly or explicitly declared in source within the same 
            container) in lexical order of their declarations. It will not work on anything that 
            uses non-source locations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CheckSubmissionOptions(Roslyn.Compilers.Common.CommonCompilationOptions)">
            <summary>
            Checks options passed to submission compilation constructor.
            Throws an exception if the options are not applicable to submissions.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.Clone">
            <summary>
            Creates a new compilation equivalent to this one with different symbol instances.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetSemanticModel(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Gets a new <see cref="T:Roslyn.Compilers.Common.ISemanticModel"/> for the specified syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CreateErrorTypeSymbol(Roslyn.Compilers.Common.INamespaceOrTypeSymbol,System.String,System.Int32)">
            <summary>
            Returns a new INamedTypeSymbol representing a error type with the given name and arity
            in the given optional container.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.UpdateOptions(Roslyn.Compilers.Common.CommonCompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetSubmissionSlotIndex">
            <summary>
            Gets or allocates a runtime submission slot index for this compilation (<see cref="T:Roslyn.Scripting.Session"/>).
            </summary>
            <returns>Non-negative integer if this is a submission and it or a previous submission contains code, negative integer otherwise.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetSubmissionResultType(System.Boolean@)">
            <summary>
            Returns the type of the submission return value.
            </summary>
            <exception cref="T:System.InvalidOperationException">The compilation doesn't represent a submission (<see cref="P:Roslyn.Compilers.Common.CommonCompilation.IsSubmission"/> return false).</exception>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.UpdatePreviousSubmission(Roslyn.Compilers.Common.CommonCompilation)">
            <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.AddSyntaxTrees(Roslyn.Compilers.Common.CommonSyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveSyntaxTrees(Roslyn.Compilers.Common.CommonSyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info for use with
            trees added later.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ReplaceSyntaxTree(Roslyn.Compilers.Common.CommonSyntaxTree,Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Creates a new compilation with an old syntax tree replaced with a new syntax tree.
            Reuses metadata from old compilation object.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ContainsSyntaxTree(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree. False otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.EnsureSourceAssemblyCreated">
            <summary>
            Calls assembly manager to binds metadata references of this compilation if they haven't been bound yet.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ToMetadataReference">
            <summary>
            Creates a metadata reference for this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.WithReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CommonWithReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.AddReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.AddReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveReferences(Roslyn.Compilers.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveReferences(System.Collections.Generic.IEnumerable{Roslyn.Compilers.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ReplaceReference(Roslyn.Compilers.MetadataReference,Roslyn.Compilers.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata
            reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetReferencedModuleSymbol(Roslyn.Compilers.MetadataReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.Common.IModuleSymbol"/> that represents an added metadata module.
            </summary>
            <returns>
            <see cref="T:Roslyn.Compilers.Common.IModuleSymbol"/> corresponding to the given reference or null if there is none.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetReferencedAssemblySymbol(Roslyn.Compilers.MetadataReference)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.Common.IAssemblySymbol"/> for a metadata reference used to create this
            compilation.
            </summary>
            <returns>Assembly symbol corresponding to the given reference or null if there is
            none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetCompilationNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Gets the corresponding compilation namespace for the specified module or assembly namespace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetEntryPoint(System.Threading.CancellationToken)">
            <summary>
            Returns the Main method that will serves as the entry point of the assembly, if it is
            executable (and not a script).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetSpecialType(Roslyn.Compilers.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the Cor Library referenced by this
            compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CreateArrayTypeSymbol(Roslyn.Compilers.Common.ITypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CreatePointerTypeSymbol(Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this
            Compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies using its
            canonical CLR metadata name.
            </summary>
            <returns>Null if the type can't be found.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ClassifyConversion(Roslyn.Compilers.Common.ITypeSymbol,Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a "source" type was
            converted to a given "destination" type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics for the compilation, including syntax, declaration, and
            binding. Does not include any diagnostics that might be produced during emit, see
            <see cref="T:CommonEmitResult"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,System.IO.Stream,System.IO.Stream)">
            <summary>
            Create a stream filled with default win32 resources.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.ConstructModuleSerializationProperties(Roslyn.Compilers.MetadataReader.Assembly)">
            <summary>
            Constructs the module serialization properties out of the compilation options of this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.HasCodeToEmit">
            <summary>
            Return true if the compilation contains any code or types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.Emit(System.IO.Stream,System.String,System.String,System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken,System.IO.Stream,System.Collections.Generic.IEnumerable{Roslyn.Compilers.ResourceDescription})">
            <summary>
            Emit the IL for the compiled source code into the specified stream.
            </summary>
            <param name="executableStream">Stream to which the compilation will be written.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="pdbFilePath">The name of the PDB file - embedded in the output.  Null to infer from the stream or the compilation.
            Ignored unless pdbStream is non-null.
            </param>
            <param name="pdbStream">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>
            <param name="xmlDocStream">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <param name="win32ResourcesInRESFormat">Stream from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none. The RES format begins with a null resource entry.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.EmitMetadataOnly(System.IO.Stream,System.String,System.Threading.CancellationToken)">
            <summary>
            Emits the IL for the symbol declarations into the specified stream. Useful for emitting
            information for cross-language modeling of code. This emits what it can even if there
            are errors.
            </summary>
            <param name="metadataStream">Stream to which the compilation's metadata will be written.</param>
            <param name="outputName">Name of the compilation: file name and extension.  Null to use the existing output name.
            CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to
            and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the 
            name of the compilation, may not be visible at runtime and vice-versa.
            </param>
            <param name="cancellationToken">To cancel the emit process.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CompareSyntaxTreeOrdering(Roslyn.Compilers.Common.CommonSyntaxTree,Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            The compiler needs to define an ordering among different partial class in different syntax trees
            in some cases, because emit order for fields in structures, for example, is semantically important.
            This function defines an ordering among syntax trees in this compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.CompareSourceLocations(Roslyn.Compilers.Common.CommonLocation,Roslyn.Compilers.Common.CommonLocation)">
            <summary>
            Compare two source locations, using their containing trees, and then by Span.First within a tree. 
            Can be used to get a total ordering on declarations, for example.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.FirstSourceLocation``1(``0,``0)">
            <summary>
            Return the lexically first of two locations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilation.FirstSourceLocation``1(Roslyn.Compilers.ReadOnlyArray{``0})">
            <summary>
            Return the lexically first of multiple locations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.MetadataFileProvider">
            <summary>
            Translates a resolved assembly reference path to a path to the file that can be opened by the compiler.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.FileResolver">
            <summary>
            Gets the resolver for resolving file references for the compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.IsCaseSensitive">
            <summary>
            Returns true if this is a case sensitive compilation, false otherwise.  Case sensitivity
            affects compilation features such as name lookup as well as choosing what names to emit
            when there are multiple different choices (for example between a virtual method and an
            override).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.Name">
            <summary>
            The assembly name of this compilation. No extension.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.OutputName">
            <summary>
            The name passed to the constructor of the Compilation. Assumed to contain file name and
            extension.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.Options">
            <summary>
            Gets the options the compilation was created with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.IsSubmission">
            <summary>
            True if the compilation represents an interactive submission.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.SubmissionReturnType">
            <summary>
            The type object that represents the type of submission result the host requested.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.HostObjectType">
            <summary>
            The type of the host object or null if not specified for this compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.PreviousSubmission">
            <summary>
            The previous submission compilation, or null if this compilation doesn't represent a
            submission or the submission is the first submission in a submission chain.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.SyntaxTrees">
            <summary>
            Gets the syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.AlwaysImportInternalMembers">
            <summary>
            Internal members of referenced assemblies are not imported unless the referenced assembly has InternalsVisibleTo
            this assembly. Set this to true to override that behavior. Can be useful for testing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ExternalReferences">
            <summary>
            Metadata references passed to the compilation constructor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.DirectiveReferences">
            <summary>
            Unique metadata references specified via #r directive in the source code of this compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ReferenceDirectiveMap">
            <summary>
            Maps values of #r references to resolved metadata references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.References">
            <summary>
            All metadata references -- references passed to the compilation constructor as well as references specified via #r directives.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ReferencedAssemblyNames">
            <summary>
            Assembly identities of all assemblies directly referenced by this compilation.
            </summary>
            <remarks>
            Includes identities of references passed in the compilation constructor 
            as well as those specified via directives in source code. 
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.Assembly">
            <summary>
            The <see cref="T:Roslyn.Compilers.Common.IAssemblySymbol"/> that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.SourceModule">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.Common.IModuleSymbol"/> for the module being created by compiling all of
            the source code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.GlobalNamespace">
            <summary>
            The root namespace that contains all namespaces and types defined in source code or in 
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ObjectType">
            <summary>
            The INamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonCompilation.LexicalOrderSymbolComparerImpl">
            <summary>
            This is an implementation of a special symbol comparer, which is supposed to be used 
            for sorting original definition symbols (explicitly or explicitly declared in source 
            within the same container) in lexical order of their declarations. It will not work on 
            anything that uses non-source locations.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.IAssemblyLoader">
            <summary>
            Loads assemblies for Reflection based APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IAssemblyLoader.Load(Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Loads an assembly given its full name.
            </summary>
            <param name="identity">The identity of the assembly to load.</param>
            <returns>The loaded assembly.</returns>
        </member>
        <member name="T:Roslyn.Compilers.ClrMetaHost">
            <summary>
            Managed abstraction of the functionality provided by ICLRMetaHost.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ClrMetaHost.CurrentRuntime">
            <summary>
            Gets the <see cref="T:Microsoft.Runtime.Hosting.ClrRuntimeInfo"/> corresponding to the current runtime.
            That is, the runtime executing currently.
            </summary>
        </member>
        <member name="T:Microsoft.Runtime.Hosting.ClrRuntimeInfo">
            <summary>
            Managed abstraction of the functionality provided by ICLRRuntimeInfo.
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.Hosting.ClrRuntimeInfo.#ctor(Microsoft.Runtime.Hosting.Interop.IClrRuntimeInfo)">
            <summary>
            Constructor that wraps an ICLRRuntimeInfo (used internally)
            </summary>
        </member>
        <member name="M:Microsoft.Runtime.Hosting.ClrRuntimeInfo.GetInterface``1(System.Guid)">
            <summary>
            Gets an interface provided by this runtime, such as ICLRRuntimeHost.
            </summary>
            <typeparam name="TInterface">The interface type to be returned.  This must be an RCW interface</typeparam>
            <param name="clsid">The CLSID to be created</param>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethods">
            <summary>
            Constructs and caches already created pseudo-methods.
            Every compiled module is supposed to have one of this, created lazily 
            (multidimensional arrays are not common).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ArrayMethods.GetArrayConstructor(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an array constructor for a given array type
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ArrayMethods.GetArrayGet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element getter method for a given array type
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ArrayMethods.GetArraySet(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element setter method for a given array type
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ArrayMethods.GetArrayAddress(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Acquires an element referencer method for a given array type
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.ArrayMethods.dict">
            <summary>
            Maps {array type, method kind} tuples to implementing pseudo-methods.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ArrayMethods.GetArrayMethod(Microsoft.Cci.IArrayTypeReference,Roslyn.Compilers.CodeGen.ArrayMethods.ArrayMethodKind)">
            <summary>
            lazily fetches or creates a new array method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethods.ArrayConstructor">
            <summary>
            "newobj ArrayConstructor"  is equivalent of "newarr ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethod">
            <summary>
            Base of all array methods. They have a lot in common.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodReference">
            <summary>
            A reference to a method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISignature">
            <summary>
            The parameters and return type that makes up a method or property signature.
            This interface models the metadata representation of a signature.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetParameters(System.Object)">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISignature.GetType(System.Object)">
            <summary>
            The return type of the method or type of the property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.CallingConvention">
            <summary>
            Calling convention of the signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ParameterCount">
            <summary>
            The number of required parameters of the signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. Evaluate this property only if ReturnValueIsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueIsByRef">
            <summary>
            True if the return value is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISignature.ReturnValueIsModified">
            <summary>
            True if the return value has one or more custom modifiers associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeMemberReference">
            <summary>
            A reference to a member of a type, such as a field or a method.
            This interface models the metadata representation of a type member reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IReference">
            <summary>
            An object corresponding to reference to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.GetAttributes">
            <summary>
            A collection of metadata custom attributes that are associated with this definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IReference.AsDefinition(System.Object)">
            <summary>
            Gets the definition object corresponding to this reference within the given context, 
            or null if the referenced entity isn't defined in the context.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedEntity">
            <summary>
            Implemented by any entity that has a name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedEntity.Name">
            <summary>
            The name of the entity.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeMemberReference.GetContainingType(System.Object)">
            <summary>
            A reference to the containing type of the referenced type member.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodReference.GetResolvedMethod(System.Object)">
            <summary>
            The method being referred to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.AcceptsExtraArguments">
            <summary>
            True if the call sites that references the method with this object supply extra arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.GenericParameterCount">
            <summary>
            The number of generic parameters of the method. Zero if the referenced method is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.IsGeneric">
            <summary>
            True if the method has generic parameters;
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodReference.ExtraParameters">
            <summary>
            Information about this types of the extra arguments supplied at the call sites that references the method with this object.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethods.ArrayGet">
            <summary>
            "call ArrayGet"  is equivalent of "ldelem ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethods.ArrayAddress">
            <summary>
            "call ArrayAddress"  is equivalent of "ldelema ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethods.ArraySet">
            <summary>
            "call ArraySet"  is equivalent of "stelem ElementType" 
            when working with multidimentsional arrays
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArrayMethodParameterInfo">
            <summary>
            Represents a parameter in an array pseudo-method.
            
            NOTE: It appears that that only number of indeces is used for verification, 
            types just have to be Int32.
            Even though actual arguments can be native ints.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterTypeInformation">
            <summary>
            Information that describes a method or property parameter, but does not include all the information in a IParameterDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterListEntry">
            <summary>
            Implemented by an entity that is always a member of a particular parameter list, such as an IParameterDefinition.
            Provides a way to determine the position where the entity appears in the parameter list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterListEntry.Index">
            <summary>
            The position in the parameter list where this instance can be found.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterTypeInformation.GetType(System.Object)">
            <summary>
            The type of argument value that corresponds to this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter. Evaluate this property only if IsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.IsByReference">
            <summary>
            True if the parameter is passed by reference (using a managed pointer).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterTypeInformation.IsModified">
            <summary>
            This parameter has one or more custom modifiers associated with it.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ArraySetValueParameterInfo">
            <summary>
            Represents the "value" parameter of the Set pseudo-method.
            
            NOTE: unlike index parameters, type of the value parameter must match 
            the actual element type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.TokenMap`1">
            <summary>
            Handles storage of items referenced via tokens in metadata (strings or Symbols).
            When items are stored they are uniquely "associated" with fake token, which is basically 
            a sequential number.
            IL gen will use these fake tokens during codegen and later, when actual token values are known
            the method bodies will be patched.
            To support thse two scenarios we need two maps - Item-->uint, and uint-->Item.  (the second is really just a list).
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference">
            <summary>
            This class represents the PermissionSetAttribute specified in source which needs fixup during codegen.
            </summary>
            <remarks>
            PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
            Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute at ndp\clr\src\vm\securityattributes.cpp.
            It involves following steps:
            1) Verifying that the specified file name resolves to a valid path: This is done during binding.
            2) Reading the contents of the file into a byte array.
            3) Convert each byte in the file content into two bytes containing hexa-decimal characters (see method <see cref="M:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.ConvertToHex(System.Byte[])"/>).
            4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            </remarks>
        </member>
        <member name="T:Microsoft.Cci.ICustomAttribute">
            <summary>
            A metadata custom attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetArguments(System.Object)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.Constructor(System.Object)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetNamedArguments(System.Object)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ICustomAttribute.GetType(System.Object)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomAttribute.AllowMultiple">
            <summary>
            Whether attribute allows multiple.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.GetArguments(System.Object)">
            <summary>
            Zero or more positional arguments for the attribute constructor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.Constructor(System.Object)">
            <summary>
            A reference to the constructor that will be used to instantiate this custom attribute during execution (if the attribute is inspected via Reflection).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.GetNamedArguments(System.Object)">
            <summary>
            Zero or more named arguments that specify values for fields and properties of the attribute.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.GetType(System.Object)">
            <summary>
            The type of the attribute. For example System.AttributeUsageAttribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.ArgumentCount">
            <summary>
            The number of positional arguments.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.PermissionSetAttributeWithFileReference.NamedArgumentCount">
            <summary>
            The number of named arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataExpression">
            <summary>
            An expression that can be represented directly in metadata.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataExpression.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IStatement. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataExpression.Type">
            <summary>
            The type of value the expression represents.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataNamedArgument.IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.PermissionSetFileReadException">
            <summary>
            Exception class to enable generating ERR_PermissionSetAttributeFileReadError while reading the file for PermissionSetAttribute fixup.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.RawSequencePoint">
            <summary>
            Represents a sequence point before translation by #line/ExternalSource directives.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.LocalConstantDefinition">
            <summary>
            We need a CCI representation for local constants because they are emitted as locals in
            PDB scopes to improve the debugging experience (see LocalScopeProvider.GetConstantsInScope).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ILocalDefinition">
            <summary>
            An object that represents a local variable or constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CompileTimeValue">
            <summary>
            The compile time value of the definition, if it is a local constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.CustomModifiers">
            <summary>
            Custom modifiers associated with local variable definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsConstant">
            <summary>
            True if this local definition is readonly and initialized with a compile time constant value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsModified">
            <summary>
            The local variable has custom modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsPinned">
            <summary>
            True if the value referenced by the local must not be moved by the actions of the garbage collector.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.IsReference">
            <summary>
            True if the local contains a managed pointer (for example a reference to a local variable or a reference to a field of an object).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.MethodDefinition">
            <summary>
            The definition of the method in which this local is defined.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalDefinition.Type">
            <summary>
            The type of the local.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ExternNamespace">
            <summary>
            Represents an assembly reference with an alias (i.e. an extern alias in C#).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IExternNamespace">
            <summary>
            Represents an assembly reference with an alias (i.e. an extern alias in C#).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IExternNamespace.NamespaceAlias">
            <summary>
            An alias for the global namespace of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IExternNamespace.AssemblyName">
            <summary>
            The name of the referenced assembly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.NamespaceScope">
            <summary>
            This is a list of the using directives (including aliases) in
            a namespace.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceScope">
            <summary>
            A description of the lexical scope in which a namespace type has been nested. This scope is tied to a particular
            method body, so that partial types can be accommodated.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceScope.UsedNamespaces">
            <summary>
            Zero or more used namespaces. These correspond to using clauses in C#.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.SecurityActionMembers">
            <summary>
            This is a duplication of the obsolete members of the enum System.Security.Permissions.SecurityAction.SecurityAction because the original
            enum has obsolete members and it's not possible in VB to suppress warnings for only parts of the source code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.SequencePointList">
            <summary>
            Maintains a list of sequence points in a space efficient way. Most of the time sequence points
            occur in the same syntax tree, so optimize for that case. Store a sequence point as an offset, and 
            position in a syntax tree, then translate to CCI format only on demand.
            
            Use a ArrayBuilder&lt;RawSequencePoint&gt; to create.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.SequencePointList.Create(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CodeGen.RawSequencePoint})">
            <summary>
            Create a SequencePointList with the raw sequence points from an ArrayBuilder.
            A linked list of instances for each syntax tree is created (almost always of length one).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.SequencePointList.GetSequencePoints(System.Func{System.String,Microsoft.Cci.DebugSourceDocument})">
            <summary>
            Get all the sequence points, possibly mapping them using #line/ExternalSource directives, and mapping
            file names to debug documents with the given mapping function.
            </summary>
            <param name="mapFileNameToDebugDoc">Function that maps file paths to CCI debug documents</param>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.SequencePointList.OffsetAndSpan">
            <summary>
            Represents the combination of an IL offset and a source text span.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.UsedNamespaceOrType">
            <summary>
            This represents a single using directive (in the scope of a method body).
            It has a name and possibly an alias.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUsedNamespaceOrType">
            <summary>
            A namespace that is used (imported) inside a namespace scope.
            
            Kind            | Example                   | Alias     | TargetName
            ----------------+---------------------------+-----------+-------------------
            Namespace       | using System;             | null      | "System"
            NamespaceAlias  | using S = System;         | "S"       | "System"
            ExternNamespace | extern alias LibV1;       | "LibV1"   | null
            TypeAlias       | using C = System.Console; | "C"       | "System.Console"
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IUsedNamespaceOrType.Alias">
            <summary>
            An alias for a namespace. For example the "x" of "using x = y.z;" in C#. Empty if no alias is present.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IUsedNamespaceOrType.TargetName">
            <summary>
            The name of a namepace that has been aliased.  For example the "y.z" of "using x = y.z;" or "using y.z" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IUsedNamespaceOrType.Kind">
            <summary>
            Distinguishes the various kinds of targets.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IUsedNamespaceOrType.ProjectLevel">
            <summary>
            Indicates whether the import was specified on a project level, or on file level (used for VB only)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IUsedNamespaceOrType.FullName">
            <summary>
            The encoded name for this used type or namespace. The encoding is dependent on the UsedNamespaceOrTypeKind.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.PrivateImplementationDetails">
            <summary>
            TypeDefinition that represents &lt;PrivateImplementationDetails&gt; class.
            The main purpose of this class so far is to contain mapped fields and their types.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.DefaultTypeDef">
            <summary>
            Just a default implementation of a type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinition">
            <summary>
            This interface models the metadata representation of a type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IDefinition">
            <summary>
            An object corresponding to a metadata entity such as a type or a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeReference">
            <summary>
            A reference to a type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeReference.GetResolvedType(System.Object)">
            <summary>
            The type definition being referred to.
            In case this type was alias, this is also the type of the aliased type
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeReference.TypeCode(System.Object)">
            <summary>
            Unless the value of TypeCode is PrimitiveTypeCode.NotPrimitive, the type corresponds to a "primitive" CLR type (such as System.Int32) and
            the type code identifies which of the primitive types it corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsEnum">
            <summary>
            True if the type is an enumeration (it extends System.Enum and is sealed). Corresponds to C# enum.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeReference.IsValueType">
            <summary>
            True if the type is a value type. 
            Value types are sealed and extend System.ValueType or System.Enum.
            A type parameter for which MustBeValueType (the struct constraint in C#) is true also returns true for this property.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetBaseClass(System.Object)">
            <summary>
            Returns null for interfaces and System.Object.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetExplicitImplementationOverrides(System.Object)">
            <summary>
            Zero or more implementation overrides provided by the class.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetFields(System.Object)">
            <summary>
            Zero or more fields defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.Interfaces(System.Object)">
            <summary>
            Zero or more interfaces implemented by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetMethods(System.Object)">
            <summary>
            Zero or more methods defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetNestedTypes(System.Object)">
            <summary>
            Zero or more nested types defined by this type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ITypeDefinition.GetProperties(System.Object)">
            <summary>
            Zero or more properties defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Alignment">
            <summary>
            The byte alignment that values of the given type ought to have. Must be a power of 2. If zero, the alignment is decided at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Events">
            <summary>
            Zero or more events defined by this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameters">
            <summary>
            Zero or more parameters that can be used as type annotations.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.HasDeclarativeSecurity">
            <summary>
            True if this type has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsAbstract">
            <summary>
            True if the type may not be instantiated.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsBeforeFieldInit">
            <summary>
            Is type initialized anytime before first access to static field
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsComObject">
            <summary>
            Is this imported from COM type library
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsGeneric">
            <summary>
            True if this type is parameterized (this.GenericParameters is a non empty collection).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsInterface">
            <summary>
            True if the type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsRuntimeSpecial">
            <summary>
            True if this type gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSerializable">
            <summary>
            True if this type is serializable.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSpecialName">
            <summary>
            True if the type has special name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.IsSealed">
            <summary>
            True if the type may not be subtyped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.Layout">
            <summary>
            Layout of the type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.PrivateHelperMembers">
            <summary>
            Zero or more private type members generated by the compiler for implementation purposes. These members
            are only available after a complete visit of all of the other members of the type, including the bodies of methods.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this type. Will be empty if this.HasSecurity is false.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.SizeOf">
            <summary>
            Size of an object of this type. In bytes. If zero, the size is unspecified and will be determined at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinition.StringFormat">
            <summary>
            Default marshalling of the Strings in this class.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeDefinition">
            <summary>
            A type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeDefinition">
            <summary>
            A named type definition, such as an INamespaceTypeDefinition or an INestedTypeDefinition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamedTypeReference">
            <summary>
            A reference to a named type, such as an INamespaceTypeReference or an INestedTypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.GenericParameterCount">
            <summary>
            The number of generic parameters. Zero if the type is not generic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamedTypeReference.MangleName">
            <summary>
            If true, the persisted type name is mangled by appending "`n" where n is the number of type parameters, if the number of type parameters is greater than 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INamespaceTypeReference">
            <summary>
            A reference to a type definition that is a member of a namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.INamespaceTypeReference.GetUnit(System.Object)">
            <summary>
            A reference to the unit that defines the referenced type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeReference.NamespaceName">
            <summary>
            Fully qualified name of the containing namespace.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.INamespaceTypeDefinition.IsPublic">
            <summary>
            True if the type can be accessed from other assemblies.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter">
            <summary>
            Class for emitting the switch jump table for switch statements with integral governing type
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.key">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.keyTypeCode">
            <summary>
            Primitive type of the switch key
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.sortedCaseLabels">
            <summary>
            Integral case labels sorted and indexed by their ConstantValue
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket.TryMerge(Roslyn.Compilers.CodeGen.SwitchIntegralJumpTableEmitter.SwitchBucket)">
            <summary>
            Try to merge the prevBucket into the current bucket.
            If merge results in a dense bucket, merge and return true.
            Else don't merge and return false.
            </summary>
            <param name="prevBucket">Bucket to merge</param>
            <returns></returns>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.key">
            <summary>
            Switch key for the jump table
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.caseLabels">
            <summary>
            Switch case labels
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.fallThroughLabel">
            <summary>
            Fall through label for the jump table
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.emitStringCondBranchDelegate">
            <summary>
            Delegate to emit string compare call
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.delegateArguments">
            <summary>
            Arguments to be passed to emitStringCondBranchDelegate
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.keyHash">
            <summary>
            Local storing the key hash value, used for emitting hash table based string switch.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.ComputeStringHash(System.String)">
            <summary>
            String Switch Hash Function.
            DEKHash function from "The Art of Computer Programming, Volume 3 - Donald E. Knuth"
            </summary>
            <remarks>
            This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
            <param name="arguments">Additional arguments for the delegate</param>
        </member>
        <member name="M:Roslyn.Compilers.ArrayBuilder`1.ToReadOnly">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ArrayBuilder`1.ToReadOnlyOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ArrayBuilder`1.ToDowncastedReadOnly``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ArrayBuilder`1.ToReadOnlyAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ArrayBuilder`1.ArrayBuilderEnumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and 
            preserves the order of values added to the dictionary.
            Thread-safe for reading, but not for adding.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.OrderPreservingMultiDictionary`2.AddRange(`0,Roslyn.Compilers.ReadOnlyArray{`1})">
            <summary>
            Add multiple values to the dictionary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.OrderPreservingMultiDictionary`2.GetCountForKey(`0)">
            <summary>
            Get the number of values assocaited with a key.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.OrderPreservingMultiDictionary`2.ContainsKey(`0)">
            <summary>
            Returns true if one or more items with given key have been added.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommandLineReference">
            <summary>
            Describes a command line metadata reference specification.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommandLineReference.Resolve(Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.Common.CommonMessageProvider)">
            <summary>
            Resolves this command line metadata reference to a <see cref="T:Roslyn.Compilers.MetadataReference"/> using given file resolver and metadata provider.
            </summary>
            <exception cref="T:System.BadImageFormatException">If the PE image format is invalid and <paramref name="diagnosticsOpt"/> is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">If the Metadata file could not be found and <paramref name="diagnosticsOpt"/> is null.</exception>
            <exception cref="T:System.IO.IOException">If error reading the file from disk and <paramref name="diagnosticsOpt"/> is null.</exception>
            <remarks>
            NOTE: Other exceptions, apart from those mentioned above, may be generated by the fileResolver or the metadata provider. These are not handled by this method.
            </remarks>
            <param name="fileResolver">The file resolver to use for assembly name and relative path resolution.</param>
            <param name="metadataProvider">Uses to create metadata references from resolved full paths.</param>
            <param name="diagnosticsOpt">Optional diagnostics list for storing diagnostics.</param>
            <param name="messageProviderOpt">Optional <see cref="T:Roslyn.Compilers.Common.CommonMessageProvider"/> for generating diagnostics.</param>
            <returns>Returns resolved metadata reference or <see cref="T:Roslyn.Compilers.UnresolvedMetadataReference"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.CommandLineReference.ResolveMetadataFile(System.String,Roslyn.Compilers.MetadataReferenceProperties,Roslyn.Compilers.MetadataFileProvider,System.String,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.Common.CommonMessageProvider)">
            <summary>
            Resolves a command line metadata reference with the given <paramref name="resolvedFullPath"/> to a <see cref="T:Roslyn.Compilers.MetadataReference"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommandLineReference.Reference">
            <summary>
            Metadata file path or an assembly display name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommandLineReference.Properties">
            <summary>
            Metadata reference properties.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommandLineReference.IsAssemblyName">
            <summary>
            True if <see cref="P:Roslyn.Compilers.CommandLineReference.Reference"/> is an assembly name, false if it is a path.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineArguments.ResolveMetadataReferences(Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:MetadataReferences"/> using given file resolver and metadata provider.
            </summary>
            <param name="fileResolver">The file resolver to use for assembly name and relative path resolution, or null to use a default.</param>
            <param name="metadataProvider">Uses to create metadata references from resolved full paths, or null to use a default.</param>
            <returns>Yields resolved metadata references or <see cref="T:Roslyn.Compilers.UnresolvedMetadataReference"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineArguments.ResolveMetadataReferences(Roslyn.Compilers.FileResolver,Roslyn.Compilers.MetadataFileProvider,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.Common.CommonMessageProvider)">
            <summary>
            Resolves metadata references stored in <see cref="P:MetadataReferences"/> using given file resolver and metadata provider.
            If a non-null diagnostic bag <paramref name="diagnosticsOpt"/> is provided, it catches exceptions that may be generated while reading the metadata file and
            reports appropriate diagnostics.
            Otherwise, if <paramref name="diagnosticsOpt"/> is null, the exceptions are unhandled.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.BaseDirectory">
            <summary>
            Directory used to resolve relative paths stored in the arguments.
            </summary>
            <remarks>
            Except for paths stored in <see cref="P:Roslyn.Compilers.Common.CommonCommandLineArguments.MetadataReferences"/>, all paths stored in the properties of this class are resolved and absolute.
            This is the directory that relative paths specified on command line were resolved against.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.ReferencePaths">
            <summary>
            Sequence of absolute paths used to search for references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.KeyFileSearchPaths">
            <summary>
            Sequence of absolute paths used to search for key files.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.Utf8Output">
            <summary>
            Use UTF8 for output
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.OutputFileName">
            <summary>
            Output file name or null if not specified.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.OutputDirectory">
            <summary>
            Absolute path of the output directory.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.Encoding">
            <summary>
            Encoding to be used for source files or 'null' for autodetect/default.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.ScriptArguments">
            <summary>
            Arguments following script argument separator "--" or null if <see cref="P:Roslyn.Compilers.Common.CommonCommandLineArguments.IsInteractive"/> is false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.SourceFiles">
            <summary>
            Source file paths.
            </summary>
            <remarks>
            Includes files specified directly on command line as well as files matching patterns specified 
            on command line using '*' and '?' wildcards or /recurse option.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCommandLineArguments.PrintFullPaths">
            <summary>
            Indicates to specify the full path of the file containing errors or warnings in a diagnostic.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommandLineSourceFile">
            <summary>
            Describes a source file specification stored on command line arguments.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommandLineSourceFile.Path">
            <summary>
            Resolved absolute path of the source file (does not contain wildcards).
            </summary>
            <remarks>
            Although this path is absolute it may not be normalized. That is, it may contain ".." and "." in the middle. 
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommandLineSourceFile.IsScript">
            <summary>
            True if the file should be treated as a script file.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonCommandLineCompiler">
            <summary>
            Base class for csc.exe, csi.exe, vbc.exe and vbi.exe implementations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.ResolveMetadataReferences(Roslyn.Compilers.MetadataFileProvider,System.Collections.Generic.List{Roslyn.Compilers.DiagnosticInfo},Roslyn.Compilers.FileResolver@)">
            <summary>
            Resolves metadata references stored in command line arguments and reports errors for those that can't be resolved.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.ReadFileContent(Roslyn.Compilers.Common.CommandLineSourceFile,System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo},System.Text.Encoding)">
            <summary>
            Reads content of a source file.
            </summary>
            <param name="file">Source file information.</param>
            <param name="diagnostics">Storage for diagnostics.</param>
            <param name="encoding">Encoding to use or 'null' for autodetect/default</param>
            <returns>File content or null on failure.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.Run(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>
            csc.exe and vbc.exe entry point.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.GetOutputFilePaths(Roslyn.Compilers.Common.CommonCompilation,System.String,System.Threading.CancellationToken,System.String@,System.String@,System.String@)">
            <summary>
            Given a compilation and a destination directory, determine three names:
              1) The name with which the assembly should be output (default = null, which indicates that the compilation output name should be used).
              2) The path of the assembly/module file (default = destination directory + compilation output name).
              3) The path of the pdb file (default = assembly/module path with ".pdb" extension).
            </summary>
            <remarks>
            C# has a special implementation that implements idiosyncratic behavior of csc.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.RunInteractive(System.IO.TextWriter)">
            <summary>
            csi.exe and vbi.exe entry point.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonCommandLineCompiler.ExistingReferencesResolver">
            <summary>
            Looks for metadata references among the assembly file references given to the compilation when constructed.
            When scripts are included into a project we don't want #r's to reference other assemblies than those 
            specified explicitly in the project references.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.FileResolver">
            <summary>
            This class is used to resolve file references for the compilation.
            It provides APIs to resolve:
            (a) Metadata reference paths.
            (b) Assembly names.
            (c) Documentation files.
            (d) Assembly strong name keyfile.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.FileResolver.Default">
            <summary>
            Default file resolver.
            </summary>
            <remarks>
            This resolver doesn't resolve any relative paths and uses the current process bitness when looking for assemblies in GAC.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.#ctor(Roslyn.Compilers.ReadOnlyArray{System.String},Roslyn.Compilers.ReadOnlyArray{System.String},System.String,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean},System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.FileResolver"/> class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.ResolveMetadataReference(System.String,System.String)">
            <summary>
            Resolves a metadata reference that is a path or an assembly name.
            </summary>
            <param name="assemblyDisplayNameOrPath">
            Assembly name or file path. 
            <see cref="M:IsFilePath"/> is used to determine whether to consider this value an assembly name or a file path.
            </param>
            <param name="baseFilePath">
            The base file path to use to resolve relative paths against.
            Null to use the <see cref="P:Roslyn.Compilers.FileResolver.BaseDirectory"/> as a base for relative paths.
            </param>
            <returns>
            Normalized absolute path to the referenced file or null if it can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.ResolveAssemblyName(System.String)">
            <summary>
            Resolves given assembly name.
            </summary>
            <returns>Full path to an assembly file.</returns>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.ResolveMetadataFile(System.String,System.String)">
            <summary>
            Resolves a given reference path.
            </summary>
            <param name="path">Path to resolve.</param>
            <param name="baseFilePath">
            The base file path to use to resolve relative paths against.
            Null to use the <see cref="P:Roslyn.Compilers.FileResolver.BaseDirectory"/> as a base for relative paths.
            </param>
            <returns>
            The resolved metadata reference path. A normalized absolute path or null.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.ResolveStrongNameKeyFile(System.String,System.String)">
            <summary>
            Resolves assembly strong name key file path.
            </summary>
            <param name="path">
            Key file path specified either through the <see cref="T:System.Reflection.AssemblyKeyNameAttribute"/> or "/keyfile" command line argument.
            </param>
            <param name="baseFilePath">
            The base file path to use to resolve current-directory-relative paths against.
            Null if not available.
            </param>
            <returns>Normalized key file path or null if not found.</returns>
        </member>
        <member name="M:Roslyn.Compilers.FileResolver.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.FileResolver.AssemblySearchPaths">
            <summary>
            Search paths used when resolving metadata references.
            </summary>
            <remarks>
            All search paths are absolute.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.FileResolver.KeyFileSearchPaths">
            <summary>
            Search paths used when resolving assembly strong name keyfile.
            </summary>
            <remarks>
            All search paths are absolute.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.FileResolver.ArchitectureFilter">
            <summary>
            Architecture filter used when resolving assembly references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.FileResolver.PreferredCulture">
            <summary>
            CultureInfo used when resolving assembly references.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.FileResolver.BaseDirectory">
            <summary>
            Directory used for resolution of relative paths.
            A full directory path or null if not available.
            </summary>
            <remarks>
            This directory is only used if the base directory isn't implied by the context within which the path is being resolved.
            
            It is used, for example, when resolving a strong name key file specified in <see cref="T:System.Reflection.AssemblyKeyFileAttribute"/>,
            or a metadata file path specified in <see cref="T:Roslyn.Compilers.MetadataFileReference"/>.
            
            On the other hand the rules for metadata reference resolution specify that 
            #r ".\foo.dll" in a script file "C:\MyDir\MyFile.csx" is resolved against "C:\MyDir" directory regardless of 
            the value of <see cref="P:BaseDirectory"/>.
            
            Resolution of a relative path that needs the base directory fails if the base directory is null.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.ExistingReferencesResolver.ResolveAssemblyName(System.String)">
            <summary>
            When compiling to a file all unresolved assembly names have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineCompiler.ExistingReferencesResolver.ResolveMetadataFile(System.String,System.String)">
            <summary>
            When compiling to a file all relative paths have to match one of the file references specified on command line.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.EnumerateFiles(System.String,System.String,System.IO.SearchOption)">
            <summary>
            Enumerates files in the specified directory and subdirectories whose name matches the given pattern.
            </summary>
            <param name="directory">Full path of the directory to enumerate.</param>
            <param name="fileNamePattern">File name pattern. May contain wildcards '*' (matches zero or more characters) and '?' (matches any character).</param>
            <param name="searchOption">Specifies whether to search the specified <paramref name="directory"/> only, or all its subdirectories as well.</param>
            <returns>Sequence of file paths.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.ParseResponseFile(System.String,System.Collections.Generic.IList{Roslyn.Compilers.DiagnosticInfo})">
            <summary>
            Parse a response file into a set of arguments. Errors openening the response file are output into "errors".
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.ParseResponseLines(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Take a string of lines from a response file, remove comments, 
            and split into a set of command line arguments.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.RemoveAllQuotes(System.String)">
            <summary>
            Remove all double quote characters from the given string.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.SplitCommandLineIntoArguments(System.String,System.Boolean)">
            <summary>
            Split a command line by the same rules as Main would get the commands.
            </summary>
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.Split(System.String,System.Func{System.Char,System.Boolean})">
            <summary>
            Split a string, based on whether "splitHere" returned true on each character.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.CondenseDoubledBackslashes(System.String)">
            <summary>
            Condense double backslashes that precede a quotation mark to single backslashes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.AddBackslashes(System.Text.StringBuilder,System.Int32)">
            <summary>
            Add "count" backslashes to a StringBuilder. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.ParseSeparatedStrings(System.String,System.Char[],System.StringSplitOptions)">
            <summary>
            Split a string by a set of separators, taking quotes into account.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.TryParseUInt64(System.String,System.UInt64@)">
            <summary>
            Tries to parse a UInt64 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCommandLineParser.TryParseUInt16(System.String,System.UInt16@)">
            <summary>
            Tries to parse a UInt16 from string in either decimal, octal or hex format.
            </summary>
            <param name="value">The string value.</param>
            <param name="result">The result if parsing was successful.</param>
            <returns>true if parsing was successful, otherwise false.</returns>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommandLineSplitter">
            <remarks>
            Rules for command line parsing, according to MSDN:
            
            Arguments are delimited by white space, which is either a space or a tab.
             
            A string surrounded by double quotation marks ("string") is interpreted 
            as a single argument, regardless of white space contained within. 
            A quoted string can be embedded in an argument.
             
            A double quotation mark preceded by a backslash (\") is interpreted as a 
            literal double quotation mark character (").
             
            Backslashes are interpreted literally, unless they immediately precede a 
            double quotation mark.
             
            If an even number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is interpreted as a string delimiter.
             
            If an odd number of backslashes is followed by a double quotation mark, 
            one backslash is placed in the argv array for every pair of backslashes, 
            and the double quotation mark is "escaped" by the remaining backslash, 
            causing a literal double quotation mark (") to be placed in argv.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.Compilation.CommonForEachStatementInfo">
            <summary>
            Structure containing all semantic information about a for each statement.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Compilation.CommonForEachStatementInfo.#ctor(Roslyn.Compilers.Common.IMethodSymbol,Roslyn.Compilers.Common.IMethodSymbol,Roslyn.Compilers.Common.IPropertySymbol,Roslyn.Compilers.Common.IMethodSymbol)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Compilers.Compilation.CommonForEachStatementInfo"/> structure.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Compilation.CommonForEachStatementInfo.GetEnumeratorMethod">
            <summary>
            Gets the &quot;GetEnumerator&quot; method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Compilation.CommonForEachStatementInfo.MoveNextMethod">
            <summary>
            Gets the &quot;MoveNext&quot; method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Compilation.CommonForEachStatementInfo.CurrentProperty">
            <summary>
            Gets the &quot;Current&quot; property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Compilation.CommonForEachStatementInfo.DisposeMethod">
            <summary>
            Gets the &quot;Dispose&quot; method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonMemberResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberResolutionKind.Applicable">
            <summary>
            The candidate member was accepted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberResolutionKind.UseSiteError">
            <summary>
            The candidate member was rejected because it is not supported by the language or cannot
            be used given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate member was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberResolutionKind.Worse">
            <summary>
            The candidate member was rejected because it was considered worse that another member.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonMemberResolutionResult`1">
            <summary>
            Represents the results of overload resolution for a single member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMemberResolutionResult`1.Member">
            <summary>
            The member considered during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMemberResolutionResult`1.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMemberResolutionResult`1.IsValid">
            <summary>
            Returns true if the compiler accepted this member as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonOverloadResolutionResult`1">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonOverloadResolutionResult`1.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonOverloadResolutionResult`1.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonOverloadResolutionResult`1.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonOverloadResolutionResult`1.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonEmitResult">
            <summary>
            The result of the CommonCompilation.Emit method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonEmitResult.Success">
            <summary>
            True if the compilation successfully produced an executable.
            If false then the diagnostics should include at least one error diagnostic
            indicating the cause of the failure.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonEmitResult.Diagnostics">
            <summary>
            A list of all the diagnostics associated with compilations. This include parse errors, declaration errors,
            compilation errors, and emitting errors.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonReflectionEmitResult.EntryPoint">
            <summary>
            Gets method information about the entrypoint of the emitted assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonReflectionEmitResult.IsUncollectible">
            <summary>
            Indicates whether the emitted assembly can be garbage collected.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSymbolInfo.Symbol">
            <summary>
            The symbol that was referred to by the syntax node, if any. Returns null if the given
            expression did not bind successfully to a single symbol. If null is returned, it may
            still be that case that we have one or more "best guesses" as to what symbol was
            intended. These best guesses are available via the CandidateSymbols property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSymbolInfo.CandidateSymbols">
            <summary>
            If the expression did not successfully resolve to a symbol, but there were one or more
            symbols that may have been considered but discarded, this property returns those
            symbols. The reason that the symbols did not successfully resolve to a symbol are
            available in the CandidateReason property. For example, if the symbol was inaccessible,
            ambiguous, or used in the wrong context.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSymbolInfo.CandidateReason">
            <summary>
             If the expression did not successfully resolve to a symbol, but there were one or more
             symbols that may have been considered but discarded, this property describes why those
             symbol or symbols were not considered suitable.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypeInfo.ImplicitConversion">
            <summary>
            If the expression underwent an implicit conversion, return information about that
            conversion. Otherwise, returns an identity conversion.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CompilationStage">
            <summary>
            Represents the possible compilation stages for which it is possible to get diagnostics
            (errors).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.DebugInformationKind">
            <summary>
            Specifies the kind of debug information to be emitted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.DebugInformationKind.None">
            <summary>
            Emit no debug information.
            </summary>
            <remarks>
            Not specifying "/debug" command line switch or specifying "/debug-" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.Common.DebugInformationKind.PDBOnly">
            <summary>
            Emit PDB file only.
            </summary>
            <remarks>
            Specifying "/debug:pdbonly" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.Common.DebugInformationKind.Full">
            <summary>
            Emit full debugging information.
            </summary>
            <remarks>
            Specifying "/debug" or "/debug:full" or "/debug+" command line switch enforces this setting.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.SubsystemVersion">
            <summary>
            Represents subsystem version, see /subsystemversion command line 
            option for details and valid values.
            
            The following table lists common subsystem versions of Windows.
            
            Windows version             Subsystem version
              - Windows 2000                5.00
              - Windows XP                  5.01
              - Windows Vista               6.00
              - Windows 7                   6.01
              - Windows 8 Release Preview   6.02
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.Major">
            <summary>
            Major subsystem version
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.Minor">
            <summary>
            Minor subsystem version
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.None">
            <summary>
            Subsystem version not specified
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.Windows2000">
            <summary>
            Subsystem version: Windows 2000
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.WindowsXP">
            <summary>
            Subsystem version: Windows XP 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.WindowsVista">
            <summary>
            Subsystem version: Windows Vista
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.Windows7">
            <summary>
            Subsystem version: Windows 7
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SubsystemVersion.Windows8">
            <summary>
            Subsystem version: Windows 8
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SubsystemVersion.TryParse(System.String,Roslyn.Compilers.SubsystemVersion@)">
            <summary>
            Try parse subsystem version in "x.y" format. Note, no spaces are allowed in string representation.
            </summary>
            <param name="str">String to parse</param>
            <param name="version">the value if successfully parsed or None otherwise</param>
            <returns>true if parsed successfully, false otherwise</returns>
        </member>
        <member name="M:Roslyn.Compilers.SubsystemVersion.Create(System.Int32,System.Int32)">
            <summary>
            Create a new instance of subsystem version with specified major and minor values.
            </summary>
            <param name="major">major subsystem version</param>
            <param name="minor">minor subsystem version</param>
            <returns>subsystem version with provided major and minor</returns>
        </member>
        <member name="M:Roslyn.Compilers.SubsystemVersion.Default(Roslyn.Compilers.OutputKind)">
            <summary>
            Subsystem version default for output kind specified
            </summary>
            <param name="outputKind">Output kind</param>
            <returns>Subsystem version</returns>
        </member>
        <member name="P:Roslyn.Compilers.SubsystemVersion.IsValid">
            <summary>
            True if the syubsystem version has a valid value
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.AnyCPU">
            <summary>
            AnyCPU (default) compiles the assembly to run on any platform.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.x86">
            <summary>
            x86 compiles the assembly to be run by the 32-bit, x86-compatible common language runtime.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.x64">
            <summary>
            x64 compiles the assembly to be run by the 64-bit common language runtime on a computer that supports the AMD64 or EM64T instruction set.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.Itanium">
            <summary>
            Itanium compiles the assembly to be run by the 64-bit common language runtime on a computer with an Itanium processor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.AnyCPU32BitPreferred">
            <summary>
            Compiles your assembly to run on any platform. Your application runs in 32-bit mode on systems that support both 64-bit and 32-bit applications.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Platform.Arm">
            <summary>
            Compiles your assembly to run on a computer that has an Advanced RISC Machine (ARM) processor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.EnumBounds.RequiresAmdInstructionSet(Roslyn.Compilers.Platform)">
            <summary>
            Gets a value indicating whether the options require the AMD instruction set.
            </summary>
            <value>
              <c>true</c> if the options require the AMD instruction set; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Roslyn.Compilers.Common.SpeculativeBindingOption">
            <summary>
            Describes the kind of binding to be performed in one of the SemanticModel
            speculative binding methods.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SpeculativeBindingOption.BindAsExpression">
            <summary>
            Binds the given expression using the normal expression binding rules
            that would occur during normal binding of expressions.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SpeculativeBindingOption.BindAsTypeOrNamespace">
            <summary>
            Binds the given expression as a type or namespace only. If this option
            is selected, then the given expression must derive from TypeSyntax.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.SymbolId">
            <summary>
            A SymbolId is a lightweight identifier for a symbol that can be used to resolve the "same"
            symbol across compilations.  Different symbols have different concepts of "same-ness".
            Same-ness is recursively defined as follows.
            
            1) Two IArraySymbol's are the "same" if they have the "same" element type and the same rank.
            2) Two IAssemblySymbol's are the "same" if they have the same <see cref="P:Roslyn.Compilers.Common.ISymbol.Name"/>.
            3) Two IEventSymbol's are the "same" if they have the "same" containing type and the same
               <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>.
            4) Two IMethodSymbol's are the "same" if they have the "same" containing type, the same
               <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>, the same <see cref="P:Roslyn.Compilers.Common.IMethodSymbol.Arity"/>, the "same" <see cref="P:Roslyn.Compilers.Common.IMethodSymbol.TypeArguments"/>, and have same parameter types and <see cref="P:Roslyn.Compilers.Common.IParameterSymbol.RefKind"/>.
            5) Two IModuleSymbol's are the "same" if they have the same <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/> and
               the "same" containing IAssemblySymbol.
            6) Two INamedTypeSymbol's are the "same" if they have "same" containing symbol, the same
               <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>, the same <see cref="P:Roslyn.Compilers.Common.INamedTypeSymbol.Arity"/> and the "same"
               <see cref="P:Roslyn.Compilers.Common.INamedTypeSymbol.TypeArguments"/>.
            7) Two INamespaceSymbol's are the "same" if they have the "same" containing symbol and the
               same <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>.  If the INamespaceSymbol is the global namespace for a
               compilation (and thus does not have a containing symbol) then it will only match another
               global namespace of another compilation.
            8) Two IParameterSymbol's are the "same" if they have the "same" containing symbol and the
               <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>.
            9) Two IPointerTypeSymbol's are the "same" if they have the "same" <see cref="P:Roslyn.Compilers.Common.IPointerTypeSymbol.PointedAtType"/>. 
            10) Two IPropertySymbol's are the "same" if they have the "same" containing type, the same
               <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>,  and have same parameter types and <see cref="P:Roslyn.Compilers.Common.IParameterSymbol.RefKind"/>.
            11) Two ITypeParameterSymbol's are the "same" if they have the "same" containing symbol and
                the <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>.
            12) Two IFieldSymbol's are the "same" if they have the "same" containing symbol and the <see cref="P:Roslyn.Compilers.Common.ISymbol.MetadataName"/>.
                
            A SymbolId cannot be obtained for ILabelSymbol's, ILocalSymbol's or IRangeVariableSymbol's.
            A SymbolID for an IAliasSymbol will <see cref="M:Roslyn.Compilers.Common.SymbolId.Resolve(Roslyn.Compilers.Common.CommonCompilation,System.Boolean)"/> back to the ISymbol for
            the <see cref="P:Roslyn.Compilers.Common.IAliasSymbol.Target"/>.
            
            Due to issues arising from errors and ambiguity, it's possible for a SymbolId to resolve to
            multiple symbols.  For example, in the following type:
            
            class C
            {
               int Foo();
               bool Foo();
            }
            
            The SymbolId for both Foo methods will be the same.  The SymbolId will then resolve to both
            methods.
            
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.SymbolId.Create(Roslyn.Compilers.Common.ISymbol)">
            <summary>
            This entry point should only be called from the actual Symbol classes.  It should not be
            used internally inside this type.  Instead, any time we need to get the SymbolID for a
            related symbol (i.e. the containing namespace of a namespace) we should call
            GetOrCreate.  The benefit of this is twofold.  First of all, it keeps the size of the
            SymbolID small by allowing up to reuse parts we've already created.  For example, if we
            have the SymbolID for "Foo(int,int)", then we will reuse the SymbolIDs for both "int"s.
            Second, this allows us to deal with the recursive nature of MethodSymbols and
            TypeParameterSymbols.  Specifically, a MethodSymbol is defined by its signature.  However,
            it's signature may refer to type parameters of that method.  Unfortunately, the type
            parameters depend on their containing method.
            
            For example, if there is Foo&lt;T&gt;(T t), then we must avoid the situation where we:
            1) try to get the symbol ID for the type parameter T, which in turn
            2) tries to get the symbol ID for the method Foo, which in turn
            3) tries to get the symbol IDs for the parameter types, which in turn
            4) tries to get the symbol ID for the type parameter T, which leads back to 1 and
               infinitely loops.
            
            In order to break this circularity we do not create the SymbolIDs for a method's type
            parameters directly in the visitor.  Instead, we create the SymbolID for the method
            itself.  When the MethodSymbolId is created it will directly instantiate the SymbolIDs
            for the type parameters, and directly assign the type parameter's method ID to itself.
            It will also then directly store the mapping from the type parameter to its SymbolID in
            the visitor cache.  Then when we try to create the symbol IDs for the parameter types,
            any reference to the type parameters can be found in the cache.
            
            It is for this reason that it is essential that all calls to get related symbol IDs goes
            through GetOrCreate and not Create.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.SymbolId.Equals(Roslyn.Compilers.Common.SymbolId,Roslyn.Compilers.Common.SymbolId.ComparisonOptions)">
            <summary>
            When comparing symbols we need to handle recursion between method type parameters and
            methods.  For example, if we have two methods with the signature Foo&lt;T&gt;(T t) and we
            try to test for equality we must avoid the situation where we:
            
            1) First test if the methods are the same, which will in turn
            2) test if the method's parameter types are the same, which will in turn
            3) test if the type parameters are the same, which will in turn
            4) test if the methods are the same, which causes infinite recursion.
            
            To avoid this we distinguish the cases where we're testing if two type parameters
            actually refer to the same thing, versus type parameters being referenced by parameters.
            For example, if we have:
            
            Foo&lt;T&gt;(T t) 
            Bar&lt;T&gt;(T t) 
            
            then clearly the type parameter T in Foo&lt;T&gt; is different from the type parameter T
            in Bar&lt;T&gt;.  When testing these type parameters for equality we *will* test to see
            if they have the same parent.  This will end up returning false, and so we will consider
            them different.
            
            However, when we are testing if two signatures are the same, if we hit a method type
            parameter then we only need to compare by metadataName.  That's because we know we'll
            already have checked if the method and it's parents are the same, so we don't need to
            recurse through them again.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.IMessageSerializable">
            <summary>
            Implements error message specific serialization.
            </summary>
            <remarks>
            Implement on classes that are not serializable in general yet 
            whose instances can be used as error message arguments.
            
            The serialization result must be culture agnostic.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.IMessageSerializable.ToSerializable">
            <summary>
            Returns a serializable culture-agnostic representation of the content.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DocumentationProvider">
            <summary>
            A class used to provide XML documentation to the compiler for members from metadata. A
            custom implementation of this class should be returned from a DocumentationResolver to provide XML
            documentation comments from custom caches or locations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationProvider.GetDocumentationForSymbol(System.String,System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Fetches a documentation comment for the given member ID.
            </summary>
            <param name="documentationMemberID">The documentation member ID of the item to fetch.</param>
            <param name="preferredCulture">The preferred culture to receive a comment in. Null if
            there is no preference. This is a preference only, and providers may choose to provide
            results from another culture if the preferred culture was unavailable.</param>
            <param name="cancellationToken">A cancellation token for the search.</param>
            <returns>A DocumentationComment.</returns>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationProvider.Equals(System.Object)">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            Equals (and GetHashCode) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationProvider.GetHashCode">
            <summary>
            DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.
            Hence, if multiple instances can represent the same documentation, it is imperative that
            GetHashCode (and Equals) be overridden to capture this fact.  Otherwise, it is possible to end
            up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DocumentationProvider.NullDocumentationProvider">
            <summary>
            A trivial DocumentationProvider which never returns documentation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.GetLocalScopes(Microsoft.Cci.IMethodBody)">
            <summary>
            Returns zero or more local (block) scopes into which the CLR IL operations in the given method body is organized.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.GetNamespaceScopes(Microsoft.Cci.IMethodBody)">
            <summary>
            Returns zero or more namespace scopes into which the namespace type containing the given method body has been nested.
            These scopes determine how simple names are looked up inside the method body. There is a separate scope for each dotted
            component in the namespace type name. For istance namespace type x.y.z will have two namespace scopes, the first is for the x and the second
            is for the y.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.GetIteratorScopes(Microsoft.Cci.IMethodBody)">
            <summary>
            Returns zero or more local (block) scopes, each defining an IL range in which an iterator local is defined.
            The scopes are returned for the MoveNext method of the object returned by the iterator method.
            The index of the scope corresponds to the index of the local.  Specifically local scope i corresponds
            to the local stored in a field named &lt;localName&gt;5__i of the class used to store the local values in
            between calls to MoveNext, where localName is the original name of the local variable.  For example, if
            the first local to be moved into the class is named "xyzzy", it will be stored in a field named
            "&lt;xyzzy&gt;5__1", and the ILocalScope returned from this method at index 1 (i.e. the second one) will
            have the scope information for where that variable is in scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.GetConstantsInScope(Microsoft.Cci.ILocalScope)">
            <summary>
            Returns zero or more local constant definitions that are local to the given scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.GetVariablesInScope(Microsoft.Cci.ILocalScope)">
            <summary>
            Returns zero or more local variable definitions that are local to the given scope.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ILocalScopeProvider.IteratorClassName(Microsoft.Cci.IMethodBody)">
            <summary>
            If the body was written as an iterator, returns the name of the (nested)
            type that implements the iterator's state machine.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ModulePropertiesForSerialization">
            <summary>
            This class is used to store the module serialization properties for a compilation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceLocationProvider.GetPrimarySourceLocationsFor(Microsoft.Cci.SequencePoint)">
            <summary>
            Return zero or more locations in primary source documents that correspond to one or more of the given derived (non primary) document locations.
            </summary>
            <param name="locations">Zero or more locations in documents that have been derived from one or more source documents.</param>
        </member>
        <member name="M:Microsoft.Cci.ISourceLocationProvider.GetSourceNameFor(Microsoft.Cci.ILocalDefinition,System.Boolean@)">
            <summary>
            Returns the source name of the given local definition, if this is available. 
            Otherwise returns the value of the Name property and sets isCompilerGenerated to true.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Roslyn.Compilers.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items. 
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\mymachine" (UNC).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ThreeState">
            <summary>
            Represent an optional bool as a single byte.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.WeakList`1.WeakCount">
            <summary>
            Returns the number of weak references in this list. 
            Note that some of them might not point to live objects anymore.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Internal.MetadataTypeName">
            <summary>
            Helper structure to incapsulate/cache various information about metadata name of a type and 
            name resolution options.
            Also, allows us to stop using strings in the APIs that accept only metadata names, 
            making usage of them less bug prone.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.fullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.namespaceName">
            <summary>
            Namespace name for top level types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.typeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.unmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.inferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.useCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.forcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If forcedArity >= 0 and useCLSCompliantNameArityEncoding, lookup may
            fail because forcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Internal.MetadataTypeName.namespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.FullName">
            <summary>
            Full metadata name of a type, includes namespace name for top level types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.NamespaceName">
            <summary>
            Namespace name for top level types, empty string for nested types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.TypeName">
            <summary>
            Name of the type without namespace prefix, but possibly with generic arity mangling present.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.UnmangledTypeName">
            <summary>
            Name of the type without namespace prefix and without generic arity mangling.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.InferredArity">
            <summary>
            Arity of the type inferred based on the name mangling. It doesn't have to match the actual
            arity of the type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.IsMangled">
            <summary>
            Does name include arity mangling suffix.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.UseCLSCompliantNameArityEncoding">
            <summary>
            While resolving the name, consider only types following 
            CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same
            emitted name and arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.ForcedArity">
            <summary>
            While resolving the name, consider only types with this arity.
            (-1) means allow any arity.
            If ForcedArity >= 0 and UseCLSCompliantNameArityEncoding, lookup may
            fail because ForcedArity doesn't match the one encoded in the name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Internal.MetadataTypeName.NamespaceSegments">
            <summary>
            Individual parts of qualified namespace name.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.AssemblyMetadata">
            <summary>
            Represents an immutable assembly metadata.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Metadata">
            <summary>
            Represents immutable assembly or module metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.#ctor(Roslyn.Compilers.ReadOnlyArray{System.Byte})">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="peImage">
            Manifest module image.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.#ctor(Roslyn.Compilers.ModuleMetadata)">
            <summary>
            Creates a single-module assembly.
            </summary>
            <param name="module">
            Manifest module.
            
            <see cref="T:Roslyn.Compilers.AssemblyMetadata"/> takes ownership of the <see cref="T:Roslyn.Compilers.ModuleMetadata"/> object passed in 
            and disposes it when it is itself <see cref="M:Roslyn.Compilers.AssemblyMetadata.Dispose"/>d.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.#ctor(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.ModuleMetadata})">
            <summary>
            Creates a multi-module assembly.
            </summary>
            <param name="modules">
            Modules comprising the assembly. The first module is the manifest module of the assembly.
            
            <see cref="T:Roslyn.Compilers.AssemblyMetadata"/> takes ownership of <see cref="T:Roslyn.Compilers.ModuleMetadata"/> objects passed in and 
            disposes them when it is itself <see cref="M:Roslyn.Compilers.AssemblyMetadata.Dispose"/>d.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="modules"/> is null or contains null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="modules"/> is empty or contains a module that doesn't own its image (was created via <see cref="M:MetadataModule.Copy"/>).</exception>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.#ctor(System.String)">
            <summary>
            Finds all modules of an assembly on a specified path and builds an instance of <see cref="T:Roslyn.Compilers.AssemblyMetadata"/> that represents them.
            </summary>
            <exception cref="T:Roslyn.Compilers.MetadataReader.MetadataReaderException"/>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.Copy">
            <summary>
            Creates a shallow copy of contained modules and wraps them into a new instance of <see cref="T:Roslyn.Compilers.AssemblyMetadata"/>.
            </summary>
            <remarks>
            The resulting copy shares the metadata images and metadata information read from them with the original.
            It doesn't own the underlying metadata images and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.Dispose">
            <summary>
            Disposes all modules contained in the assembly.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyMetadata.IsValidAssembly">
            <summary>
            Checks if the first module has a single row in Assembly table and that all other modules have none.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyMetadata.Modules">
            <summary>
            Modules comprising this assembly. The first module is the manifest module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyMetadata.ManifestModule">
            <summary>
            The manifest module of the assembly.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ReferenceDirective">
            <summary>
            Represents the value of #r reference along with its source location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.UnresolvedMetadataReference">
            <summary>
            Represents a metadata reference that can't be resolved.
            </summary>
            <remarks>
            For error reporting only, can't be used to reference a metadata file.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.MetadataReference">
            <summary>
            Represents metadata image reference.
            </summary>
            <remarks>
            Represents a logical location of the image, not the content of the image. 
            The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReference.GetAssemblyName">
            <summary>
            Returns a simple name of the assembly, or null if the metadata reference doesn't represent a valid assembly.
            </summary>
            <remarks>
            Unlike <see cref="M:Roslyn.Compilers.MetadataReference.GetAssemblyIdentity"/> this call doesn't ever trigger custom attribute analysis.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReference.GetAssemblyIdentity">
            <summary>
            Returns the assembly identity of this reference, or null if it doesn't have an identity 
            (the reference is a module or <see cref="T:Roslyn.Compilers.UnresolvedMetadataReference"/>).
            </summary>
            <returns>The assembly identity.</returns>
            <remarks>
            If the reference is a <see cref="T:Roslyn.Compilers.Common.CommonCompilationReference"/> this might trigger assembly binding and custom attribute analysis.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReference.CreateAssemblyReference(System.String)">
            <summary>
            Creates an assembly metadata reference given an assembly display name.
            </summary>
            <param name="displayName">The display name of the assembly.</param>
            <returns>Resolved metadata reference.</returns>
            <remarks>
            Uses <see cref="F:Roslyn.Compilers.FileResolver.Default"/> to find <paramref name="displayName"/> in a GAC
            and <see cref="F:Roslyn.Compilers.MetadataFileProvider.Default"/> to create the resulting metadata reference.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Assembly with the given name <paramref name="displayName"/> can't be found.</exception>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReference.IsUnresolved">
            <summary>
            Returns true if this reference is an unresolved reference.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.MetadataShadowCopy">
            <summary>
            Represents a shadow copy of an assembly or a standalone module.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.MetadataShadowCopy.PrimaryModule">
            <summary>
            Assembly manifest module copy or a standalone module copy.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.MetadataShadowCopy.DocumentationFile">
            <summary>
            Documentation file copy or null if there is none.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.ShadowCopy">
            <summary>
            Represents a shadow copy of a single file.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplay.AbstractSymbolDisplayVisitor.AddNonNullConstantValue(Roslyn.Compilers.Common.ITypeSymbol,System.Object)">
            <summary>
            Append a default argument (i.e. the default argument of an optional parameter).
            Assumed to be non-null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplay.AbstractSymbolDisplayVisitor.IsFlagsEnum(Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            Check if the given type is an enum with System.FlagsAttribute.
            </summary>
            <remarks>
            TODO: Can/should this be done using WellKnownAttributes?
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.AttributeUsageInfo.Default">
            <summary>
            Default attribute usage for attribute types:
            (a) Valid targets: AttributeTargets.All
            (b) AllowMultiple: false
            (c) Inherited: true
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonParameterEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.EarlyWellKnownAttributeData">
            <summary>
            Base class for storing information decoded from early well-known custom attributes.
            </summary>
            <remarks>
            CONSIDER: Should we remove this class and let the sub-classes derived from WellKnownAttributeData?
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.WellKnownAttributeData">
            <summary>
            Base class for storing information decoded from well-known custom attributes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3">
            <summary>
            Contains common arguments to Symbol.DecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.lazyDecodeData">
            <summary>
            Object to store the decoded data from bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.AttributeSyntax">
            <summary>
            Syntax of the attribute to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.Attribute">
            <summary>
            Bound attribute to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.Index">
            <summary>
            The index of the attribute in the list of attributes to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.AttributesCount">
            <summary>
            Total count of attributes to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.Diagnostics">
            <summary>
            Diagnostic bag.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.DecodeWellKnownAttributeArguments`3.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4">
            <summary>
            Contains common arguments to Symbol.EarlyDecodeWellKnownAttribute method in both the language compilers.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.lazyDecodeData">
            <summary>
            Object to store the decoded data from early bound well-known attributes.
            Created lazily only when some decoded data needs to be stored, null otherwise.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.GetOrCreateData``1">
            <summary>
            Gets or creates the decoded data object.
            </summary>
            <remarks>
            This method must be called only when some decoded data will be stored into it subsequently.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData">
            <summary>
            Returns true if some decoded data has been stored into <see cref="F:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.lazyDecodeData"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.DecodedData">
            <summary>
            Gets the stored decoded data.
            </summary>
            <remarks>
            Assumes <see cref="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.HasDecodedData"/> is true.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.Binder">
            <summary>
            Binder to bind early well-known attributes.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.AttributeType">
            <summary>
            Bound type of the attribute to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.AttributeSyntax">
            <summary>
            Syntax of the attribute to decode.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.EarlyDecodeWellKnownAttributeArguments`4.SymbolPart">
            <summary>
            Specific part of the symbol to which the attributes apply, or AttributeLocation.None if the attributes apply to the symbol itself.
            Used e.g. for return type attributes of a method symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonAttributeData.IsTargetEarlyAttribute(Roslyn.Compilers.Common.INamedTypeSymbol,System.Int32,Roslyn.Compilers.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attributeArgCount.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonAttributeData.GetConstructorArgument``1(System.Int32,Roslyn.Compilers.SpecialType)">
            <summary>
            Returns the value of a constructor argument as type <typeparamref name="T"/>.
            Throws if no constructor argument exists or the argument cannot be converted to the type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonAttributeData.DecodeNamedArgument``1(System.String,Roslyn.Compilers.SpecialType,``0)">
            <summary>
            Returns named attribute argument with the given <paramref name="name"/> as type <typeparamref name="T"/>.
            If there is more than one named argument with this name, it returns the last one.
            If no named argument is found then the <paramref name="defaultValue"/> is returned.
            </summary>
            <param name="name">The metadata property or field name. This name is case sensitive (both VB and C#).</param>
            <param name="specialType">SpecialType of the named argument.</param>
            <param name="defaultValue">Default value for the named argument.</param>
            <remarks>
            For user defined attributes VB allows duplicate named arguments and uses the last value.
            Dev11 reports an error for pseudo-custom attributes when emitting metadata. We don't.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonAttributeData.DecodeObsoleteAttribute(Roslyn.Compilers.Common.CommonCompilation)">
            <summary>
            Decode the arguments to ObsoleteAttribute. ObsoleteAttribute can have 0,1 or 2 arguments.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonAttributeData.AttributeClass">
            <summary>
            The attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonAttributeData.AttributeConstructor">
            <summary>
            The constructor on the attribute class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonAttributeData.ConstructorArguments">
            <summary>
            Constructor arguments on the attribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonAttributeData.NamedArguments">
            <summary>
            Named (property value) arguments on the attribute. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonEventEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonFieldEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonMethodEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonModuleWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ObsoleteAttributeData">
            <summary>
            Information decoded from ObsoleteAttribute.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ObsoleteAttributeData.IsError">
            <summary>
            True if an error should be thrown for the ObsoleteAttribute. Default is false in which case
            a warning is thrown.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ObsoleteAttributeData.Message">
            <summary>
            The message that will be shown when an error\warning is created for ObsoleteAttribute.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DllImportData">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPlatformInvokeInformation">
            <summary>
            Information that describes how a method from the underlying Platform is to be invoked.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.ModuleName">
            <summary>
            Module providing the method/field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.EntryPointName">
            <summary>
            Name of the method providing the implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPlatformInvokeInformation.Flags">
            <summary>
            Flags that determine marshalling behavior.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.ModuleName">
            <summary>
            Module name. Null if value specified in the attribute is not valid.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.EntryPointName">
            <summary>
            Name of the native entry point or null if not specified (the effective name is the same as the name of the target method).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.ExactSpelling">
            <summary>
            Controls whether the <see cref="P:CharacterSet"/> field causes the common language runtime 
            to search an unmanaged DLL for entry-point names other than the one specified.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.CharacterSet">
            <summary>
            Indicates how to marshal string parameters and controls name mangling.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.SetLastError">
            <summary>
            Indicates whether the callee calls the SetLastError Win32 API function before returning from the attributed method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.CallingConvention">
            <summary>
            Indicates the calling convention of an entry point.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.BestFitMapping">
            <summary>
            Enables or disables best-fit mapping behavior when converting Unicode characters to ANSI characters.
            Null if not specified (the setting for the containing type or assembly should be used, <see cref="T:System.Runtime.InteropServices.BestFitMappingAttribute"/>).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DllImportData.ThrowOnUnmappableCharacter">
            <summary>
            Enables or disables the throwing of an exception on an unmappable Unicode character that is converted to an ANSI "?" character.
            Null if not specified.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonEventWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on an event.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonPropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonPropertyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonReturnTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method return value.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonReturnTypeWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the return value.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SecurityWellKnownAttributeData">
            <summary>
            Information decoded from security attributes, i.e. attributes derived from well-known SecurityAttribute, applied on a method/type/assembly.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SecurityWellKnownAttributeData.GetSecurityAttributes``1(Roslyn.Compilers.ReadOnlyArray{``0})">
            <summary>
            Used for retreiving applied source security attributes, i.e. attributes derived from well-known SecurityAttribute.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonTypeEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TypeLayout">
            <summary>
            Type layout information.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TypeLayout.Kind">
            <summary>
            Layout kind (Layout flags in metadata).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TypeLayout.Alignment">
            <summary>
            Field alignment (PackingSize field in metadata).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TypeLayout.Size">
            <summary>
            Size of the type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.ItemInternal(Roslyn.Compilers.Common.IBaseSyntaxNodeExt,System.Int32)">
            <summary>
            internal indexer that does not verify index.
            Used when caller has already ensured that index is within bounds.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.Reversed.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.Reversed.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.Reversed.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonChildSyntaxList.Reversed.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonChildSyntaxList.Reversed.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.EnumeratorImpl.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.EnumeratorImpl.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonChildSyntaxList.EnumeratorImpl.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonChildSyntaxList.EnumeratorImpl.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonChildSyntaxList.EnumeratorImpl.System#Collections#IEnumerator#Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
            The element in the collection at the current position of the enumerator.
              </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTriviaList.First">
            <summary>
            Returns the first CommonSyntaxTrivia in the list.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTriviaList.FirstOrDefault">
            <summary>
            Returns the first CommonSyntaxTrivia in the list or the default value of CommonSyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTriviaList.Last">
            <summary>
            Returns the last CommonSyntaxTrivia in the list. May throw ArgumentOutOfRange exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTriviaList.LastOrDefault">
            <summary>
            Returns the last CommonSyntaxTrivia in the list or the default value of CommonSyntaxTrivia if the list has no items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTriviaList.Any">
            <summary>
            Does this list have any items.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxTriviaList.Reversed">
            <summary>
            reversed enumerable
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.SyntaxWalkerDepth">
            <summary>
            enum to specify how deep walker should decent into
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SyntaxWalkerDepth.Node">
            <summary>
            descend into only nodes
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SyntaxWalkerDepth.Token">
            <summary>
            descend into nodes and tokens
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SyntaxWalkerDepth.Trivia">
            <summary>
            descend into nodes, tokens and trivia
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.SyntaxWalkerDepth.StructuredTrivia">
            <summary>
            descend into everything
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SyntaxRemoveOptions.KeepNoTrivia">
            <summary>
            None of the trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SyntaxRemoveOptions.KeepExteriorTrivia">
            <summary>
            The leading and trailing trivia associated with the node or token is kept.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SyntaxRemoveOptions.KeepUnbalancedDirectives">
            <summary>
            Any directives that would become unbalanced are kept.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SyntaxRemoveOptions.KeepDirectives">
            <summary>
            All directives are kept
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.VbStringDisplay">
            <summary>
            Implements VB string escaping. Uses iterators and thus it's implemented in shared code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataImageReference">
            <summary>
            Represents an in-memory Portable-Executable image.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.PortableExecutableReference">
            <summary>
            Reference to metadata stored in the standard ECMA-335 metadata format.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.PortableExecutableReference.GetDocumentationProvider">
            <summary>
            Returns XML doc comments provider for the reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.PortableExecutableReference.CreateMetadata">
             <summary>
             Get metadata for the PE file.
             </summary>
             <exception cref="T:System.BadImageFormatException">If the PE image format is invalid.</exception>
             <exception cref="T:System.SystemException">Metadata image can't be read.</exception>
             <remarks>
             Called when the compiler needs to read the reference metadatada. The listed exceptions are caught and converted to compilation diagnostics.
             Any other exception is considered an unexpected error in the implementation and is not caught.
            
             <see cref="T:Roslyn.Compilers.ModuleMetadata"/> may cache information decoded from the PE image.
             Reusing <see cref="T:Roslyn.Compilers.Metadata"/> instances accross metadata references will result in better performance.
             
             This method is called at most once per metadata referenceand its result is cached on the reference object.
             </remarks>
        </member>
        <member name="M:Roslyn.Compilers.PortableExecutableReference.GetMetadata">
            <summary>
            Creates or gets cached metadata for the PE file.
            Might throw an exception for invalid metadata files.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.PortableExecutableReference.GetMetadata(Roslyn.Compilers.Common.CommonMessageProvider,Roslyn.Compilers.Common.CommonLocation,Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Creates or gets cached metadata for the PE file.
            If any of the following exceptions: <see cref="T:System.BadImageFormatException"/>, <see cref="T:System.IO.FileNotFoundException"/>, <see cref="T:System.IO.IOException"/>,
            are thrown while reading the metadata file, the exception is caught and an appropriate diagnostic stored in <paramref name="diagnostics"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.PortableExecutableReference.LoadMetadata``1(System.Boolean,Roslyn.Compilers.Common.CommonMessageProvider,Roslyn.Compilers.Common.CommonLocation,System.String,System.Func{``0},System.Func{Roslyn.Compilers.Common.CommonDiagnostic,``0})">
            <summary>
            Handles exceptions caused by metadata loading in uniform way and returns a diagnostics, 
            returns null if the exception was handled.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.PortableExecutableReference.Display">
            <summary>
            Path or name used in error messages to identity the reference.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.PortableExecutableReference.FullPath">
            <summary>
            Full path describing the location of the metadata, or null if the metadata have no location.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataImageReference.#ctor(Roslyn.Compilers.ReadOnlyArray{System.Byte},Roslyn.Compilers.DocumentationProvider,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to a single-module assembly image.
            </summary>
            <param name="assemblyImage">Read-only assembly image.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="alias">Reference alias.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">Optional full path used for reference comparison when used in compilation. The file doesn't need to exist.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataImageReference.#ctor(Roslyn.Compilers.ModuleMetadata,Roslyn.Compilers.DocumentationProvider,System.String,System.String)">
            <summary>
            Creates a reference to a standalone module image.
            </summary>
            <param name="metadata">Metadata for the standalone module.</param>
            <param name="fullPath">
            Optional full path used for reference comparison when used in compilation. 
            The file doesn't need to exist.
            If <paramref name="metadata"/> represents a memory mapped file and this parameter is not specified the path to the memory mapped file is used.
            </param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataImageReference.#ctor(Roslyn.Compilers.AssemblyMetadata,Roslyn.Compilers.DocumentationProvider,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Creates a reference to an assembly or a module image. The assembly can comprise multiple modules.
            </summary>
            <param name="metadata">Assembly or module metadata.</param>
            <param name="documentation">Provides XML documentation for symbol found in the reference.</param>
            <param name="alias">Reference alias.</param>
            <param name="embedInteropTypes">True if interop types contained in the reference should be embedded to the compilation that uses the reference.</param>
            <param name="fullPath">
            Optional full path used for reference comparison when used in compilation. 
            The file doesn't need to exist.
            If the manifest module of the assembly is a memory mapped file and this parameter is not specified the path to the memory mapped file is used.
            </param>
            <param name="display">Display string for error reporting.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataImageReference.WithAlias(System.String)">
            <summary>
            Returns an instance of the reference with specified alias.
            </summary>
            <param name="alias">The new alias for the reference.</param>
            <exception cref="T:System.ArgumentException">Alias is invalid for the metadata kind.</exception> 
        </member>
        <member name="M:Roslyn.Compilers.MetadataImageReference.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns an instance of the reference with specified interop types embedding.
            </summary>
            <param name="value">The new value for <see cref="P:Roslyn.Compilers.MetadataReferenceProperties.EmbedInteropTypes"/>.</param>
            <exception cref="T:System.ArgumentException">Interop types can't be embedded from modules.</exception> 
        </member>
        <member name="T:Roslyn.Compilers.MetadataFileReference">
            <summary>
            Represents a metadata image with a file path.
            </summary>
            <remarks>
            The actual image doesn't need to be stored in a physical file on disk. It can be loaded in memory.
            Unlike <see cref="T:Roslyn.Compilers.MetadataImageReference"/>, <see cref="T:Roslyn.Compilers.MetadataFileReference"/> represents an image with a path.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.ModuleMetadata">
            <summary>
            Represents an immutable assembly metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ModuleMetadata.#ctor(Roslyn.Compilers.ReadOnlyArray{System.Byte})">
            <summary>
            Create metadata module from a byte array.
            </summary>
            <param name="peImage">Read-only PE image.</param>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
        </member>
        <member name="M:Roslyn.Compilers.ModuleMetadata.#ctor(System.String)">
            <summary>
            Memory maps the given file.
            </summary>
            <param name="fullPath">Absolute path to the file to map.</param>
            <remarks>
            The file remains mapped (and read-locked) until this object is disposed.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not a valid absolute path.</exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
            <exception cref="T:System.BadImageFormatException">The PE image format is invalid.</exception>
            <exception cref="T:System.IO.IOException">Error reading the file.</exception>
        </member>
        <member name="M:Roslyn.Compilers.ModuleMetadata.Copy">
            <summary>
            Creates a shallow copy of this object.
            </summary>
            <remarks>
            The resulting copy shares the metadata image and metadata information read from it with the original.
            It doesn't own the underlying metadata image and is not responsible for its disposal.
            
            This is used, for example, when a metadata cache needs to return the cached metadata to its users
            while keeping the ownership of the cached metadata object.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.ModuleMetadata.Dispose">
            <summary>
            Frees memory and handles allocated for the module.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ModuleMetadata.GetContent">
            <summary>
            Returns read-only PE image.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ModuleMetadata.FullPath">
            <summary>
            Full path of the module if the metadata is memory-mapped from a file, null otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ModuleMetadata.Name">
            <summary>
            Name of the module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataImageKind">
            <summary>
            The kind of metadata a PE file image contains.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataImageKind.Assembly">
            <summary>
            The PE file is an assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataImageKind.Module">
            <summary>
            The PE file is a module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataReferenceProperties">
            <summary>
            Information about a metadata reference.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReferenceProperties.Module">
            <summary>
            Default properties for a module reference.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReferenceProperties.Assembly">
            <summary>
            Default properties for an assembly reference.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReferenceProperties.#ctor(Roslyn.Compilers.MetadataImageKind,System.String,System.Boolean)">
            <summary>
            Initializes reference properties.
            </summary>
            <param name="kind">The image kind - assembly or module.</param>
            <param name="alias">Assembly alias. Can't be set for a module.</param>
            <param name="embedInteropTypes">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReferenceProperties.WithAlias(System.String)">
            <summary>
            Returns <see cref="T:Roslyn.Compilers.MetadataReferenceProperties"/> with <see cref="P:Alias"/> set to specified value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <see cref="P:Kind"/> is <see cref="F:Roslyn.Compilers.MetadataImageKind.Module"/>, as modules can't be aliased.
            </exception>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReferenceProperties.WithEmbedInteropTypes(System.Boolean)">
            <summary>
            Returns <see cref="T:Roslyn.Compilers.MetadataReferenceProperties"/> with <see cref="P:EmbedInteropTypes"/> set to specified value.
            </summary>
            <exception cref="T:System.ArgumentException"><see cref="P:Kind"/> is <see cref="F:Roslyn.Compilers.MetadataImageKind.Module"/>, as interop types can't be embedded from modules.</exception>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReferenceProperties.Kind">
            <summary>
            The image kind (assembly or module) the reference refers to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReferenceProperties.Alias">
            <summary>
            Non-empty alias for the metadata reference, or null.
            </summary>
            <remarks>
            In C# this alias can be used in "extern alias" syntax to disambiguate type names. 
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReferenceProperties.EmbedInteropTypes">
            <summary>
            True if interop types defined in the refernced metadata should be embedded into the compilation referencing the metadata.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ObjectReader">
            <summary>
            A class that reads both primitive values and non-cyclical object graphs from a stream that was constructed using 
            the ObjectWriter class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadBoolean">
            <summary>
            Read a Boolean value from the stream. This value must have been written using ObjectWriter.WriteBoolean.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadByte">
            <summary>
            Read a Byte value from the stream. This value must have been written using ObjectWriter.WriteByte.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadChar">
            <summary>
            Read a Char value from the stream. This value must have been written using ObjectWriter.WriteChar.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadDecimal">
            <summary>
            Read a Decimal value from the stream. This value must have been written using ObjectWriter.WriteDecimal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadDouble">
            <summary>
            Read a Double value from the stream. This value must have been written using ObjectWriter.WriteDouble.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadSingle">
            <summary>
            Read a Single value from the stream. This value must have been written using ObjectWriter.WriteSingle.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadInt32">
            <summary>
            Read a Int32 value from the stream. This value must have been written using ObjectWriter.WriteInt32.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadInt64">
            <summary>
            Read a Int64 value from the stream. This value must have been written using ObjectWriter.WriteInt64.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadSByte">
            <summary>
            Read a SByte value from the stream. This value must have been written using ObjectWriter.WriteSByte.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadInt16">
            <summary>
            Read a Int16 value from the stream. This value must have been written using ObjectWriter.WriteInt16.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadUInt32">
            <summary>
            Read a UInt32 value from the stream. This value must have been written using ObjectWriter.WriteInt32.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadUInt64">
            <summary>
            Read a UInt64 value from the stream. This value must have been written using ObjectWriter.WriteUInt64.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadUInt16">
            <summary>
            Read a UInt16 value from the stream. This value must have been written using ObjectWriter.WriteUInt16.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadDateTime">
            <summary>
            Read a DateTime value from the stream. This value must have been written using the ObjectWriter.WriteDateTime.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadCompressedUInt">
            <summary>
            Read a compressed 30-bit integer value from the stream. This value must have been written using ObjectWriter.WriteCompressedInt.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadValue">
            <summary>
            Read a value from the stream. The value must have been written using ObjectWriter.WriteValue.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectReader.ReadString">
            <summary>
            Read a String value from the stream. This value must have been written using ObjectWriter.WriteString.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ObjectWriter">
            <summary>
            A class that writes both primitive values and non-cyclical object graphs to a stream that may be
            later read back using the ObjectReader class.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteBoolean(System.Boolean)">
            <summary>
            Writes a Boolean value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteByte(System.Byte)">
            <summary>
            Writes a Byte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteChar(System.Char)">
            <summary>
            Writes a Char value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteDecimal(System.Decimal)">
            <summary>
            Writes a Decimal value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteDouble(System.Double)">
            <summary>
            Writes a Double value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteSingle(System.Single)">
            <summary>
            Writes a Single value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteInt32(System.Int32)">
            <summary>
            Writes a Int32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteInt64(System.Int64)">
            <summary>
            Writes a Int64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteSByte(System.SByte)">
            <summary>
            Writes a SByte value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteInt16(System.Int16)">
            <summary>
            Writes a Int16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteUInt32(System.UInt32)">
            <summary>
            Writes a UInt32 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteUInt64(System.UInt64)">
            <summary>
            Writes a UInt64 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteUInt16(System.UInt16)">
            <summary>
            Writes a UInt16 value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteDateTime(System.DateTime)">
            <summary>
            Writes a DateTime value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteCompressedUInt(System.UInt32)">
            <summary>
            Writes a compressed 30 bit integer to the stream. (not 32 bit)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteString(System.String)">
            <summary>
            Writes a String value to the stream.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectWriter.WriteValue(System.Object)">
            <summary>
            Writes any value (primitive or object graph) to the stream.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SwitchConstantValueHelper">
            <summary>
            Contains helper methods for switch statement label constants
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SwitchConstantValueHelper.CompareSwitchCaseLabelConstants(Roslyn.Compilers.ConstantValue,Roslyn.Compilers.ConstantValue)">
            <summary>
            Method used to compare ConstantValues for switch statement case labels
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns>A value that indicates the relative order of the objects being compared. The return value has these meanings:
            Less than zero:     first instance precedes second in the sort order.
            Zero:               first instance occurs in the same position in the sort order as second.
            Greater than zero:  first instance follows second in the sort order.
            </returns>
        </member>
        <member name="F:Roslyn.Compilers.OutputKind.ConsoleApplication">
            <summary>
            An .exe with an entry point and a console.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.OutputKind.WindowsApplication">
            <summary>
            An .exe with an entry point but no console.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.OutputKind.DynamicallyLinkedLibrary">
            <summary>
            A .dll file.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.OutputKind.NetModule">
            <summary>
            A .netmodule file.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CandidateReason">
            <summary>
            Indicates the reasons why a candidate (or set of candidate) symbols were not considered
            correct in SemanticInfo. Higher values take precedence over lower values, so if, for
            example, there a symbol with a given name that was inaccessible, and other with the wrong
            arity, only the inaccessible one would be reported in the SemanticInfo.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.None">
            <summary>
            No CandidateSymbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotATypeOrNamespace">
            <summary>
            Only a type or namespace was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotAnEvent">
            <summary>
            Only an event was valid in the given location, but the candidate symbols was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotAWithEventsMember">
            <summary>
            The candidate symbol must be a WithEvents member, but it was not. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotAnAttributeType">
            <summary>
            Only an attribute type was valid in the given location, but the candidate symbol was
            of the wrong kind.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.WrongArity">
            <summary>
            The candidate symbol takes a different number of type parameters that was required.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotCreatable">
            <summary>
            The candidate symbol existed, but was not allowed to be created in a new expression. 
            For example, interfaces, static classes, and unconstrained type parameters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotReferencable">
            <summary>
            The candidate symbol existed, but was not allowed to be referenced. For example, the
            "get_XXX" method used to implement a property named "XXX" may not be directly
            referenced. Similarly, the type "System.Void" can not be directly referenced.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.Inaccessible">
            <summary>
            The candidate symbol had an accessibility modifier (private, protected, ...) that made
            it inaccessible.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotAValue">
            <summary>
            The candidate symbol was in a place where a value was required, but was not a value
            (e.g., was a a type or namespace).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotAVariable">
            <summary>
            The candidate symbol was in a place where a variable (or sometimes, a property) was
            required, but was not allowed there because it isn't a symbol that can be assigned to. 
            For example, the left hand side of an assignment, or a ref or out parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.NotInvocable">
            <summary>
            The candidate symbol was used in a way that an invocable member (method, or variable of
            delegate type) was required, but the candidate symbol was not invocable.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.StaticInstanceMismatch">
            <summary>
            The candidate symbol must be an instance variable, but was used as static, or the
            reverse. Also occurs if "this" is used in a context (static method or field initializer)
            where "this" is not available. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.OverloadResolutionFailure">
            <summary>
            Overload resolution did not chose a method. The candidate symbols are the methods there
            were considered during overload resolution (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.Latebound">
            <summary>
            Method could not be selected statically.
            The candidate symbols are the methods there were considered during overload resolution 
            (which may or may not be applicable methods). 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CandidateReason.Ambiguous">
            <summary>
            Multiple ambiguous symbols were available with the same name. This can occur if "using"
            statements bring multiple namespaces into scope, and the same type is available in
            multiple. This can also occur if multiple properties of the same name are available in a
            multiple interface inheritance situation.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.DebuggerUtilities.CallBeforeAcquiringLock">
            <summary>
            The issue here is acquiring a lock in the course of evaluating a property
            value in the debugger (e.g. in the Locals window).  If anything causes that
            evaluation to bail, it will do so without releasing the lock, making future
            evaluations impossible (leads to a timeout, among other things).  One thing
            that might cause the evaluation to bail is a call to 
            Debugger.NotifyOfCrossThreadDependency, which causes the debugger to prompt
            the user for confirmation (little swirling red and blue icon) before evaluating
            an expression that will involve multiple threads.  To prevent this from happening
            we make the call ourselved *before* acquiring the lock.  Then, when the user
            opts to proceed, the evaluation runs without interruption and succeeds.
            </summary>
            <remarks>
            TODO: This probably isn't necessary in Dev11 (see Dev11 548767 and/or Dev11 84313).
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.GlobalAssemblyCache">
            <summary>
            Provides APIs to enumerate and look up assemblies stored in the Global Assembly Cache.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.GlobalAssemblyCache.GetAssemblyIdentities(System.Reflection.AssemblyName,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">Optional partial name.</param>
            <param name="architectureFilter">Optional architecture filter.</param>
        </member>
        <member name="M:Roslyn.Compilers.GlobalAssemblyCache.GetAssemblyIdentities(System.String,System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning those that match given partial name and
            architecture.
            </summary>
            <param name="partialName">Optional partial name.</param>
            <param name="architectureFilter">Optional architecture filter.</param>
        </member>
        <member name="M:Roslyn.Compilers.GlobalAssemblyCache.GetAssemblySimpleNames(System.Func{System.Reflection.ProcessorArchitecture,System.Boolean})">
            <summary>
            Enumerates assemblies in the GAC returning their simple names.
            </summary>
            <param name="architectureFilter">Optional architecture filter.</param>
            <returns>Unique simple names of GAC assemblies.</returns>
        </member>
        <member name="F:Roslyn.Compilers.FileKey.FullPath">
            <summary>
            Full case-insensitive path.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.FileKey.Timestamp">
            <summary>
            Last write time (Utc).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.FileKey.#ctor(System.String,System.DateTime)">
            <summary>
            Constructor.
            </summary>
            <param name="fullPath">Full path.</param>
            <param name="timestamp">Last write time (Utc).</param>
        </member>
        <member name="T:Roslyn.Compilers.MetadataCache">
             <summary>
             Manages cache of the following information for Portable Executables loaded from files.
            
             For assemblies - a map from file name and timestamp to: 
                 1) A weak reference to the corresponding MetadataReader.Assembly object;
                 2) A list of weak references to instances of VB/CS AssemblySymbols based on the MetadataReader.Assembly object.
            
             For modules - a map from file name and timestamp to a weak reference to the corresponding MetadataReader.Module object
             </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.compactTimerPeriod">
            <summary>
            Period at which the timer is firing (30 seconds).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.assembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.modulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.compactTimer">
            <summary>
            Timer triggering compact operation for metadata cache.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.CompilationsToCompact">
            <summary>
            List of compilations that should be compacted.
            
            The cache must be locked for the duration of read/write operations, 
            see CacheLockObject property.
            
            Internal accesibility is for test purpose only.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.compactInProgress">
            <summary>
            compactTimer's procedure is in progress.
            Used to prevent multiple instances running in parallel.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.compactTimerIsOn">
            <summary>
            compactTimer is on, i.e. will fire.
            
            This field is changed to 'yes' only by EnableCompactTimer(),
            and is changed to 'no' only by CompactCache().
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.compactCollectionCount">
            <summary>
            Collection count last time the cache was compacted.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataCache.cacheLockObject">
            <summary>
            The object that must be locked for the duration of read/write operations on AssemblyManager's caches.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.CompactCacheOfRetargetingAssemblies">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.GetCollectionCount">
            <summary>
            Return amount of GC collections occurred so far.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.CompactCache(System.Object)">
            <summary>
            Called by compactTimer to compact the cache.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.EnableCompactTimer">
            <summary>
            Trigger timer every 30 seconds.
            Cache must be locked before calling this method.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.TriggerCacheCompact">
            <summary>
            Trigger compact operation for the cache, meant to be used for test purpose only.
            Locking the cache prior to calling this method is a good way to get into a deadlock.
            
            For test purposes only!!!
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.CompactCacheOfAssemblies">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.CompactCacheOfModules">
            <summary>
            Called by compactTimer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataCache.CompactTimerIsOn">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataCache.AssembliesFromFiles">
            <summary>
            Global cache for assemblies imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            Internal accessibility is for test purpose only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataCache.AssemblyKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataCache.ModulesFromFiles">
            <summary>
            Global cache for net-modules imported from files.
            The cache must be locked for the duration of read/write operations, see CacheLockObject property.
            Internal accessibility is for test purpose only.
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Roslyn.Compilers.MetadataCache.ModuleKeys">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataCache.CleaningCacheLock">
            <summary>
            This class is meant to be used for test purpose only.
            It locks MetadataCache until the instance is disposed.
            Upon locking, the cache is swapped with an empty cache,
            original cache is restored before the cache is unlocked.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataCache.CleaningCacheLock.CleanCaches">
            <summary>
            Clean global metadata caches, meant to be used for test purpose only.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.Realize">
            <summary>
            Realizes method body.
            No more data can be added to the builder after this call.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.GetAllScopes(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.GetIteratorScopes(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.MarkReachableBlocks">
            <summary>
            Marks blocks that are reachable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.MarkReachableFrom(Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock,System.Boolean)">
            <summary>
            Marks blocks that are recursively reachable from the given block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.OptimizeLabels">
            <summary>
            If a label points to a block that does nothing other than passing to block X,
            replaces target label's block with block X.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.DropUnreachableBlocks">
            <summary>
            Drops blocks that are not reachable
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.MarkAllBlocksUnreachable">
            <summary>
            Marks all blocks unreachable.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.RewriteSpecialBlocks">
            <summary>
            Rewrite any block marked as BlockedByFinally as an "infinite loop".
            </summary>
            <remarks>
            Matches the code generated by the native compiler in
            ILGENREC::AdjustBlockedLeaveTargets.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.IsSpecialEndHandlerBlock(Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock)">
            <summary>
            Returns true if the block has the signature of the special
            labeled block that follows a complete try/catch or try/finally.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.DefineSeqPoint(Roslyn.Compilers.Common.CommonSyntaxTree,Roslyn.Compilers.TextSpan)">
            <summary>
            Define a sequence point with the given syntax tree and span within it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.DefineHiddenSeqPoint">
            <summary>
            Defines a hidden sequence point.
            The effect of this is that debugger will not associate following code 
            with any source.(until it sees a lexically following sequence point)
            
            This is used for synthetic code that is reachable through labels.
            
            If such code is not separated from previous sequence point by the means of a hidden sequence point
            It looks as a part of the statement that previous sequence point specifies.
            As a result, when user steps through the code and goes through a jump to such label,
            it will appear as if the jump landed at the beginning of the previous statement.
            
            NOTE: Also inserted as the first statement of a method that would not otherwise have a leading
            sequence point so that step-into will find the method body.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.SetInitialDebugDocument(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            This is called when starting emitting a method for which there is some source.
            It is done in case the first sequence point is a hidden point.
            Even though hidden points do not have syntax, thye need to associate with some document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.MarkFilterConditionEnd">
            <summary>
            Marks the end of filter condition and start of the actual filter handler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.DefineIteratorLocal(System.Int32)">
            <summary>
            See Microsoft.Cci.ILocalScopeProvider.GetIteratorScopes.  This is called within an
            iterator scope to identify that a field named "&lt;Xyzzy&gt;5__i" is used to represent
            a local variable named Xyzzy.  The "i" is an integer, which is passed to this method
            as the index parameter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.AddLocalToScope(Roslyn.Compilers.CodeGen.LocalDefinition)">
            <summary>
            Puts local variable into current scope.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.AddLocalConstantToScope(Roslyn.Compilers.CodeGen.LocalConstantDefinition)">
            <summary>
            Puts local constant into current scope.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.MarkLabel(System.Object)">
            <summary>
            Mark current IL position with a label
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitStringSwitchJumpTable(System.Collections.Generic.KeyValuePair{Roslyn.Compilers.ConstantValue,System.Object}[],System.Object,Roslyn.Compilers.CodeGen.LocalDefinition,System.Boolean,Roslyn.Compilers.CodeGen.LocalDefinition,Roslyn.Compilers.CodeGen.SwitchStringJumpTableEmitter.EmitStringCompareAndBranch,System.Object[])">
            <summary>
            Primary method for emitting string switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="key">Local holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="genHashTableSwitch">Flag indicating whether we should generate
            hash table based switch or non hash table switch.</param>
            <param name="keyHash">Local holding the hash value of the key for emitting
            hash table switch. Hash value has already been computed and loaded into keyHash.
            This parameter is null if emitting non hash table switch.
            </param>
            <param name="emitStringCondBranchDelegate">
            Delegate to emit string compare call and conditional branch based on the compare result.
            </param>
            <param name="delegateArguments">Arguments to be passed to emitStringCondBranchDelegate</param>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitIntegerSwitchJumpTable(System.Collections.Generic.KeyValuePair{Roslyn.Compilers.ConstantValue,System.Object}[],System.Object,Roslyn.Compilers.CodeGen.LocalDefinition,Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Primary method for emitting integer switch jump table
            </summary>
            <param name="caseLabels">switch case labels</param>
            <param name="fallThroughLabel">fall through label for the jump table</param>
            <param name="key">Local holding the value to switch on.
            This value has already been loaded onto the execution stack.
            </param>
            <param name="keyTypeCode">Primitive type code of switch key</param>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.FinishFilterCondition">
            <summary>
            Finishes filter condition (and starts actual handler portion of the handler).
            Returns the last block of the condition.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitArrayCreation(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Generates code that creates an instance of multidimensional array
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitArrayElementLoad(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Generates code that loads an element of a multidimensional array
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitArrayElementAddress(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Generates code that loads an address of an element of a multidimensional array
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitArrayElementStore(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Generates code that stores an element of a multidimensional array
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.RealizedIL">
            <summary>
            This data is only relevant when builder has been realized.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.RealizedSequencePoints">
            <summary>
            This data is only relevant when builder has been realized.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.InstructionsEmitted">
            <summary>
            IL opcodes emitted by this builder.
            This includes branch instructions that end blocks except if they are fall-through NOPs.
            
            This count allows compilers to see if emitting a particular statement/expression 
            actually produced any instructions.
            
            Example: a label will not result in any code so when emitting debugging information 
                     an extra NOP may be needed if we want to decorate the label with sequence point. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.ILBuilder.Reachability.NotReachable">
            <summary>
            Block is not reachable or reachability analysis
            has not been performed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.ILBuilder.Reachability.Reachable">
            <summary>
            Block can be reached either falling through
            from previous block or from branch.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.ILBuilder.Reachability.BlockedByFinally">
            <summary>
            Block is reachable from try or catch but
            finally prevents falling through.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.AdjustForDelta(System.Int32)">
            <summary>
            Updates position of the current block to account for shorter sizes of previous blocks.
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.ShortenBranches(System.Int32@)">
            <summary>
            If possible, changes the branch code of the current block to the short version and 
            updates the delta correspondingly.
            </summary>
            <param name="delta">Position delta created by previous block size reductions.</param>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.OptimizeBranches(System.Int32@)">
            <summary>
            replaces branches with more compact code if possible.
            * branch to the next block  ===> nop
            * branch to ret blok        ===> ret
            
            TODO:
            * cond branch over uncond branch ===> flip condition, skip next block
            * cond branch to next            ===> pop args + nop
            * ???
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.GetReversedBranchOp">
            <summary>
            Returns reversed branch operation for the current block.
            If no reverse opcode can be obtained Nop is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.IsBranchToLabel">
            <summary>
            Returns true if this block has a branch label
            and is not a "nop" branch.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.RegularInstructions">
            <summary>
            Instructions that are not branches.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock.HasNoRegularInstructions">
            <summary>
            The block contains only the final branch or nothing at all
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.EmitState">
            <summary>
            Abstract Execution state. 
            If we know something interesting about IL stream we put it here.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.EmitState.AdjustStack(System.Int32)">
            <summary>
            Record effects of that currently emitted instruction on the eval stack.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.EmitState.MaxStack">
            <summary>
            Eval stack's high watermark.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.ILBuilder.EmitState.CurStack">
            <summary>
            Current evaluation stack depth.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.LabelInfo">
            <summary>
            Contains information about a label.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CodeGen.ILBuilder.LabelInfo.targetOfConditionalBranches">
            <summary>
            Sometimes we need to know if a label is targeted by conditional branches.
            For example optimizer can do optimizations of branches into outer try scopes only 
            if they are unconditional (because there are no conditional Leave opcodes)
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.LabelInfo.#ctor(System.Int32,System.Boolean)">
            <summary>
            Used when we see a branch, but label is not yet marked.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.LabelInfo.#ctor(Roslyn.Compilers.CodeGen.ILBuilder.BasicBlock,System.Int32,System.Boolean)">
            <summary>
            Used when label is marked to the code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.LocalScopeManager.GetAllScopesWithLocals(System.Boolean)">
            <summary>
            Gets all scopes that contain variables.
            </summary>
            <param name="edgeInclusive">Specifies whether scope spans should be reported as edge inclusive
            (position at "start + length" is IN the scope). VB EE expects that.</param>
            <returns></returns>
            <remarks>
            NOTE that edgeInclusive affects only how results are _reported_. 
            All internal representation is EDGE EXCLUSIVE.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.LocalScopeManager.GetExceptionHandlerRegions">
            <summary>
            Returns an ExceptionHandlerRegion for each exception handler clause
            beneath the root scope. Each ExceptionHandlerRegion indicates the type
            of clause (catch or finally) and the bounds of the try block and clause block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.ScopeInfo">
            <summary>
            Base class for IL scopes where a scope contains IL blocks and other nested
            scopes. A scope may represent a scope for variable declarations, an exception
            handler clause, or an entire exception handler (multiple clauses).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.ScopeInfo.GetScopesWithLocals(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.CodeGen.LocalScope},System.Boolean)">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.ScopeInfo.GetIteratorScopes(System.Collections.Generic.List{Roslyn.Compilers.CodeGen.LocalScope},System.Boolean)">
            <summary>
            Recursively calculates the start and end of the given scope.
            Only scopes with locals are actually dumped to the list.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilder.ScopeInfo.FreeBasicBlocks">
            <summary>
            Free any basic blocks owned by this scope or sub-scopes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.LocalScopeInfo">
            <summary>
            Class that collects content of the scope (blocks, nested scopes, variables etc).
            There is one for every opened scope.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.ExceptionHandlerScope">
            <summary>
            A scope for a single try, catch, or finally clause. If the clause
            is a catch clause, ExceptionType will be set.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.ExceptionHandlerContainerScope">
            <summary>
            A scope for an entire exception handler (a try block with either several
            catches or a finally block). Unlike other scopes, this scope contains
            nested scopes only, no IL blocks (although nested ExceptionHandlerScopes
            for the clauses will contain IL blocks).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ILBuilder.ScopeComparer">
            <summary>
            Compares scopes by their start (ascending) and then size (descending).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilderHelpers.IsClrInteger(Roslyn.Compilers.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILBuilderHelpers.IsBlittable(Roslyn.Compilers.SpecialType)">
            <summary>
            Checks if a type is a primitive of a fixed size.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILOpCodeExtensions.IsControlTransfer(Roslyn.Compilers.CodeGen.ILOpCode)">
            <summary>
            These opcodes represent control transfer.
            They should not appear inside basic blocks.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILOpCodeExtensions.IsBranchToLabel(Roslyn.Compilers.CodeGen.ILOpCode)">
            <summary>
            Opcodes that represents a branch to a label.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILOpCodeExtensions.CanFallThrough(Roslyn.Compilers.CodeGen.ILOpCode)">
            <summary>
            Opcodes that represents a branch to a label.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILVisualizer.DumpILBlock(System.Byte[],System.Int32,System.Text.StringBuilder,Roslyn.Compilers.CodeGen.ITokenDeferral,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CodeGen.ExceptionHandlerRegion},System.Int32)">
            <summary>
            Dumps all instructions in the stream into provided string builder.
            The blockOffset specifies the relative position of the block within method body (if known).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ILVisualizer.GetHandlerSpans(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.CodeGen.ExceptionHandlerRegion})">
            <summary>
            Determine the list of spans ordered by handler
            block start, with outer handlers before inner.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalDefinition.#ctor(System.String,Microsoft.Cci.ITypeReference,System.Int32)">
            <summary>
            Creates a new LocalDefinition.
            Slot will have no special constraints.
            </summary>
            <param name="name">Name associated with the slot.</param>
            <param name="type">Type associated with the slot.</param>
            <param name="slot">Slot position in the signature.</param>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalDefinition.#ctor(System.String,Microsoft.Cci.ITypeReference,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new LocalDefinition.
            </summary>
            <param name="name">Name associated with the slot.</param>
            <param name="type">Type associated with the slot.</param>
            <param name="slot">Slot position in the signature.</param>
            <param name="isPinned">Specifies whether slot type should have pinned modifier.</param>
            <param name="isReference">Specifies whether slot should have byref constraint.</param>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.LocalScope">
            <summary>
            Scope representation for PDB emit.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ILocalScope">
            <summary>
            A range of CLR IL operations that comprise a lexical scope, specified as an IL offset and a length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalScope.Offset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalScope.Length">
            <summary>
            The length of the scope. Offset+Length equals the offset of the first operation outside the scope, or equals the method body length.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ILocalScope.MethodDefinition">
            <summary>
            The definition of the method in which this local scope is defined.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.LocalSlotManager">
            <summary>
            At this level there are two kinds of local variables -
                
            Locals - have identities by which consuming code refers to them.
                Typical use is a local variable or a compiler generated temp that can be accessed in multiple operations.
                Any object can be used as identity. Reference equality is used.
                
            Temps - do not have identity. They are borrowed and returned to the free list.
                Typical use is a scratch temporary or spilling storage.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.DeclareLocal(Microsoft.Cci.ITypeReference,System.Object)">
            <summary>
            Gets a local slot and associates it with given identity.
            This will create a regular local (without byref, ispinned etc).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.DeclareLocal(Microsoft.Cci.ITypeReference,System.Object,System.Boolean,System.Boolean)">
            <summary>
            Gets a local slot and associates it with given identity.
            Also allows to specify whether the local should have byref constraint.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.GetLocal(System.Object)">
            <summary>
            Retrieve a local slot by its identity.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.FreeLocal(System.Object)">
            <summary>
            Release a local slot by its identity.
            Slot is not associated with identity after this.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.AllocateSlot(Microsoft.Cci.ITypeReference)">
            <summary>
            Gets a local slot.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.AllocateSlot(Microsoft.Cci.ITypeReference,System.Boolean,System.Boolean)">
            <summary>
            Gets a local slot.
            Also allows to specify whether the local should have byref constraint.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.LocalSlotManager.FreeSlot(Roslyn.Compilers.CodeGen.LocalDefinition)">
            <summary>
            Frees a local slot.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.LocalSlotManager.LocationSignature">
            <summary>
            Structure that represents a local signature (as in 8.6.1.3)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataConstant">
            <summary>
            An expression that does not change its value at runtime and can be evaluated at compile time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataConstant.Value">
            <summary>
            The compile time value of the expression. Can be null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.MetadataCreateArray">
            <summary>
            An expression that creates an array instance in metadata. Only for use in custom attributes.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataCreateArray">
            <summary>
            An expression that creates an array instance in metadata. Only for use in custom attributes.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.ElementType">
            <summary>
            The element type of the array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.Initializers">
            <summary>
            The initial values of the array elements. May be empty.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.ElementCount">
            <summary>
            The number of elements in the array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.LowerBounds">
            <summary>
            The index value of the first element in each dimension.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.Rank">
            <summary>
            The number of dimensions of the array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataCreateArray.Sizes">
            <summary>
            The number of elements allowed in each dimension.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#ElementType">
            <summary>
            The element type of the array.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#Initializers">
            <summary>
            The initial values of the array elements. May be empty.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#LowerBounds">
            <summary>
            The index value of the first element in each dimension.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#Rank">
            <summary>
            The number of dimensions of the array.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataCreateArray.Microsoft#Cci#IMetadataCreateArray#Sizes">
            <summary>
            The number of elements allowed in each dimension.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.MetadataNamedArgument">
            <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentName">
            <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#ArgumentValue">
            <summary>
            The value of the argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataNamedArgument.Microsoft#Cci#IMetadataNamedArgument#IsField">
            <summary>
            True if the named argument provides the value of a field.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.MetadataTypeOf">
            <summary>
            An expression that results in a System.Type instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataTypeOf">
            <summary>
            An expression that results in a System.Type instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataTypeOf.TypeToGet">
            <summary>
            The type that will be represented by the System.Type instance.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CodeGen.MetadataTypeOf.TypeToGet">
            <summary>
            The type that will be represented by the System.Type instance.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ReflectionEmitter">
             <summary>
             Emits types in a given <see cref="T:Microsoft.Cci.IModule"/> to a <see cref="T:System.Reflection.Emit.ModuleBuilder"/>.
             </summary>
             <remarks>
             Some types can't be emitted either due to the current Reflection.Emit implementation bugs/architecture or 
             due to limitations of collectible assemblies (http://msdn.microsoft.com/en-us/library/dd554932.aspx).
             
             The main problem with Reflection.Emit is that it uses two-phase type creation process. <see cref="T:System.Reflection.Emit.TypeBuilder"/>s are defined in the first phase
             and created (baked) one by one in the second. This isn't compatible with the way how CLR Type Loader loads cyclic type references. 
             
             The following rules apply and imply a partial order on the type baking (based upon observation and tests; they are not clearly documented anywhere) :
             1) Before a type can be baked its derived type and all interfaces it implements needs to be baked.
             2) Before a generic type can be baked the constraints of its generic type parameters need to be baked.
             3) Before a type can be baked all types of its fields that are value types need to be baked (reference typed fields don't).
             4) If a type is dependent on a generic type instantiation it is also dependent on its generic arguments.
             5) If a type is dependent on a type nested in another type the outer type need to be baked first.
            
             If these rule imply an order that is not satisfiable (there is a cycle) the emitter throws <see cref="T:System.NotSupportedException"/>.
             
             TODO (tomat):
             Some of these rules can be circumvented by using AppDomain.TypeLoad event, but it's unclear which exactly (I suspect #4).
             
             Examples of type topologies that can't be emitted today are:
             
             <code>
             class B{T} where T : A              // B depends on A by rule #2
             class A : B{A}                      // A depends on B by rule #1
             </code>
             
             <code>
             public class E                      
             {
                 public struct N2
                 {
                     public N3 n1;               // E.N2 depends on E.N3 by rule #3 and thus on E by rule #5
                 }
                 public struct N3    
                 {
                 }
                 N2 n2;                          // E depends on E.N2 by rule #3
             }
             </code>
             </remarks>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ReflectionEmitter.AddDependency(System.Reflection.Emit.TypeBuilder,System.Reflection.Emit.TypeBuilder)">
            <summary>
            Establishes a creation dependency of <paramref name="builder"/> on <paramref name="dependentType"/>. 
            The <paramref name="builder"/> can't be baked before <paramref name="dependentType"/> is.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ReflectionEmitter.Emit(System.Threading.CancellationToken,Microsoft.Cci.IMethodReference)">
            <summary>
            The main worker. Emits all types.
            </summary>
            <param name="cancellationToken">Token used to cancel the operation.</param>
            <param name="entryPoint">An entry point to resolve and return. This could be an arbitrary method, not just PE entry point.</param>
            <returns>The entry point or null if there is none.</returns>
            <exception cref="T:System.NotSupportedException">Reflection.Emit doesn't support the feature being emitted.</exception>
        </member>
        <member name="M:Roslyn.Compilers.CodeGen.ReflectionEmitter.OrderTypeBuilders">
            <summary>
            Bakes types in the order implied by <see cref="F:Roslyn.Compilers.CodeGen.ReflectionEmitter.dependencyGraph"/>. A type can't be baked until all of its dependencies are.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.MetadataBlock">
            <summary>
            Represents a block in .data
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISectionBlock">
            <summary>
            Represents a block of data stored at a given offset within a specified section of the PE file.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.PESectionKind">
            <summary>
            Section where the block resides.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Offset">
            <summary>
            Offset into section where the block resides.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Size">
            <summary>
            Size of the block.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISectionBlock.Data">
            <summary>
            Byte information stored in the block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ExplicitSizeStruct">
            <summary>
            Simple struct type with explicit size and no members.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeDefinition">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ITypeDefinitionMember">
            <summary>
            A member of a type definition, such as a field or a method.
            This interface models the metadata representation of a type member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition">
            <summary>
            The type definition that contains this member.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ITypeDefinitionMember.Visibility">
            <summary>
            Indicates if the member is public or confined to its containing type, derived types and/or declaring assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.INestedTypeReference">
            <summary>
            A type definition that is a member of another type definition.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.MappedField">
            <summary>
            Definition of a simple field mapped to a metadata block
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldDefinition">
            <summary>
            A field is a member that represents a variable associated with an object or class.
            This interface models the metadata representation of a field.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFieldReference">
            <summary>
            A reference to a field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetType(System.Object)">
            <summary>
            The type of value that is stored in this field.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IFieldReference.GetResolvedField(System.Object)">
            <summary>
            The Field being referred to.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataConstantContainer">
            <summary>
            Implemented by IFieldDefinition, IParameterDefinition and IPropertyDefinition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMetadataConstantContainer.Constant">
            <summary>
            The constant value associated with this metadata object. For example, the default value of a parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.CompileTimeValue">
            <summary>
            The compile time value of the field. This value should be used directly in IL, rather than a reference to the field.
            If the field does not have a valid compile time value, Dummy.Constant is returned.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.FieldMapping">
            <summary>
            Information of the location where this field is mapped to
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsCompileTimeConstant">
            <summary>
            This field is a compile-time constant. The field has no runtime location and cannot be directly addressed from IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsMapped">
            <summary>
            This field is mapped to an explicitly initialized (static) memory location.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsMarshalledExplicitly">
            <summary>
            This field has associated field marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsNotSerialized">
            <summary>
            The field does not have to be serialized when its containing instance is serialized.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsReadOnly">
            <summary>
            This field can only be read. Initialization takes place in a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsRuntimeSpecial">
            <summary>
            True if the field gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsSpecialName">
            <summary>
            This field is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.IsStatic">
            <summary>
            This field is static (shared by all instances of its declaring type).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.MarshallingInformation">
            <summary>
            Specifies how this field is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFieldDefinition.Offset">
            <summary>
            Offset of the field.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.BitArray.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.BitArray.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.BitArray.Clone">
            <summary>
            Maky a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.BitArray.IntersectWith(Roslyn.Compilers.BitArray)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.BitArray.UnionWith(Roslyn.Compilers.BitArray)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <param name="other"></param>
        </member>
        <member name="P:Roslyn.Compilers.BitArray.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Collections.CachingDictionary`2">
            <summary>
            The CachingLookup class provides a convenient representation of an ILookup that is based
            upon a potentially slow lookup, and caches lookup results so that subsequent lookups are
            fast. Internally a ConcurrentDictionary is used to cache lookup results. The client provides
            two delegates to perform lookups: One that maps a key to a IEnumerable of values, and one
            that provides all keys.
            
            The client must provide an IEqualityComparer used for comparing keys, and can select whether
            to cache failed lookups (keys with no values). Caching failed lookups has the disadvantage
            that every different failed lookup will consume a small amount of extra memory.
            
            Thread safe.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Collections.CachingDictionary`2.#ctor(System.Func{`0,Roslyn.Compilers.ReadOnlyArray{`1}},System.Func{System.Collections.Generic.IEnumerable{`0}},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create a CachingLookup.
            </summary>
            <param name="getElementsOfKey">A function that takes a key, and returns an IEnumerable of values that
            correspond to that key. If no values correspond, the function may either return null or an empty
            IEnumerable.</param>
            <param name="getKeys">A function that returns an IEnumerable of all keys that have associated values.</param>
            <param name="comparer">A IEqualityComparer used to compare keys.</param>
        </member>
        <member name="M:Roslyn.Compilers.Collections.CachingDictionary`2.Contains(`0)">
            <summary>
            Does this key have one or more associated values?
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Collections.CachingDictionary`2.GetOrCreateValue(`0)">
            <summary>
            Use the underlying (possibly slow) functions to get the values associated with a key.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Collections.CachingDictionary`2.FullyPopulate">
            <summary>
            Fully populate the underlying dictionary. Once this returns, the dictionary is guaranteed 
            to have every key in it. The field allCached is set to non-zero to indicate this, so that 
            we don't have to lookup keys that aren't in the dictionary.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Collections.CachingDictionary`2.Item(`0)">
            <summary>
            Get the values associated with a key. 
            </summary>
            <param name="key">Key to look up.</param>
            <returns>All values associated with key. Returns an empty IEnumerable if
            no values are associated. Never returns null.</returns>
        </member>
        <member name="P:Roslyn.Compilers.Collections.CachingDictionary`2.Count">
            <summary>
            Get the number of distinct keys.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Collections.CachingDictionary`2.Keys">
            <summary>
            Enumerate all the keys.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Collections.CachingDictionary`2.Map">
            <summary>
            Get the concurrent dictionary, creating it if needed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exectly one, and default(TSource) otherwise.
            Unlike <see cref="M: Enumerable.SingleOrDefault()"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ConsListExtensions">
            <summary>
            Extension methods associated with ConsList.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArray.ReadFromFile(System.String)">
            <summary>
            Reads content of the specified file.
            </summary>
            <param name="path">The path to the file.</param>
            <returns>Read-only binary data read from the file.</returns>
        </member>
        <member name="T:Roslyn.Compilers.FileLinePositionSpan">
            <summary>
            Represents a span of text in a source code file in terms of file name, line number, and offset within line.
            However, the file is actually whatever was passed in when asked to parse; there may not really be a file.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.#ctor(System.String,Roslyn.Compilers.LinePosition,Roslyn.Compilers.LinePosition)">
            <summary>
            Initializes <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/>.
            </summary>
            <param name="path">The file path.</param>
            <param name="startLinePosition">The start line position.</param>
            <param name="endLinePosition">The end line position.</param>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.#ctor(System.String,System.Boolean,Roslyn.Compilers.LinePosition,Roslyn.Compilers.LinePosition)">
            <summary>
            Initializes <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/>
            </summary>
            <param name="path">File path.</param>
            <param name="isFileNameFromLineDirective">True if the file name comes from a #line directive.</param>
            <param name="startLinePosition">The start line position.</param>
            <param name="endLinePosition">The end line position.</param>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.Equals(Roslyn.Compilers.FileLinePositionSpan)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive comparison is used.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.Equals(System.Object)">
            <summary>
            Determines if two FileLinePositionSpan objects are equal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.GetHashCode">
            <summary>
            Serves as a hash function for FileLinePositionSpan.
            </summary>
            <returns>The hash code.</returns>
            <remarks>
            The path is treated as an opaque string, i.e. a case-sensitive hash is calculated.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.FileLinePositionSpan.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents FileLinePositionSpan.
            </summary>
            <returns>The string representation of FileLinePositionSpan.</returns>
            <example>[0,0..5,6]</example>
        </member>
        <member name="P:Roslyn.Compilers.FileLinePositionSpan.IsValid">
            <summary>
            Returns true if the span represents a valid location. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.LocationKind">
            <summary>
            Specifies the kind of location (source vs. metadata).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.LocationKind.None">
            <summary>
            Unspecified location.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.LocationKind.SourceFile">
            <summary>
            The location represents a position in a source file.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.LocationKind.MetadataFile">
            <summary>
            The location represents a metadata file.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.EnumConstantHelper.OffsetValue(Roslyn.Compilers.ConstantValue,System.UInt32,Roslyn.Compilers.ConstantValue@)">
            <summary>
            Generate a ConstantValue of the same integer type as the argument
            and offset by the given non-negative amount. Return ConstantValue.Bad
            if the generated constant would be outside the valid range of the type.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.RemoveTrailingSpacesAndDots(System.String)">
            <summary>
            Trims all '.' and whitespaces from the end of the path
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileName(System.String)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it
                doesn't check for invalid path characters, 
                doesn't strip any trailing directory separators (TODO: tomat),
                doesn't recognize UNC structure \\computer-name\share\directory-name\file-name (TODO: tomat).
            </remarks>
            <returns>Prefix of path that represents a directory. </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetPathRoot(System.String)">
            <summary>
            Get a prefix of given path which is the root of the path.
            </summary>
            <returns>
            Root of an absolute path or null if the path isn't absolute or has invalid format (e.g. "\\").
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetUncPathRootLength(System.String)">
            <summary>
            Calculates the length of root of an UNC path.
            </summary>
            <remarks>
            "\\server\share" is root of UNC path "\\server\share\dir1\dir2\file".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.ArgumentException"/>
            <exception cref="T:System.Security.SecurityException"/>
            <exception cref="T:System.ArgumentNullException"/>
            <exception cref="T:System.NotSupportedException"/>
            <exception cref="T:System.IO.PathTooLongException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ImmutableList`1.ElementList">
            <summary>
            This is a simple list of elements
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ImmutableList`1.CompoundList">
            <summary>
            This is a compound list of lists
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonCompilationOptions">
            <summary>
            Represents compilation options common to C# and VB.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilationOptions.WithOutputKind(Roslyn.Compilers.OutputKind)">
            <summary>
            Creates a new options instance with the specified output kind.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilationOptions.WithOptimizations(System.Boolean)">
            <summary>
            Creates a new options instance with optimizations enabled or disabled.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonCompilationOptions.ValidateOptions(Roslyn.Compilers.ArrayBuilder{Roslyn.Compilers.DiagnosticInfo})">
            <summary>
            Performs validation of options compatibilities and generates diagnostics if needed
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.OutputKind">
            <summary>
            The kind of assembly generated when emitted.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.SubsystemVersion">
            <summary>
            Subsystem version
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.ScriptClassName">
            <summary>
            The full name of a global implicit class (script class). This class implicitly encapsulates top-level statements, 
            type declarations, and member declarations. Could be a namespace qualified name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.MainTypeName">
            <summary>
            The full name of a type that declares static Main method. Must be a valid non-generic namespace-qualified name.
            Null if any static Main method is a candidate for an entry point.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.CryptoKeyFile">
            <summary>
            The name of the file containing the key with which to sign the output.
            </summary>
            <remarks>
            To sign the output supply either one of <see cref="P:CryptoKeyContainer"/> or <see cref="P:CryptoKeyFile"/>.
            but not both.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.CryptoKeyContainer">
            <summary>
            The CSP container containing the key with which to sign the output.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.DelaySign">
            <summary>
            Turn off strong name signing when you have supplied a key either through
            attributes or  <see cref="P:CryptoKeyContainer"/> or <see cref="P:CryptoKeyFile"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.CheckOverflow">
            <summary>
            Whether bounds checking on integer arithmetic is enforced by default or not.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.FileAlignment">
            <summary>
            Specifies the size of sections in the output file. 
            </summary>
            <remarks>
            Valid values are 0, 512, 1024, 2048, 4096 and 8192.
            If the value is 0 the file alignment is determined based upon the value of <see cref="P:Roslyn.Compilers.Common.CommonCompilationOptions.Platform"/>.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.BaseAddress">
            <summary>
            Specifies the preferred base address at which to load the output DLL.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.Platform">
            <summary>
            Specifies which version of the common language runtime (CLR) can run the assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.EmitDebugInformationKind">
            <summary>
            Specifies the kind of debug information to be emitted.
            </summary>
            <remarks>
            This value is set based on the "/debug", "/debug+", "/debug-" and "/debug:{full|pdbonly}" command line switches.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.Optimize">
            <summary>
            Specifies whether or not optimizations should be performed on the output IL.
            This is independent of whether or not PDB information is generated.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.GeneralWarningOption">
            <summary>
            Globla warning report option
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.WarningLevel">
            <summary>
            Global warning level (from 0 to 4).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.ConcurrentBuild">
            <summary>
            Specifies whether building compilation may use multiple threads.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.SpecificWarningOptions">
            <summary>
            Warning report option for each warning
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonCompilationOptions.Errors">
            <summary>
            Errors collection related to an incompatible set of compilation options
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.IdentifierCollection">
            <summary>
            A dictionary that maps strings to all known spellings of that string. Can be used to
            efficiently store the set of known type names for a module for both VB and C# while also
            answering questions like "do you have a type called Foo" in either a case sensitive or
            insensitive manner.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonParseOptions">
            <summary>
            Represents parse options common to C# and VB.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonParseOptions.Kind">
            <summary>
            Specifies whether to parse as regular code files, script files or interactive code.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonParseOptions.ParseDocumentationComments">
            <summary>
            Gets a value indicating whether the documentation comments are parsed.
            </summary>
            <value><c>true</c> if documentation comments are parsed, <c>false</c> otherwise.</value>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonParseOptions.WithKind(Roslyn.Compilers.SourceCodeKind)">
            <summary>
            Creates a new options instance with the specified source code kind.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonParseOptions.PreprocessorSymbolNames">
            <summary>
            Names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IControlFlowAnalysis">
            <summary>
            Provides information about statements which transfer control in and out of a region. This
            information is returned from a call to <see cref="M:ISemanticModel.AnalyzeControlFlow" />.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IControlFlowAnalysis.EntryPoints">
            <summary>
            An enumerator for the set of statements inside the region what are the
            destination of branches outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IControlFlowAnalysis.ExitPoints">
            <summary>
            An enumerator for the set of statements inside a region that jump to locations outside
            the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Indicates whether a region completes normally. Return true if and only if the end of the
            last statement in a region is reachable or the region contains no statements.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IControlFlowAnalysis.ReturnStatements">
            <summary>
            An enumerator for the set of return statements found within a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IControlFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IDataFlowAnalysis">
            <summary>
            Provides information about how data flows into and out of a region. This information is
            returned from a call to
            <see cref="M:Roslyn.Compilers.ISemanticModel.AnalyzeRegionDataFlow" />.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.VariablesDeclared">
            <summary>
            An enumerator for the set of local variables that are declared within a region. Note
            that the region must be bounded by a method's body or a field's initializer, so
            parameter symbols are never included in the result.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.DataFlowsIn">
            <summary>
            An enumerator for the set of local variables which are assigned a value outside a region
            that may be used inside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.DataFlowsOut">
            <summary>
            An enumerator for the set of local variables which are assigned a value inside a region
            that may be used outside the region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.AlwaysAssigned">
            <summary>
            An enumerator for the set of local variables for which a value is always assigned inside
            a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.ReadInside">
            <summary>
            An enumerator for the set of local variables that are read inside a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.WrittenInside">
            <summary>
            An enumerator for the set of local variables that are written inside a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.ReadOutside">
            <summary>
            An enumerator for the set of the local variables that are read outside a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.WrittenOutside">
            <summary>
            An enumerator for the set of local variables that are written outside a region.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.Captured">
            <summary>
            An enumerator for the set of the local variables that have been referenced in anonymous
            functions within a region and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            A collection of the non-constant local variables and parameters that have had their
            address (or the address of one of their fields) taken.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IDataFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not
            properly span a single expression, a single statement, or a contiguous series of
            statements within the enclosing block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ISemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to GetBinding on a Compilation or CommonCompilation.
            </summary>
            <remarks>
            <para>An instance of ISemanticModel caches local symbols and semantic information. Thus, it
            is much more efficient to use a single instance of ISemanticModel when asking multiple
            questions about a syntax tree, because information from the first question may be reused.
            This also means that holding onto an instance of ISemanticModel for a long time may keep a
            significant amount of memory from being garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned
            (i.e. the returned value will be reference-equal to one reachable from the root of the
            symbol table). Symbols representing entities without names (e.g. array-of-int) may or may
            not exhibit reference equality. However, some named symbols (such as local variables) are
            not reachable from the root. These symbols are visible as answers to semantic questions.
            When the same SemanticModel object is used, the answers exhibit reference-equality.
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetSymbolInfo(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetSpeculativeSymbolInfo(System.Int32,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetSpeculativeTypeInfo(System.Int32,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the node in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information
            about an expression that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to  SemanticModel
            instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The semantic information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetTypeInfo(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the semantic info.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetAliasInfo(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If "nameSyntax" resolves to an alias name, return the IAliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
            <param name="nameSyntax">Name to get alias info for.</param>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the alias information.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetSpeculativeAliasInfo(System.Int32,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the syntax and declaration errors within the syntax tree associated with this
            object. Does not get errors involving compiling method bodies or initializers.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>The declaration errors for a syntax tree are cached. The first time this method
            is called, all declarations are analyzed for diagnostics. Calling this a second time
            will return the cached diagnostics.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Get all the errors within the syntax tree associated with this object. Includes errors
            involving compiling method bodies or initializers, in addition to the errors returned by
            GetDeclarationDiagnostics.
            </summary>
            <param name="cancellationToken">A cancellation token that can be used to cancel the
            process of obtaining the diagnostics.</param>
            <remarks>
            Because this method must semantically bind all method bodies and initializers to check
            for diagnostics, it may take a significant amount of time. Unlike
            GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not
            cached, the any semantic information used to obtain the diagnostics is discarded.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetDeclaredSymbol(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the symbol associated with a declaration syntax node.
            </summary>
            <param name="declaration">A syntax node that is a declaration. This can be any type
            derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,
            NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a
            UsingDirectiveSyntax</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol declared by the node or null if the node is not a declaration.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.LookupSymbols(System.Int32,Roslyn.Compilers.Common.INamespaceOrTypeSymbol,System.String,System.Nullable{System.Int32},Roslyn.Compilers.Common.CommonLookupOptions)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional container. Only
            symbols that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="arity">The number of generic type parameters the symbol has. If null is specified then symbols
            with any arity are returned.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.AnalyzeControlFlow(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.AnalyzeControlFlow(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The statement must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.AnalyzeDataFlow(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first node to be included within the analysis.</param>
            <param name="lastStatement">The last node to be included within the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The span is not with a method
            body.</exception>
            <remarks>
            The first and last nodes must be fully inside the same method body.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.AnalyzeDataFlow(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statementOrExpression">The statement or expression to be analyzed.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The statement or expression is not with a method
            body or field or property initializer.</exception>
            <remarks>
            The statement or expression must be fully inside a method body.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetConstantValue(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            If the node provided has a constant value an Optional value will be returned with
            HasValue set to true and with Value set to the constant.  If the node does not have an
            constant value, an Optional will be returned with HasValue set to false.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetMemberGroup(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            When getting information for a symbol that resolves to a method group or property group,
            from which a method is then chosen; the chosen method or property is present in Symbol;
            all methods in the group that was consulted are placed in this property.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetForEachStatementInfo(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets the semantic information of a for each statement.
            </summary>
            <param name="node">The for each statement or block syntax node.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this ISemanticModel returns the innermost Symbol
            that the position is considered inside of.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.ResolveOverloads``1(System.Int32,Roslyn.Compilers.ReadOnlyArray{``0},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.Common.ITypeSymbol},Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.Common.CommonSyntaxNode})">
            <summary>
            Resolves the set of provided arguments against set of provided members to determine the
            appropriate overload. The arguments are bound as if they were at 'position' within this
            semantic model. An CommonOverloadResolutionResult is returned that gives the result of
            the compiler's overload resolution analysis.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel. This position is used when binding the arguments.
            </param>
            <param name="members">The set of members to resolve overloads among.</param>
            <param name="arguments">The list of arguments, in order, to use when resolving the
            overloads. The arguments are interpreted as if they occurred within the declaration
            scope that encloses "position".</param>
            <param name="typeArguments">If present, the type argument provided. If not provided,
            type inference is done.</param>
            <remarks>
            This can be used to resolve constructors, properties as well as methods.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.ClassifyConversion(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use CommonCompilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.ClassifyConversion(System.Int32,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.IsAccessible(System.Int32,Roslyn.Compilers.Common.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISemanticModel.IsEventUsableAsField(System.Int32,Roslyn.Compilers.Common.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
            <remarks>
            Always false for VB events.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISemanticModel.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISemanticModel.Compilation">
            <summary>
            The compilation this model was obtained from.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISemanticModel.SyntaxTree">
            <summary>
            The syntax tree this model was obtained from.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.ReadOnlyArray`1">
            <summary>
            A wrapper that prevents writing to elements of an underlying array. It is a struct
            to avoid extra allocation and indirections. Equality is determined by reference equality
            of the underlying array. Implements a struct enumerator to minimize allocations. For similar
            reasons, it does not implement IEnumerable, but instead implements a subset of the Linq extensions.
            
            This type is expected to be replaced by a BCL type.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Roslyn.Compilers.ReadOnlyArray`1.Empty">
            <summary>
            A singleton representing an empty array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArray`1.#ctor(`0[])">
            <summary>
            DANGER!!! DANGER!! This constructor wraps the array. No copy is made.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArray`1.ToDownCasted``1">
            <summary>
            Downcast the array to ReadOnlyArray of derived type without doing additional allocation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArray`1.InterlockedCompareExchange(Roslyn.Compilers.ReadOnlyArray{`0}@,Roslyn.Compilers.ReadOnlyArray{`0})">
            <summary>
            Replace value at location with given value if the current value is
            ReadOnlyArray&lt;T&gt;.Null. Return true if value was replaced.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArray`1.GetPinnedHandle">
            <summary>
            Pins the underlying array and returns a <see cref="T:System.Runtime.InteropServices.GCHandle"/> of the pinned memory.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ReadOnlyArray`1.ReadOnlyList">
            <summary>
            IList Wrapper on top of ReadOnlyArray
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.ToReadOnlyArray(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.AsReadOnlyWrap``1(``0[])">
            <summary>
            DANGER!!! DANGER!!! This method wraps the array!! No copy is made.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.Distinct``1(Roslyn.Compilers.ReadOnlyArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Return an array of distinct elements, preserving the order in the original
            array. If the array has no duplicates, the original array is returned. The
            original array must be non-null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.WriteToFile(Roslyn.Compilers.ReadOnlyArray{System.Byte},System.String)">
            <summary>
            Writes read-only array of bytes to the specified file.
            </summary>
            <param name="bytes">Data to write to the file.</param>
            <param name="path">File path.</param>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.LoadAsAssembly(Roslyn.Compilers.ReadOnlyArray{System.Byte},System.Boolean)">
            <summary>
            Loads given array of bytes as an assembly image using <see cref="M:System.Reflection.Assembly.Load"/> or <see cref="M:System.Reflection.Assembly.ReflectionOnlyLoad"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ReadOnlyArrayExtensions.LoadModule(System.Reflection.Assembly,System.String,Roslyn.Compilers.ReadOnlyArray{System.Byte},Roslyn.Compilers.ReadOnlyArray{System.Byte})">
            <summary>
            Loads given array of bytes as an assembly image using <see cref="M:System.Reflection.Assembly.Load"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Collections.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.UnionCollection`1">
            <summary>
            Implements a readonly collection over a set of existing collections. This can be used to
            prevent having to copy items from one collection over to another (thus bloating space).
            
            Note: this is a *collection*, not a *set*.  There is no removal of duplicated elements. This
            allows us to be able to efficiently do operations like CopyTo, Count, etc. in O(c) time
            instead of O(n) (where 'c' is the number of collections and 'n' is the number of elements).
            If you have a few collections with many elements in them, then this is an appropriate
            collection for you.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonLookupOptions">
            <summary>
            Options that can be used to modify the symbol lookup mechanism. Multiple options can be combined together.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.Default">
            <summary>
            Consider all symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.NamespacesOrTypesOnly">
            <summary>
            Consider only namespaces and types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.LabelsOnly">
            <summary>
            Look only for label symbols.  This must be exclusive of all other options.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.MustNotBeInstance">
            <summary>
            Do not consider symbols that are instance members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.IncludeExtensionMethods">
            <summary>
            Include extension methods.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.UseBaseReferenceAccessibility">
            <summary>
            Ignore 'throughType' in accessibility checking. Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonLookupOptions.MustBeInstance">
            <summary>
            Consider only symbols that are instance members. Valid with IncludeExtensionMethods
            since extension methods are invoked on an instance.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DiagnosticSeverity">
            <summary>
            Describes how severe a diagnostic is.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.DiagnosticSeverity.Info">
            <summary>
            An "informational" diagnostic is something we tell the user,
            but it isn't necessarily "something wrong".
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.DiagnosticSeverity.Warning">
            <summary>
            A "warning" is something suspicious but legal.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.DiagnosticSeverity.Error">
            <summary>
            An "error" is something not technically allowed.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.NeedsLocalization(System.String)">
            <summary>
            Used to indicate places where we are hard-coding strings that will later need to be
            localized.  This way, we can use a "Find All References" to find and fix these.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SyntaxPath">
            <summary>
            Stores the "path" from the root of a tree to a node, allowing the node to be recovered in a
            later snapshot of the tree, under certain circumstances.
            
            The implementation stores the child indices to represent the path, so any edit which affects
            the child indices could render this object unable to recover its node.  NOTE: One thing C#
            IDE has done in the past to do a better job of this is to store the fully qualified name of
            the member to at least be able to descend into the same member.  We could apply the same sort
            of logic here.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SyntaxPath.TryResolve(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNodeOrToken@)">
            <summary>
            Attempts to recover the node at this path in the provided tree.  If the node is found
            then 'true' is returned, otherwise the result is 'false' and 'node' will be null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CompilationErrorException">
            <summary>
            An exception thrown when the compilation stage of interactive execution produces compilation errors.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CompilationErrorException.Diagnostics">
            <summary>
            The list of diagnostics produced by compilation.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DocumentationComment">
            <summary>
            A documentation comment derived from either source text or metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationComment.FromXmlFragment(System.String)">
            <summary>
            Parses and constructs a DocumentationComment from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentionComment instance.</returns>
            <exception cref="T:System.ArgumentException">If the XML fragment was unable to be successfully
            parsed.</exception>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationComment.GetParameterText(System.String)">
            <summary>
            Returns the text for a given parameter, or null if no documentation was given for the parameter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DocumentationComment.GetTypeParameterText(System.String)">
            <summary>
            Returns the text for a given type parameter, or null if no documentation was given for the type parameter.
            </summary>
            <param name="typeParameterName"></param>
            <returns></returns>
        </member>
        <member name="F:Roslyn.Compilers.DocumentationComment.Empty">
            <summary>
            An empty comment.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DocumentationComment.HadXmlParseError">
            <summary>
            True if an error occurred when parsing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DocumentationComment.FullXmlFragmentOpt">
            <summary>
            The full XML text of this tag.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DocumentationComment.ExampleTextOpt">
            <summary>
            The text in the &lt;example&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DocumentationComment.SummaryTextOpt">
            <summary>
            The text in the &lt;summary&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DocumentationComment.ReturnsTextOpt">
            <summary>
            The text in the &lt;returns&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.ModuleExtensions.ShouldImportNestedType(Roslyn.Compilers.MetadataReader.Module,System.UInt32)">
            <summary>
            Returns true if the nested type should be imported. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.ModuleExtensions.ShouldImportField(Roslyn.Compilers.MetadataReader.Module,System.UInt32,System.Boolean)">
            <summary>
            Returns true if the field should be imported. Visibility
            and the value of <paramref name="importInternals"/> are considered
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.ModuleExtensions.ShouldImportField(Roslyn.Compilers.MetadataReader.PEFileFlags.FieldFlags,System.Boolean)">
            <summary>
            Returns true if the flags represent a field that should be imported.
            Visibility and the value of <paramref name="importInternals"/> are considered
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.ModuleExtensions.ShouldImportMethod(Roslyn.Compilers.MetadataReader.Module,System.UInt32,System.Boolean)">
            <summary>
            Returns true if the method should be imported. Returns false for private methods that are not
            explicit interface implementations. For other methods, visibility and the value of
            <paramref name="importInternals"/> are considered.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataFileProvider">
            <summary>
            Provides metadata files to services that need to read or load them. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataFileProvider.ClearCache">
            <summary>
            Removes any cached data or files created by the provider.
            </summary>
            <remarks>
            <see cref="M:Roslyn.Compilers.MetadataFileProvider.GetReference(System.String,Roslyn.Compilers.MetadataReferenceProperties)"/> might be optimized to cache results and ignore changes to the files made after the file has been provided. 
            This behavior is useful when the compiler and services that use the provider work on a snapshot of the metadata files.
            Call this method to clear the cache and start over.
            </remarks>
        </member>
        <member name="T:Microsoft.Cci.IResource">
            <summary>
            A named data resource that is stored as part of CLR metadata.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IResourceReference">
            <summary>
            A reference to an IResource instance.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResourceReference.Attributes">
            <summary>
            A collection of metadata custom attributes that are associated with this resource.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResourceReference.DefiningAssembly">
            <summary>
            A symbolic reference to the IAssembly that defines the resource.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResourceReference.IsPublic">
            <summary>
            Specifies whether other code from other assemblies may access this resource.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResourceReference.Name">
            <summary>
            The name of the resource.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResourceReference.Resource">
            <summary>
            The referenced resource.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResource.Data">
            <summary>
            The resource data.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResource.IsInExternalFile">
            <summary>
            The resource is in external file
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IResource.ExternalFile">
            <summary>
            The external file that contains the resource.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ManagedResource.#ctor(System.String,System.Func{System.IO.Stream},Microsoft.Cci.IFileReference,System.Boolean,Microsoft.Cci.IAssemblyReference)">
            <summary>
            <paramref name="streamProvider"/> will be evaluated only once and the result disposed. 
            <paramref name="streamProvider"/> and <paramref name="fileReference"/> are mutually exclusive.
            </summary>
            <param name="name"></param>
            <param name="streamProvider"></param>
            <param name="fileReference"></param>
            <param name="isPublic"></param>
            <param name="parent"></param>
        </member>
        <member name="T:Roslyn.Compilers.CodeGen.ExceptionHandlerRegion">
            <summary>
            A region representing an exception handler clause. The region exposes the type (catch or
            finally) and the bounds of the try block and catch or finally block as needed by CCI.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IOperationExceptionInformation">
            <summary>
            Exception information of the method body expressed in terms of offsets in CLR IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.HandlerKind">
            <summary>
            Handler kind for this SEH info
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.ExceptionType">
            <summary>
            If HandlerKind == HandlerKind.Catch, this is the type of expection to catch. If HandlerKind == HandlerKind.Filter, this is System.Object.
            Otherwise this is a Dummy.TypeReference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.TryStartOffset">
            <summary>
            Label instruction corresponding to the start of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.TryEndOffset">
            <summary>
            Label instruction corresponding to the end of try block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.FilterDecisionStartOffset">
            <summary>
            Label instruction corresponding to the start of filter decision block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.HandlerStartOffset">
            <summary>
            Label instruction corresponding to the start of handler block
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IOperationExceptionInformation.HandlerEndOffset">
            <summary>
            Label instruction corresponding to the end of handler block
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ResourceDescription.#ctor(System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose contents are to be embedded in the output assembly. The
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="dataProvider">
            Function returning a stream of the data to embed.
            Will be evaluated once and the result will be disposed.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
        </member>
        <member name="M:Roslyn.Compilers.ResourceDescription.#ctor(System.String,System.String,System.Func{System.IO.Stream},System.Boolean)">
            <summary>
            Creates a representation of a resource whose file name will be recorded in the assembly.
            </summary>
            <param name="resourceName">Resource name.</param>
            <param name="fileName">File name with an extension to be stored in metadata.</param>
            <param name="dataProvider">
            Function returning a stream of the recource content (used to calculate hash).
            Will be evaluated once and the result will be disposed.
            This allows the resources to be opened and read one at a time.
            </param>
            <param name="isPublic">True if the resource is public.</param>
        </member>
        <member name="T:Microsoft.Cci.IFileReference">
            <summary>
            Represents a file referenced by an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.HasMetadata">
            <summary>
            True if the file has metadata.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.FileName">
            <summary>
            File name with extension.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFileReference.HashValue">
            <summary>
            A hash of the file contents.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.MetadataShadowCopyProvider">
            <summary>
            Implements shadow-copying metadata file cache.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an instance of <see cref="T:Roslyn.Scripting.MetadataShadowCopyProvider"/>.
            </summary>
            <param name="directory">The directory to use to store file copies.</param>
            <param name="noShadowCopyDirectories">Directories to exclude from shadow-copying.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="directory"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="directory"/> is not an absolute path.</exception>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.IsShadowCopy(System.String)">
            <summary>
            Determine whether given path is under the shadow-copy directory managed by this shadow-copy provider.
            </summary>
            <param name="fullPath">Absolute path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not an absolute path.</exception>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.ClearCache">
            <summary>
            Clears shadow-copy cache, disposes all allocated metadata, and attempts to delete copied files.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.GetMetadata(System.String,Roslyn.Compilers.MetadataImageKind)">
            <summary>
            Gets or creates metadata for specified file path.
            </summary>
            <param name="fullPath">Full path to an assembly manifest module file or a standalone module file.</param>
            <param name="kind">Metadata kind (assembly or module).</param>
            <returns>Metadata for the specified file.</returns>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.GetMetadataShadowCopy(System.String,Roslyn.Compilers.MetadataImageKind)">
            <summary>
            Gets or creates a copy of specified assembly or standalone module.
            </summary>
            <param name="fullPath">Full path to an assembly manifest module file or a standalone module file.</param>
            <param name="kind">Metadata kind (assembly or module).</param>
            <returns>
            Copy of the specified file, or null if the file doesn't need a copy (<see cref="M:Roslyn.Scripting.MetadataShadowCopyProvider.NeedsShadowCopy(System.String)"/>). 
            Returns the same object if called multiple times with the same path.
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not an absolute path.</exception>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.GetReference(System.String,Roslyn.Compilers.MetadataReferenceProperties)">
            <exception cref="T:System.ArgumentNullException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not an absolute path.</exception>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.SuppressShadowCopy(System.String)">
            <summary>
            Suppresses shadow-coping of specified path.
            </summary>
            <param name="originalPath">Full path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="originalPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="originalPath"/> is not an absolute path.</exception>
            <remarks>
            Doesn't affect files that have already been shadow-copied.
            </remarks>
        </member>
        <member name="M:Roslyn.Scripting.MetadataShadowCopyProvider.NeedsShadowCopy(System.String)">
            <summary>
            Determines whether given file is a candidate for shadow-copy.
            </summary>
            <param name="fullPath">An absolute path.</param>
            <returns>True if the shadow-copy policy applies to the specified path.</returns>
            <exception cref="T:System.NullReferenceException"><paramref name="fullPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="fullPath"/> is not absolute.</exception>
        </member>
        <member name="T:Roslyn.Scripting.MetadataShadowCopyProvider.ShadowCopyReference">
            <summary>
            Specialize <see cref="T:Roslyn.Compilers.PortableExecutableReference"/> with path being the original path of the copy.
            Logically this reference represents that file, the fact that we load the image from a copy is an implementation detail.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.CommonObjectFormatter">
            <summary>
            Object pretty printer.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonObjectFormatter.FormatArrayTypeName(System.Array,Roslyn.Scripting.ObjectFormattingOptions)">
            <summary>
            Formats an array type name (vector or multidimensional).
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonObjectFormatter.IsHiddenMember(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the member shouldn't be displayed (e.g. it's a compiler generated field).
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.CommonObjectFormatter.VoidDisplayString">
            <summary>
            String that describes "void" return type in the language.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.CommonObjectFormatter.NullLiteral">
            <summary>
            String that describes "null" literal in the language.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonObjectFormatter.Formatter.FormatObjectMembers(Roslyn.Scripting.CommonObjectFormatter.Builder,System.Object,System.Type,System.Boolean,System.Boolean)">
            <summary>
            Formats object members to a list.
            
            Inline == false:
            <code>
            { A=true, B=false, C=new int[3] { 1, 2, 3 } }
            </code>
            
            Inline == true:
            <code>
            {
              A: true,
              B: false,
              C: new int[3] { 1, 2, 3 }
            }
            </code>
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonObjectFormatter.Formatter.FormatObjectMembersRecursive(System.Collections.Generic.List{Roslyn.Scripting.CommonObjectFormatter.Formatter.FormattedMember},System.Object,System.Boolean,System.Int32@)">
            <summary>
            Enumerates sorted object members to display.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonObjectFormatter.Formatter.FormatWithEmbeddedExpressions(System.Int32,System.String,System.Object)">
            <summary>
            Evaluate a format string with possible member references enclosed in braces. 
            E.g. "foo = {GetFooString(),nq}, bar = {Bar}".
            </summary>
            <remarks>
            Although in theory any expression is allowed to be embedded in the string such behavior is in practice fundamentally broken.
            The attribute doesn't specify what language (VB, C#, F#, etc.) to use to parse these expressions. Even if it did all languages 
            would need to be able to evaluate each other language's expressions, which is not viable and the Expression Evaluator doesn't 
            work that way today. Instead it evaluates the embedded expressions in the language of the current method frame. When consuming 
            VB objects from C#, for example, the evaluation migth fail due to language mismatch (evaluating VB expression using C# parser).
            
            Therefore we limit the expressions to a simple language independent syntax: {clr-member-name} '(' ')' ',nq', 
            where parentheses and ,nq suffix (no-quotes) are optional and the name is an arbitrary CLR field, property, or method name.
            We then resolve the member by name using case-sensitive lookup first with fallback to case insensitive and evaluate it.
            If parentheses are present we only look for methods.
            Only parameter less members are considered.
            </remarks>
        </member>
        <member name="T:Roslyn.Scripting.CommonScriptEngine">
            <summary>
            Represents a runtime execution context for C# scripts.
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.CommonScriptEngine.globalAssemblyNamePrefix">
            <summary>
            Unique prefix for generated uncollectible assemblies.
            </summary>
            <remarks>
            The full names of uncollectible assemblies generated by this context must be unique,
            so that we can resolve references among them. Note that CLR can load two different assemblies of the very 
            identity into the same load context.
            
            We are using a certain naming scheme for the generated assemblies (a fixed name prefix followed by a number). 
            If we allowed the compiled code to add references that match this exact pattern it migth happen that 
            the user supplied reference identity conflicts with the identity we use for our generated assemblies and 
            the AppDomain assembly resolve event won't be able to correctly identify the target assembly.
            
            To avoid this problem we use a prefix for assemblies we generate that is unlikely to conflict with user specified references.
            We also check that no user provided references are allowed to be used in the compiled code and report an error ("reserved assembly name").
            </remarks>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.GetReferences">
            <summary>
            Returns a list of assemblies that are currently referenced by the engine.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.AddReference(System.String)">
            <summary>
            Adds a reference to specified assembly.
            </summary>
            <param name="assemblyDisplayNameOrPath">Assembly display name or path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assemblyDisplayNameOrPath"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="assemblyDisplayNameOrPath"/> is empty.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Assembly file can't be found.</exception>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.AddReference(System.Reflection.Assembly)">
            <summary>
            Adds a reference to specified assembly.
            </summary>
            <param name="assembly">Runtime assembly. The assembly must be loaded from a file on disk. In-memory assemblies are not supported.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.AddReference(Roslyn.Compilers.MetadataReference)">
            <summary>
            Adds a reference to specified assembly.
            </summary>
            <param name="reference">Assembly reference.</param>
            <exception cref="T:System.ArgumentException"><paramref name="reference"/> is not an assembly reference (it's a module).</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="reference"/> is null.</exception>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.GetImportedNamespaces">
            <summary>
            Returns a list of imported namespaces.
            </summary>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.ImportNamespace(System.String)">
            <summary>
            Imports a namespace, an equivalent of executing "using <paramref name="namespace"/>;" (C#) or "Imports <paramref name="namespace"/>" (VB).
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="namespace"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="namespace"/> is not a valid namespace name.</exception>
        </member>
        <member name="M:Roslyn.Scripting.CommonScriptEngine.MapAssemblySymbol(Roslyn.Compilers.Common.IAssemblySymbol,System.Boolean)">
            <summary>
            Maps given assembly symbol to an assembly ref.
            </summary>
            <remarks>
            The compiler represents every submission by a compilation instance for which it creates a distinct source assembly symbol.
            However multiple submissions might compile into a single dynamic assembly and so we need to map the corresponding assembly symbols to 
            the name of the dynamic assembly.
            </remarks>
        </member>
        <member name="P:Roslyn.Scripting.CommonScriptEngine.BaseDirectory">
            <summary>
            The base directory used to resolve relative paths to assembly references and 
            relative paths that appear in source code compiled by this script engine.
            </summary>
            <remarks>
            If null relative paths won't be resolved and an error will be reported when the compiler encountrs such paths.
            The value can be changed at any point in time. However the new value doesn't affect already compiled submissions.
            The initial value is the current working directory if the current process, or null if not available.
            Changing the base directory doesn't affect the process current working directory used by <see cref="N:System.IO"/> APIs.
            </remarks>
        </member>
        <member name="T:Roslyn.Scripting.CommonScriptEngine.UncollectibleCodeManager">
            <summary>
            Manages uncollectible assemblies and resolves assembly references baked into CCI generated metadata. 
            The resolution is triggered by the CLR Type Loader.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.AssemblyLoader">
            <summary>
            Implements assembly loader for interactive compiler and REPL.
            </summary>
            <remarks>
            <para>
            An assembly is loaded into CLRs Load Context if it is in the GAC, otherwise it's loaded into No Context via <see cref="M:System.Reflection.Assembly.LoadFile(System.String)"/>.
            <see cref="M:System.Reflection.Assembly.LoadFile(System.String)"/> automatically redirects to GAC if the assembly has a strong name and there is an equivalent assembly in GAC. 
            </para>
            <para>
            The class is thread-safe.
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Scripting.AssemblyLoader.Load(Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Loads assembly with given identity.
            </summary>
            <param name="identity">The assembly identity.</param>
            <returns>Loaded assembly.</returns>
        </member>
        <member name="M:Roslyn.Scripting.AssemblyLoader.LoadFromPath(System.String)">
            <summary>
            Loads an assembly from path.
            </summary>
            <param name="path">Absolute assembly file path.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an exisiting assembly file path.</exception>
            <exception cref="T:System.Reflection.TargetInvocationException">The assembly resolver threw an exception.</exception>
        </member>
        <member name="M:Roslyn.Scripting.AssemblyLoader.RegisterDependency(Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Notifies the assembly loader about a dependency that might be loaded in future.
            </summary>
            <param name="dependency">Assembly identity with location.</param>
            <remarks>
            Associates a full assembly name with its location. The association is used when an assembly 
            is being loaded and its name needs to be resolved to a location.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="dependency"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="dependency"/>.<see cref="P:System.Reflection.AssemblyName.CodeBase"/> is null or empty.</exception>
        </member>
        <member name="P:Roslyn.Scripting.AssemblyLoader.LoadedAssembly.OriginalPath">
            <summary>
            The original path of the assembly before it was shadow-copied.
            For GAC'd assemblies, this is equal to Assembly.Location no matter what path was used to load them.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.AssemblyLoadResult">
            <summary>
            The result of loading an assembly reference to the interactive session.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.AssemblyLoadResult.IsSuccessful">
            <summary>
            True if the assembly was loaded by the assembly loader, false if has been loaded before.
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.AssemblyLoadResult.Path">
            <summary>
            Full path to the physical assembly file (might be a shadow-copy of the original assembly file).
            </summary>
        </member>
        <member name="P:Roslyn.Scripting.AssemblyLoadResult.OriginalPath">
            <summary>
            Original assembly file path.
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.MemberDisplayFormat.NoMembers">
            <summary>
            Display just a simple description of the object, like type name or ToString(). Don't
            display any members or items of the object.
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.MemberDisplayFormat.Inline">
            <summary>
            Display structure of the object on a single line.
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.MemberDisplayFormat.InlineValue">
            <summary>
            Display structure of the object on a single line, where the object is displayed as a value of its container's member.
            E.g. { a = ... }
            </summary>
        </member>
        <member name="F:Roslyn.Scripting.MemberDisplayFormat.List">
            <summary>
            Displays a siple description of the object followed by list of members. Each member is
            displayed on a separate line.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.Submission`1">
            <summary>
            Compiled executable submission.
            </summary>
        </member>
        <member name="T:Roslyn.Scripting.Session">
            <summary>
            Runtime representation of an interactive session.
            </summary>
            <remarks>
            Session is not thread-safe, i.e. parallel executions against the same session object might fail.
            However executing methods defined in a context of a session in parallel is safe as long as the methods themselves are thread-safe.
            (i.e. accessing data from previous submissions is safe as long as they are readonly or guarded by a user maintained lock).
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.SourceCodeKind.Regular">
            <summary>
            No scripting. Used for .cs/.vb file parsing.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SourceCodeKind.Script">
            <summary>
            Allows top-level statements and declarations. Used for .csx/.vbx file parsing.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SourceCodeKind.Interactive">
            <summary>
            Allows top-level expressions and optional semicolon.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataReader.IMemoryBlock">
            <summary>
            Represents an unmanaged memory block.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.IMemoryBlock.GetContent">
            <summary>
            Returns the content of the memory block. 
            </summary>
            <remarks>
            Only creates a copy of the data if they are not represented by a managed byte array.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReader.IMemoryBlock.Pointer">
            <summary>
            The pointer to the start of Memory block. Null after the block has been disposed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MetadataReader.IMemoryBlock.Length">
            <summary>
            Length of the memory block.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SpecialType">
            <summary>
            Ids of special runtime types.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.SpecialType.Count">
            <summary>
            Count of special types. This is not a count of enum members.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.UseMetadataMethodNames">
            <summary>
            ".ctor" instead of "Foo"
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.UseArityForGenericTypes">
            <summary>
            "List`1" instead of "List&lt;T&gt;" ("List(of T)" in VB). Overrides GenericsOptions on
            types.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.FlagMissingMetadataTypes">
            <summary>
            Append "[Missing]" to missing Metadata types (for testing).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.IncludeScriptType">
            <summary>
            Include the Script type when qualifying type names.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.IncludeCustomModifiers">
            <summary>
            Include custom modifiers (e.g. modopt([mscorlib]System.Runtime.CompilerServices.IsConst)) on
            the member (return) type and parameters.
            </summary>
            <remarks>
            CONSIDER: custom modifiers are part of the public API, so we might want to move this to SymbolDisplayMemberOptions.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayCompilerInternalOptions.ReverseArrayRankSpecifiers">
            <summary>
            For a type written as "int[][,]" in C#, then
              a) setting this option will produce "int[,][]", and
              b) not setting this option will produce "int[][,]".
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayDelegateStyle">
            <summary>
            Specifies how to display delegates (just the name or a name with signature).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayDelegateStyle.NameOnly">
            <summary>
            Only show the name of the delegate (e.g. "SomeDelegate").
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayDelegateStyle.NameAndParameters">
            <summary>
            Show the name and the parameters of the delegate.  e.g. "SomeDelegate(int x)".  The format
            of the parameters will be determined by the other flags passed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayDelegateStyle.NameAndSignature">
            <summary>
            Show the name and the signature of the delegate.  e.g. "void SomeDelegate(int x)".  The
            format of the signature will be determined by the other flags passed.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayExtensionMethodStyle">
            <summary>
            Specifies the options for how extension methods are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayExtensionMethodStyle.StaticMethod">
            <summary>
            Display the extension method as a static method. E.g. Enumerable.ElementAt&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source, int index).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayExtensionMethodStyle.InstanceMethod">
            <summary>
            Display the extension method as an instance method. E.g. IEnumerable&lt;TSource&gt;.ElementAt&lt;TSource&gt;(int index).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayExtensions">
            <summary>
            Contains the extension methods used to display the description of a symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.ToDisplayString(Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.SymbolDisplayPart},System.IFormatProvider)">
            <summary>
            Converts an array of string parts to a string.
            </summary>
            <param name="parts">An array of string parts (presumably, from ToDisplayStringParts or
            ToDisplayStringPartsInContext).</param>
            <param name="formatProvider">For formatting values within the symbol - null is passed to
            IFormattable.ToString, which treats it as CultureInfo.CurrentCulture.</param>
            <returns>The concatenation of the string parts into a single string (disregarding part
            kinds)</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayGenericsOptions,Roslyn.Compilers.SymbolDisplayGenericsOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayGenericsOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayMemberOptions,Roslyn.Compilers.SymbolDisplayMemberOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayMemberOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayMiscellaneousOptions,Roslyn.Compilers.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayParameterOptions,Roslyn.Compilers.SymbolDisplayParameterOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayParameterOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayKindOptions,Roslyn.Compilers.SymbolDisplayKindOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayKindOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayExtensions.IncludesOption(Roslyn.Compilers.SymbolDisplayLocalOptions,Roslyn.Compilers.SymbolDisplayLocalOptions)">
            <summary>
            Determines if a flag is set on the <see cref="T:Roslyn.Compilers.SymbolDisplayLocalOptions"/> enum.
            </summary>
            <param name="options">The value to check.</param>
            <param name="flag">An enum field that specifies the flag.</param>
            <returns>Whether the <paramref name="flag"/> is set on the <paramref name="options"/>.</returns>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayFormat">
            <summary>
            Describes the formatting rules that should be used while generating the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.CSharpErrorMessageFormat">
            <summary>
            Standard format for displaying symbols in compiler error messages (C#).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.VisualBasicErrorMessageFormat">
            <summary>
            Standard format for displaying symbols in compiler error messages (Visual Basic).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.FullyQualifiedFormat">
            <summary>
            Fully qualified name format.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.MinimallyQualifiedFormat">
            <summary>
            Format used by default when asking to minimally qualify a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.TestFormat">
            <summary>
            A verbose format for displaying symbols (useful for testing).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.QualifiedNameOnlyFormat">
            <summary>
            this.QualifiedNameOnly = containingSymbol.QualifiedNameOnly + "." + this.Name
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.QualifiedNameArityFormat">
            <summary>
            this.QualifiedNameArity = containingSymbol.QualifiedNameArity + "." + this.Name + "`" + this.Arity
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.ShortFormat">
            <summary>
            A succinct format for displaying symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.ILVisualizationFormat">
            <summary>
            The format used for displaying symbols when visualizing IL.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayFormat.ExplicitInterfaceImplementationFormat">
            <summary>
            Used to normalize explicit interface implementation member names.
            Only expected to be applied to interface types (and their type arguments).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayFormat.#ctor(Roslyn.Compilers.SymbolDisplayGlobalNamespaceStyle,Roslyn.Compilers.SymbolDisplayTypeQualificationStyle,Roslyn.Compilers.SymbolDisplayGenericsOptions,Roslyn.Compilers.SymbolDisplayMemberOptions,Roslyn.Compilers.SymbolDisplayDelegateStyle,Roslyn.Compilers.SymbolDisplayExtensionMethodStyle,Roslyn.Compilers.SymbolDisplayParameterOptions,Roslyn.Compilers.SymbolDisplayAccessorStyle,Roslyn.Compilers.SymbolDisplayLocalOptions,Roslyn.Compilers.SymbolDisplayKindOptions,Roslyn.Compilers.SymbolDisplayMiscellaneousOptions)">
            <summary>
            Constructs a new instance of <see cref="T:Roslyn.Compilers.SymbolDisplayFormat"/> accepting a variety of optional parameters.
            </summary>
            <param name="globalNamespaceStyle"></param>
            <param name="typeQualificationStyle"></param>
            <param name="genericsOptions"></param>
            <param name="memberOptions"></param>
            <param name="delegateStyle"></param>
            <param name="extensionMethodStyle"></param>
            <param name="parameterOptions"></param>
            <param name="accessorStyle"></param>
            <param name="localOptions"></param>
            <param name="kindOptions"></param>
            <param name="miscellaneousOptions"></param>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.GlobalNamespaceStyle">
            <summary>
            Determines how to display references to the global namespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.TypeQualificationStyle">
            <summary>
            Determines how types are qualified (e.g. Nested vs Containing.Nested vs Namespace.Containing.Nested).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.GenericsOptions">
            <summary>
            Determines how generics (on types and methods) should be described (i.e. level of detail).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.MemberOptions">
            <summary>
            Formatting options that apply to fields, properties, and methods.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.ParameterOptions">
            <summary>
            Formatting options that apply to method and indexer parameters (i.e. level of detail).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.DelegateStyle">
            <summary>
            Determines how delegates are displayed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.ExtensionMethodStyle">
            <summary>
            Determines how extension methods are displayed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.AccessorStyle">
            <summary>
            Determines how properties are displayed. "Prop" vs "Prop { get; set; }" ("Prop" vs. "ReadOnly Prop" in VB)
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.LocalOptions">
            <summary>
            Determines how local variables are displayed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.KindOptions">
            <summary>
            Formatting options that apply to types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.MiscellaneousOptions">
            <summary>
            Miscellaneous formatting options.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayFormat.CompilerInternalOptions">
            <summary>
            Flags that can only be set within the compiler.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.FormattedSymbol">
            <summary>
            This class associates a symbol with particular format for display.
            It can be passed as an argument for an error message in place where symbol display should go, 
            which allows to defer building strings and doing many other things (like loading metadata) 
            associated with that until the error message is actually requested.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayGenericsOptions">
            <summary>
            Specifies the options for how generics are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGenericsOptions.None">
            <summary>
            Omit generics entirely.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGenericsOptions.IncludeTypeParameters">
            <summary>
            Type parameters. e.g. "Foo&lt;T&gt;" ("Foo(Of T)" in VB).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGenericsOptions.IncludeTypeConstraints">
            <summary>
            Type parameter constraints.  e.g. "where T : new()" ("Of T as New" in VB).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGenericsOptions.IncludeVariance">
            <summary>
            Use out/in before type parameter if it has one. e.g. "Foo&lt;out T&gt;" ("Foo Of Out T" in VB).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayGlobalNamespaceStyle">
            <summary>
            Specifies the options for how to display the global namespace in the description of a symbol.
            </summary>
            <remarks>
            Any of these styles may be overridden by SymbolDisplayTypeQualificationStyle.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGlobalNamespaceStyle.Omitted">
            <summary>
            Omit the global namespace.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining">
            <summary>
            Omit the global namespace if it is being displayed as a containing symbol (i.e. not on its own).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayGlobalNamespaceStyle.Included">
            <summary>
            Include the global namespace.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayLocalOptions">
            <summary>
            Specifies the options for how locals are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayLocalOptions.None">
            <summary>
            Only show the name of the local. (e.g. "x").
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayLocalOptions.IncludeType">
            <summary>
            Include the type of the local. (e.g. "int x").
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayLocalOptions.IncludeConstantValue">
            <summary>
            Include the value of the local if is a constant. (e.g. "int x = 1").
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayMemberOptions">
            <summary>
            Specifies the options for how members are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.None">
            <summary>
            Display only the name of the member.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeType">
            <summary>
            Include the (return) type of the method/field/property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeModifiers">
            <summary>
            Include modifiers.  e.g. "static readonly" ("Shared ReadOnly" in VB).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeAccessibility">
            <summary>
            Include accessibility.  e.g. "public" ("Public" in VB).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeExplicitInterface">
            <summary>
            Indicate properties and methods that explicitly implement interfaces. e.g. "IFoo.Bar {
            get; }".  This has no effect in VB.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeParameters">
            <summary>
            Include method/indexer parameters.  (See ParameterFlags for fine-grained settings.)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeContainingType">
            <summary>
            Include the name of the containing type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeConstantValue">
            <summary>
            Include the value of the member if is a constant. (e.g. "const int x = 1").
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMemberOptions.IncludeMethodKind">
            <summary>
            Include the method kind (e.g. "Function MyFun()") (supported by VB only).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions">
            <summary>
            Specifies the miscellaneous options for how elements are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.UseSpecialTypes">
            <summary>
            Use keywords for predefined types. "int?" instead of
            "System.Nullable&lt;System.Int32&gt;" ("Integer?" instead of "Nullable(of Integer)" in
            VB)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers">
            <summary>
            "@true" instead of "true".  ("[True]" instead of "True" in VB)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.UseAsterisksInMultiDimensionalArrays">
            <summary>
            "int[][*,*]" instead of "int[][,]".  ("Integer()(*,*)" in VB)
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.UseErrorTypeSymbolName">
            <summary>
            Displays ? for unknown type names
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.RemoveAttributeSuffix">
            <summary>
            Displays attributes names without the "Attribute" suffix, if possible.  This value is
            only respected when getting the minimal display string for a symbol and only applies if
            the context location is one where an attribute can be referenced without the "Attribute"
            suffix.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayMiscellaneousOptions.ExpandNullable">
            <summary>
            Use "System.Nullable&lt;T&gt;" instead of "T?" ("System.Nullable(Of T)" in VB).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayParameterOptions">
            <summary>
            Specifies the options for how parameters are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.None">
            <summary>
            If MemberFlags.IncludeParameters is set, but this value is used, then only the parentheses will be shown
            (e.g. M()).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeExtensionThis">
            <summary>
            Include the 'this' keyword before the first parameter of an extension method. This has no effect in Visual
            Basic.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeParamsRefOut">
            <summary>
            Include the params/ref/out keyword ("ByRef/ByVal" in Visual Basic) before params/ref/out parameters (no
            effect if the type is not included).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeType">
            <summary>
            Include the parameter type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeName">
            <summary>
            Include the parameter name.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeDefaultValue">
            <summary>
            Include the parameter default value (no effect if the name is not included).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayParameterOptions.IncludeOptionalBrackets">
            <summary>
            Include square brackets around optional parameters.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayAccessorStyle">
            <summary>
            Specifies the options for how property/event accessors are displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayAccessorStyle.NameOnly">
            <summary>
            Only show the name of the property (formatted using MemberFlags).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayAccessorStyle.ShowAccessors">
            <summary>
            Show the getter and/or setter of the property (or "ReadOnly"/"WriteOnly" in Visual Basic).
            Alternatively, show the add and/or remove methods of the event.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayPart">
            <summary>
            A classified piece of text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SymbolDisplayPart.ToString(System.IFormatProvider)">
            <summary>
            Returns the display string of a piece of classified text.
            </summary>
            <param name="formatProvider"></param>
            <returns>The display string of a piece of classified text.</returns>
        </member>
        <member name="P:Roslyn.Compilers.SymbolDisplayPart.Kind">
            <summary>
            Gets the kind of a piece of classified text.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayPartKind">
            <summary>
            Specifies the kinds of a piece of classified text (SymbolDisplayPart).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayKindOptions">
            <summary>
            Specifies the options for whether the type's kind should be displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayKindOptions.None">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayKindOptions.IncludeKind">
            <summary>
            Use the type's kind 
            (C#: "Class N1.C1" instead of "N1.C1")
            (VB: "Enum myEnum as Integer" instead of "myEnum as Integer") 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SymbolDisplayTypeQualificationStyle">
            <summary>
            Specifies the options for whether types are qualified when displayed in the description of a symbol.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayTypeQualificationStyle.NameOnly">
            <summary>
            ex) Class1
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayTypeQualificationStyle.NameAndContainingTypes">
            <summary>
            ParentClass.NestedClass
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces">
            <summary>
            Namespace1.Namespace2.Class1.Class2
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonAssemblyWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on an assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonAssemblyWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonNamespaceExtent">
            <summary>
            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a
            particular module, assembly, or merged across all modules (source and metadata) in a
            particular compilation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonNamespaceExtent.#ctor(Roslyn.Compilers.Common.IModuleSymbol)">
            <summary>
            Create a NamespaceExtent that represents a given ModuleSymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonNamespaceExtent.#ctor(Roslyn.Compilers.Common.IAssemblySymbol)">
            <summary>
            Create a NamespaceExtent that represents a given AssemblySymbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonNamespaceExtent.#ctor(Roslyn.Compilers.Common.CommonCompilation)">
            <summary>
            Create a NamespaceExtent that represents a given Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonNamespaceExtent.Kind">
            <summary>
            Returns what kind of extent: Module, Assembly, or Compilation.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonNamespaceExtent.Module">
            <summary>
            If the Kind is ExtendKind.Module, returns the module symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonNamespaceExtent.Assembly">
            <summary>
            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonNamespaceExtent.Compilation">
            <summary>
            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this
            namespace encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CustomAttributesBag`1">
            <summary>
            Represents a bag of custom attributes and the associated decoded well-known attribute data.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.Empty">
            <summary>
            Instance representing sealed custom attribute bag with no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CustomAttributesBag`1.WithEmptyData">
            <summary>
            Returns a non-sealed custom attribute bag with null initialized <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.earlyDecodedWellKnownAttributeData"/>, null initialized <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.decodedWellKnownAttributeData"/> and uninitialized <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.customAttributes"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Roslyn.Compilers.EarlyWellKnownAttributeData)">
            <summary>
            Sets the early decoded well-known attribute data on the bag in a thread safe manner.
            Stored early decoded data is immutable and cannot be updated further.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Roslyn.Compilers.WellKnownAttributeData)">
            <summary>
            Sets the decoded well-known attribute data (except the early data) on the bag in a thread safe manner. 
            Stored decoded data is immutable and cannot be updated further.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CustomAttributesBag`1.SetAttributes(Roslyn.Compilers.ReadOnlyArray{`0})">
            <summary>
            Sets the bound attributes on the bag in a thread safe manner.
            If store succeeds, it seals the bag and makes the bag immutable.
            </summary>
            <returns>Returns true if bound attributes were stored into the bag on this thread.</returns>
        </member>
        <member name="P:Roslyn.Compilers.CustomAttributesBag`1.Attributes">
            <summary>
            Gets the stored bound attributes in the bag.
            </summary>
            <remarks>This property can only be accessed on a sealed bag.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CustomAttributesBag`1.DecodedWellKnownAttributeData">
            <summary>
            Gets the decoded well-known attribute data (except the early data) in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Roslyn.Compilers.CustomAttributesBag`1.SetDecodedWellKnownAttributeData(Roslyn.Compilers.WellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData">
            <summary>
            Gets the early decoded well-known attribute data in the bag. 
            </summary>
            <remarks>This property can only be accessed on the bag after <see cref="M:Roslyn.Compilers.CustomAttributesBag`1.SetEarlyDecodedWellKnownAttributeData(Roslyn.Compilers.EarlyWellKnownAttributeData)"/> has been invoked.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.CustomAttributesBag`1.IsEarlyDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether early decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Roslyn.Compilers.CustomAttributesBag`1.EarlyDecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes or remaining decoded attribute data has also been initialized.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CustomAttributesBag`1.IsDecodedWellKnownAttributeDataComputed">
            <summary>
            Return whether all decoded attribute data has been computed and stored on the bag and it is safe to access <see cref="P:Roslyn.Compilers.CustomAttributesBag`1.DecodedWellKnownAttributeData"/> from this bag.
            Return value of true doesn't guarantee that bound attributes have also been initialized.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart">
            <summary>
            Enum representing the current state of attribute binding/decoding for a corresponding CustomAttributeBag.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.None">
            <summary>
            Bag has been created, but no decoded data or attributes have been stored.
            CustomAttributeBag is in this state during early decoding phase.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData">
            <summary>
            Early decoded attribute data has been computed and stored on the bag, but bound attributes or remaining decoded attribute data is not stored.
            Only <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData">
            <summary>
            All decoded attribute data has been computed and stored on the bag, but bound attributes are not yet stored.
            Both <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.EarlyDecodedWellKnownAttributeData"/> and <see cref="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.DecodedWellKnownAttributeData"/> can be accessed from this bag.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.Attributes">
            <summary>
            Bound attributes have been computed and stored on this bag.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.CustomAttributesBag`1.CustomAttributeBagCompletionPart.All">
            <summary>
            CustomAttributeBag is completely initialized and immutable.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonTypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonTypeWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MarshalPseudoCustomAttributeData">
            <summary>
            Information decoded from <see cref="T:System.Runtime.InteropServices.MarshalAsAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMarshallingInformation">
            <summary>
            Information about how values of managed types should be marshalled to and from unmanaged types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.CustomMarshaller">
            <summary>
            <see cref="T:Microsoft.Cci.ITypeReference"/> or a fully-qualified type name of a type implementing the custom marshaller.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.CustomMarshallerRuntimeArgument">
            <summary>
            An argument string (cookie) passed to the custom marshaller at run time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ElementType">
            <summary>
            The unmanged element type of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.IidParameterIndex">
            <summary>
            Specifies the index of the parameter that contains the value of the Inteface Identifier (IID) of the marshalled object.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.UnmanagedType">
            <summary>
            The unmanaged type to which the managed type will be marshalled. This can be be UnmanagedType.CustomMarshaler, in which case the unmanaged type
            is decided at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.NumberOfElements">
            <summary>
            The number of elements in the fixed size portion of the unmanaged array.
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.ParamIndex">
            <summary>
            The zero based index of the parameter in the unmanaged method that contains the number of elements in the variable portion of unmanaged array.
            If -1, the variable portion is of size zero, or the caller conveys the size of the variable portion of the array to the unmanaged method in some other way.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.SafeArrayElementSubtype">
            <summary>
            The type to which the variant values of all elements of the safe array must belong. See also SafeArrayElementUserDefinedSubtype.
            (The element type of a safe array is VARIANT. The "sub type" specifies the value of all of the tag fields (vt) of the element values. )
            -1 if it should be omitted from the marshal blob.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMarshallingInformation.SafeArrayElementUserDefinedSubtype">
            <summary>
            A reference to the user defined type to which the variant values of all elements of the safe array must belong.
            (The element type of a safe array is VARIANT. The tag fields will all be either VT_DISPATCH or VT_UNKNOWN or VT_RECORD.
            The "user defined sub type" specifies the type of value the ppdispVal/ppunkVal/pvRecord fields of the element values may point to.)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonFieldWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonFieldWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the field.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IErrorTypeSymbol">
            <summary>
            An IErrorTypeSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an IErrorTypeSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.INamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.INamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ISymbol">
            <summary>
            Represents a symbol (namespace, class, method, parameter, etc.)
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.GetSymbolId">
            <summary>
            Gets the SymbolId for this ISymbol.  The SymbolId is a lightweight identifier for a
            symbol that can be used to resolve the same symbol across compilations.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.GetAttributes">
            <summary>
            Gets the attributes for the symbol. Returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            if there are no attributes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.GetAttributes(Roslyn.Compilers.Common.INamedTypeSymbol)">
            <summary>
            Gets the attributes of a given attribute class on this symbol. Returns an empty
            ReadOnlyArray if there are no attributes.
            </summary>
            <param name="attributeType">The type of attribute to check for.</param>
            <returns>All attributes of the given type, or an empty ReadOnlyArray if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.GetAttributes(Roslyn.Compilers.Common.IMethodSymbol)">
            <summary>
            Gets the attributes on this symbol which are specified with the given attribute constructor.
            Returns an empty ReadOnlyArray if there are no such attributes.
            </summary>
            <param name="attributeConstructor">Attribute constructor to check for.</param>
            <returns>Attributes specified with the given constructor, or an empty ReadOnlyArray if none.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.GetDocumentationComment(System.Globalization.CultureInfo,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.DocumentationComment"/> for the comment associated with the symbol.
            </summary>
            <param name="preferredCulture">Preferred culture or null for the default.</param>
            <param name="cancellationToken">Token allowing cancellation of request.</param>
            <returns>The comment associated with the symbol.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.ToDisplayString(Roslyn.Compilers.SymbolDisplayFormat,System.IFormatProvider)">
            <summary>
            Converts the symbol to a string representation.
            </summary>
            <param name="format">Format or null for the default.</param>
            <param name="formatProvider">Format provider or null for the default.</param>
            <returns>A formatted string representation of the symbol.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISymbol.ToDisplayParts(Roslyn.Compilers.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="format">Formatting rules - null implies
            SymbolDisplayFormat.ErrorMessageFormat.</param>
            <returns>A read-only array of string parts.</returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.Kind">
            <summary>
            Gets the <see cref="E:Roslyn.Compilers.CommonSymbolKind"/> indicating what kind of symbol it is.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.Language">
            <summary>
            Gets the source language ("C#" or "Visual Basic").
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.Name">
            <summary>
            Gets the symbol name. Returns the empty string if unnamed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            3) The length of names is limited to not exceed metadata restrictions.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.ContainingSymbol">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.ISymbol"/> for the immediately containing symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.ContainingAssembly">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.IAssemblySymbol"/> for the containing assembly. Returns null if the
            symbol is shared across multiple assemblies.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.ContainingModule">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.IModuleSymbol"/> for the containing module. Returns null if the
            symbol is shared across multiple modules.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.ContainingType">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.INamedTypeSymbol"/> for the containing type. Returns null if the
            symbol is not contained within a type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.ContainingNamespace">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.INamespaceSymbol"/> for the nearest enclosing namespace. Returns null if the
            symbol isn't contained in a namespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsDefinition">
            <summary>
            Gets a value indicating whether the symbol is the original definition. Returns false
            if the symbol is derived from another symbol, by type substitution for instance.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsStatic">
            <summary>
            Gets a value indicating whether the symbol is static.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsVirtual">
            <summary>
            Gets a value indicating whether the symbol is virtual.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsOverride">
            <summary>
            Gets a value indicating whether the symbol is an override of a base class symbol.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsAbstract">
            <summary>
            Gets a value indicating whether the symbol is abstract.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsSealed">
            <summary>
            Gets a value indicating whether the symbol is sealed.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsObsolete">
            <summary>
            Gets a value indicating whether the symbol is marked as obsolete.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsExtern">
            <summary>
            Gets a value indicating whether the symbol is defined externally.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not have
            an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense, and may be
            used by code, but that are simply declared implicitly rather than with explicit language
            syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              this "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.DeclaringSyntaxNodes">
            <summary>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for example,
            partial classes) may be defined in more than one location. This property should return
            one or more syntax nodes only if the symbol was declared in source code and also was
            not implicitly declared (see the IsImplicitlyDeclared property). 
            
            Note that for namespace symbol, the declaring syntax might be declaring a nested namespace.
            For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is the entire
            NamespaceDeclarationSyntax for N1.N2. For the global namespace, the declaring syntax will
            be the CompilationUnitSyntax.
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata
            or was implicitly declared, returns an empty read-only array.
            </returns>
            <remarks>
            To go the opposite direction (from syntax node to symbol), see <see cref="M:Roslyn.Compilers.Common.ISemanticModel.GetDeclaredSymbol(Roslyn.Compilers.Common.CommonSyntaxNode,System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.DeclaredAccessibility">
            <summary>
            Gets a <see cref="T:Roslyn.Compilers.Common.CommonAccessibility"/> indicating the declared accessibility for the symbol.
            Returns NotApplicable if no accessibility is declared.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISymbol.OriginalDefinition">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.Common.ISymbol"/> for the original definition of the symbol.
            If this symbol is derived from another symbol, by type substitution for instance,
            this gets the original symbol, as it was defined in source or metadata.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>A ReadOnlyArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ReadOnlyArray. Never returns Null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>A ReadOnlyArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ReadOnlyArray. Never returns null.</returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. If it is not a type, it must be a namespace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ITypeSymbol.FindImplementationForInterfaceMember(Roslyn.Compilers.Common.ISymbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.TypeKind">
            <summary>
            An enumerated value that identifies whether this type is an array, pointer, enum, and so on.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.BaseType">
            <summary>
            The declared base type of this type, or null. The object type, interface types,
            and pointer types do not have a base type. The base type of a type parameter
            is its effective base class.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces. This does
            include the interfaces declared as constraints on type parameters.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively).  This also is the effective
            interface set of a type parameter. Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerble&lt;object&gt;
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.IsReferenceType">
            <summary>
            True if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.IsValueType">
            <summary>
            True if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including delegate).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeSymbol.SpecialType">
            <summary>
            An enumerated value that identifies certain 'special' types such as System.Object. 
            Returns SpecialType.None if the type is not special.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamedTypeSymbol.Construct(Roslyn.Compilers.Common.ITypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type. A generic type is
            considered <em>unbound</em> if all of the type argument lists in its fully qualified
            name are empty. Note that the type arguments of an unbound generic type will be
            returned as error types because they do not really have type arguments.  An unbound
            generic type yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.MemberNames">
            <summary>
            Returns collection of names of members declared within this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ReadOnlyArray.  
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this type symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that is is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamedTypeSymbol.AssociatedEvent">
            <summary>
            For implicitly declared delegate types returns the EventSymbol that caused this
            delegate type to be generated.
            For all other types returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this type, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
            <remarks>
            This only applies if this INamedTypeSymbol has TypeKind CommonTypeKind.Error.
            If not, an empty ReadOnlyArray is returned.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.IErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IRangeVariableSymbol">
            <summary>
            Represents a range variable in a query expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonMethodWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonMethodWellKnownAttributeData.SecurityInformation">
            <summary>
            Returns data decoded from security attributes or null if there are no security attributes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.NamespaceExtentKind">
            <summary>
            Describes the kind of the namespace extent.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IEventSymbol">
            <summary>
            Represents an event.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.Type">
            <summary>
            The type of the event. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.RaiseMethod">
            <summary>
            The 'raise' accessor of the event.  Null if there is no raise method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.OriginalDefinition">
            <summary>
            The original definition of the event. If the event is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this event.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.Common.IAliasSymbol">
            <summary>
            Represents a using alias (Imports alias in Visual Basic).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Roslyn.Compilers.Common.INamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IArrayTypeSymbol">
            <summary>
            Represents an array.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of this array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IAssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IAssemblySymbol.GivesAccessTo(Roslyn.Compilers.Common.IAssemblySymbol)">
            <summary>
            Gets a value indicating whether this assembly gives 
            <paramref name="toAssembly"/> access to internal symbols</summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IAssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="metadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.Identity">
            <summary>
            Gets the name of this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.Modules">
            <summary>
            Gets the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IAssemblySymbol.BaseName">
            <summary>
            Get the base name of the assembly. This is equivalent to AssemblyName.Name, but may be 
            much faster to retrieve for source code assemblies, since it does not require binding
            the assembly-level attributes that contain the version number and other assembly
            information.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IDynamicTypeSymbol">
            <summary>
            Represents the 'dynamic' type in C#.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IFieldSymbol">
            <summary>
            Represents a field in a class, struct or enum.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.AssociatedPropertyOrEvent">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that property/event. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or errorneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.ConstantValue">
            <summary>
            Gets the constant value of this field
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IFieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ILabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing <see cref="T:Roslyn.Compilers.Common.IMethodSymbol"/> of this <see cref="T:Roslyn.Compilers.Common.ILocalSymbol"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ILocalSymbol">
            <summary>
            Represents a local variable in method body
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILocalSymbol.Type">
            <summary>
            Gets the type of this local variable.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILocalSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing <see cref="T:Roslyn.Compilers.Common.IMethodSymbol"/> of this <see cref="T:Roslyn.Compilers.Common.ILocalSymbol"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILocalSymbol.HasConstantValue">
            <summary>
            Returns false if the local variable wasn't declared as "const", or constant value was omitted or errorneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ILocalSymbol.ConstantValue">
            <summary>
            Gets the constant value of this local variable
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IMethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IMethodSymbol.ReduceExtensionMethod(Roslyn.Compilers.Common.ITypeSymbol)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IMethodSymbol.Construct(Roslyn.Compilers.Common.ITypeSymbol[])">
            <summary>
            Returns a constructed method given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the method.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.IMethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for
             C-style variable argument lists. This is used extremely rarely in C# code and is
             represented using the undocumented __arglist keyword.
            
             Note that methods with params on the last parameter are indicated with the IsParams
             property on ParameterSymbol, and are not represented with this property.
             </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.OriginalDefinition">
            <summary>
            Get the original definition of this symbol. If this symbol is derived from another
            symbol by (say) type substitution, this gets the original symbol, as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, returns the extension
            method from which this was reduced. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ReadOnlyArray.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.ReturnTypeAttributes">
            <summary>
            Returns the list of custom attributes, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.AssociatedPropertyOrEvent">
            <summary>
            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
            returns the property that this method is the getter or setter for.
            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
            returns the event that this method is the adder or remover for.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method implementation part, returns the corresponding
            definition part.  Otherwise null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IMethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method is
            implemented with a body, returns that implementing definition.  Otherwise
            null.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IModuleSymbol.GetModuleNamespace(Roslyn.Compilers.Common.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.INamedTypeSymbolExtensions">
            <summary>
            Defines extension methods for the INamedTypeSymbol interface.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamedTypeSymbolExtensions.GetStaticConstructors(Roslyn.Compilers.Common.INamedTypeSymbol)">
            <summary>
            Returns static constructors.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamedTypeSymbolExtensions.GetConstructors(Roslyn.Compilers.Common.INamedTypeSymbol)">
            <summary>
            Get the constructors.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.INamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.INamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceSymbol.Extent">
            <summary>
            Namespaces are by their nature open-ended, but a NamespaceSymbol contains a specific set
            of members. The set of members contained by a NamespaceSymbol is denoted by the Extent
            of the namespace. If a Namespace has an module Extent, it contains members of the
            namespace that are present in a particular module. If a Namespace has an compilation
            extent, it contains all members of the namespace in a compilation, including those
            defined in source and all directly referenced metadata assemblies (or added metadata
            modules). 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace has Assembly or Compilation extent, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.INamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IParameterSymbol">
            <summary>
            Represents a parameter of a method or property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.RefKind">
            <summary>
            Whether the parameter passed by value or by reference.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is optional.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' ('Me' in Visual Basic) parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The 'this' parameter ('Me' in Visual Basic) has ordinal -1.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.HasDefaultValue">
            <summary>
            Returns true if the parameter specifies a default value to be passed
            when no value is provided as an argument to a call. The default value
            can be obtained with the DefaultValue property.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IParameterSymbol.DefaultValue">
            <summary>
            Returns the default value of the parameter. 
            </summary>
            <remarks>
            Returns null if the parameter type is a struct and the default value of the parameter
            is the default value of the struct type.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="T:Roslyn.Compilers.Common.IPointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            (Some managed languages may represent special information about the pointer type
            as a custom modifier on either the pointer type or the element type, or
            both.)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IPropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.IsWithEvents">
            <summary>
            Returns true if this property is an auto-created WithEvents property that takes place of
            a field member when the field is marked as WithEvents.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.OriginalDefinition">
            <summary>
            The original definition of the property. If the property is constructed from another
            symbol by type substitution, OriginalDefinition gets the original symbol, as it was 
            defined in source or metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.IPropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonTypedConstant">
            <summary>
            Represents a constant value used as an argument to a custom attribute.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonTypedConstant.GetTypedConstantKind(Roslyn.Compilers.Common.ITypeSymbol,Roslyn.Compilers.Common.CommonCompilation)">
            <remarks>
            TypedConstant isn't computing its own kind from the type symbol because it doesn't
            have a way to recognize the well-known type System.Type.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypedConstant.Kind">
            <summary>
            The kind of the constant.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypedConstant.Type">
            <summary>
            Returns the <see cref="T:Roslyn.Compilers.Common.ITypeSymbol"/> of the constant, 
            or null if the type can't be determined (error).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypedConstant.Value">
            <summary>
            The value for a non-array constant.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonTypedConstant.Values">
            <summary>
            The value for an <see cref="T:Roslyn.Compilers.Common.CommonTypedConstant"/> array.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.ITypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.Variance">
            <summary>
            The variance annotation, if any, of the type parameter declaration. Type parameters may be 
            declared as 'in' (contravariant), 'out' (covariant) or neither.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.IsMethodTypeParameter">
            <summary>
            True if the type parameter is declared by a generic method.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.DeclaringType">
            <summary>
            The type that declares the type parameter, or null.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.HasReferenceTypeConstraint">
            <summary>
            True if the reference type constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.HasValueTypeConstraint">
            <summary>
            True if the value type constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ITypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonMethodKind">
            <summary>
            Enumeration for possible kinds of method symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.AnonymousFunction">
            <summary>
            An anonymous method or lambda expression
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.Constructor">
            <summary>
            Method is a constructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.Conversion">
            <summary>
            Method is a conversion.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.DelegateInvoke">
            <summary>
            Method is a delegate invoke.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.Destructor">
            <summary>
            Method is a destructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.EventAdd">
            <summary>
            Method is an event add.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.EventRaise">
            <summary>
            Method is an event raise.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.EventRemove">
            <summary>
            Method is an event remove.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.ExplicitInterfaceImplementation">
            <summary>
            Method is an explicit interface implementation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.Operator">
            <summary>
            Method is an operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.Ordinary">
            <summary>
            Method is an ordinary method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.PropertyGet">
            <summary>
            Method is a property get.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.PropertySet">
            <summary>
            Method is a property set.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.ReducedExtension">
            <summary>
            An extension method with the "this" parameter removed.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMethodKind.StaticConstructor">
            <summary>
            Method is a static constructor.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonTypeKind">
            <summary>
            Enumeration for possible kinds of type symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Unknown">
            <summary>
            Type's kind is undefined.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.ArrayType">
            <summary>
            Type is an array type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Class">
            <summary>
            Type is a class.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Delegate">
            <summary>
            Type is a delegate.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.DynamicType">
            <summary>
            Type is dynamic.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Enum">
            <summary>
            Type is an enumeration.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Error">
            <summary>
            Type is an error type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Interface">
            <summary>
            Type is an interface.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Module">
            <summary>
            Type is a module.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.PointerType">
            <summary>
            Type is a pointer.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Struct">
            <summary>
            Type is a struct.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.TypeParameter">
            <summary>
            Type is a type parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonTypeKind.Submission">
            <summary>
            Type is an interactive submission.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonMemberNames">
            <summary>
            Specifies the member names known to the compiler (such as .ctor or op_Explicit).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.EnumBackingFieldName">
            <summary>
            Name of the enum backing field.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.InstanceConstructorName">
            <summary>
            The name assigned to an instance constructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.StaticConstructorName">
            <summary>
            The name assigned to the static constructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.Indexer">
            <summary>
            The symbol name assigned to all indexers, other than explicit interface implementations.
            </summary>
            <remarks>
            Will not correspond to the name that appears in metadata.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DestructorName">
            <summary>
            The name assigned to the destructor.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DelegateInvokeName">
            <summary>
            The name assigned to the delegate invoke method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DelegateBeginInvokeName">
            <summary>
            The name assigned to the delegate BeginInvoke method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DelegateEndInvokeName">
            <summary>
            The name assigned to the delegate EndInvoke method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.EntryPointMethodName">
            <summary>
            The name of an entry point method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DefaultScriptClassName">
            <summary>
            The default fully qualified name of a Script class.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ObjectToString">
            <summary>
            The name assigned to Object.ToString method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ObjectEquals">
            <summary>
            The name assigned to Object.Equals method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ObjectGetHashCode">
            <summary>
            The name assigned to Object.GetHashCode method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ImplicitConversionName">
            <summary>
            The name assigned to an implicit (widening) conversion.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ExplicitConversionName">
            <summary>
            The name assigned to an explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.AdditionOperatorName">
            <summary>
            The name assigned to the Addition operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.BitwiseAndOperatorName">
            <summary>
            The name assigned to the BitwiseAnd operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.BitwiseOrOperatorName">
            <summary>
            The name assigned to the BitwiseOr operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DecrementOperatorName">
            <summary>
            The name assigned to the Decrement operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.DivisionOperatorName">
            <summary>
            The name assigned to the Division operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.EqualityOperatorName">
            <summary>
            The name assigned to the Equality operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ExclusiveOrOperatorName">
            <summary>
            The name assigned to the ExclusiveOr operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.FalseOperatorName">
            <summary>
            The name assigned to the False operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.GreaterThanOperatorName">
            <summary>
            The name assigned to the GreaterThan operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.GreaterThanOrEqualOperatorName">
            <summary>
            The name assigned to the GreaterThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.IncrementOperatorName">
            <summary>
            The name assigned to the Increment operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.InequalityOperatorName">
            <summary>
            The name assigned to the Inequality operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LeftShiftOperatorName">
            <summary>
            The name assigned to the LeftShift operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.UnsignedLeftShiftOperatorName">
            <summary>
            The name assigned to the UnsignedLeftShift operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LessThanOperatorName">
            <summary>
            The name assigned to the LessThan operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LessThanOrEqualOperatorName">
            <summary>
            The name assigned to the LessThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LogicalNotOperatorName">
            <summary>
            The name assigned to the LogicalNot operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LogicalOrOperatorName">
            <summary>
            The name assigned to the LogicalOr operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LogicalAndOperatorName">
            <summary>
            The name assigned to the LogicalAnd operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ModulusOperatorName">
            <summary>
            The name assigned to the Modulus operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.MultiplyOperatorName">
            <summary>
            The name assigned to the Multiply operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.OnesComplementOperatorName">
            <summary>
            The name assigned to the OnesComplement operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.RightShiftOperatorName">
            <summary>
            The name assigned to the RightShift operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.UnsignedRightShiftOperatorName">
            <summary>
            The name assigned to the UnsignedRightShift operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.SubtractionOperatorName">
            <summary>
            The name assigned to the Subtraction operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.TrueOperatorName">
            <summary>
            The name assigned to the True operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.UnaryNegationOperatorName">
            <summary>
            The name assigned to the UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.UnaryPlusOperatorName">
            <summary>
            The name assigned to the UnaryPlus operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ConcatenateOperatorName">
            <summary>
            The name assigned to the Concatenate operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ExponentOperatorName">
            <summary>
            The name assigned to the Exponent operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.IntegerDivisionOperatorName">
            <summary>
            The name assigned to the IntegerDivision operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.LikeOperatorName">
            <summary>
            The name assigned to the Like operator.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.GetEnumeratorMethodName">
            <summary>
            The required name for the GetEnumerator method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.MoveNextMethodName">
            <summary>
            The required name for the MoveNext method used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.CurrentPropertyName">
            <summary>
            The required name for the Current property used in a ForEach statement.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.ValuePropertyName">
            <summary>
            The required name for the Nullable&lt;T&gt;.Value property used in
            a ForEach statement when the collection is a nullable struct.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonMemberNames.CollectionInitializerAddMethodName">
            <summary>
            The name for the Add method to be invoked for each element in a Collection initializer expression.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.LanguageNames">
            <summary>
            A class that provides constants for common language names.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.LanguageNames.CSharp">
            <summary>
            The common name used from the C# language.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.LanguageNames.VisualBasic">
            <summary>
            The common name used for the Visual Basic language.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CommonParameterWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.CommonParameterWellKnownAttributeData.MarshallingInformation">
            <summary>
            Returns marshalling data or null of MarshalAs attribute isn't applied on the parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.RefKind">
            <summary>
            Denotes the kind of reference parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.RefKind.None">
            <summary>
            Indicates a "value" parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.RefKind.Ref">
            <summary>
            Indicates a "ref" parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.RefKind.Out">
            <summary>
            Indicates an "out" parameter.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonAccessibility">
            <summary>
            Enumeration for common accessibility combinations.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.NotApplicable">
            <summary>
            No accessibility specified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.Public">
            <summary>
            Public access.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.Protected">
            <summary>
            Protected access.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.Private">
            <summary>
            Private access.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.Internal">
            <summary>
            Internal access.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.ProtectedOrInternal">
            <summary>
            Protected or internal access.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonAccessibility.ProtectedAndInternal">
            <summary>
            Protected internal access.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TypedConstantKind">
            <summary>
            Represents the kind of a TypedConstant.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.VarianceKind">
            <summary>
            An enumeration declaring the kinds of variance supported for generic type parameters.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.VarianceKind.None">
            <summary>
            invariant
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.VarianceKind.Out">
            <summary>
            "Out" - covariant
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.VarianceKind.In">
            <summary>
            "In" - contravariant
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSymbolKind">
            <summary>
            Specifies the possible kinds of symbols.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Alias">
            <summary>
            Symbol is an alias.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.ArrayType">
            <summary>
            Symbol is an array type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Assembly">
            <summary>
            Symbol is an assembly.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.DynamicType">
            <summary>
            Symbol is a dynamic type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Event">
            <summary>
            Symbol is an Event.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Field">
            <summary>
            Symbol is a field.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Label">
            <summary>
            Symbol is a label.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Local">
            <summary>
            Symbol is a local.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Method">
            <summary>
            Symbol is a method.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.NetModule">
            <summary>
            Symbol is a netmodule.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.NamedType">
            <summary>
            Symbol is a named type (e.g. class).
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Namespace">
            <summary>
            Symbol is a namespace.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Parameter">
            <summary>
            Symbol is a parameter.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.PointerType">
            <summary>
            Symbol is a pointer type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.Property">
            <summary>
            Symbol is a property.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.RangeVariable">
            <summary>
            Symbol is a range variable of a query expression.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSymbolKind.TypeParameter">
            <summary>
            Symbol is a type parameter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.ReplaceNodes``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxNode},System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNodes">The nodes to be replaced; descendants of the root node.</param>
            <param name="computeReplacementNode">A function that computes a replacement node for the
            argument nodes. The first argument is the original node. The second argument is the same
            node rewritten with replaced descendants.</param>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.ReplaceNode``2(``0,``1,``1)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <typeparam name="TNode">The type of the replaced node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldNode">The node to be replaced; a descendant of the root node.</param>
            <param name="newNode">The new node to use in the new tree in place of the old node.</param>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.ReplaceTokens``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxToken},System.Func{Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldTokens">The token to be replaced; descendants of the root node.</param>
            <param name="computeReplacementToken">A function that computes a replacement token for
            the argument tokens. The first argument is the original token. The second argument is
            the same token rewritten with replaced trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.ReplaceToken``1(``0,Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
            <typeparam name="TRoot">The type of the root node.</typeparam>
            <param name="root">The root node of the tree of nodes.</param>
            <param name="oldToken">The token to be replaced.</param>
            <param name="newToken">The new token to use in the new tree in place of the old
            token.</param>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.RemoveNode``1(``0,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed. The associated trivia is distributed to the next
            token or is returned as residual trivia if no token is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonSyntaxNodeExtensions.RemoveNodes``1(``0,System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxNode},Roslyn.Compilers.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified nodes removed. The associated trivia is distributed to the next
            token or is returned as residual trivia if no token is available.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SyntaxAnnotation">
            <summary>
            Annotates syntax with additional information. As syntax elements are immutable they can not
            actually be annotated with information. However, new syntax elements can be created from an
            existing syntax element and an annotation to return an entirely new syntax element with that
            associated annotation.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SyntaxAnnotation.ElasticAnnotation">
            <summary>
            predefined syntax annotation that indicates whether one has a elastric trivia or not
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.SyntaxAnnotation.AddAnnotationTo``1(``0)">
            <summary>
            Adds this annotation to the given syntax node, creating a new syntax node of the same
            type with the annotation on it.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Roslyn.Compilers.CSharp.SyntaxNode"/> and <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.HasAnnotations(System.Type)">
            <summary>
            Determines if this node has annotations of the specified type. 
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines if this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.GetAnnotations(System.Type)">
            <summary>
            Gets all annotations of the specified type attached to this node.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.ChildNodesAndTokens">
            <summary>
            The children nodes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IBaseSyntaxNode.Kind">
            <summary>
            A integer representing the language specific kind of node
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetText">
            <summary>
            Gets the full text of this node as an new IText instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.EquivalentTo(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Determine whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetChildPosition(System.Int32)">
            <summary>
            Determines position of a child at the slotIndex
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetReference">
            <summary>
            Gets an ISyntaxReference for this syntax node. ISyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of this node, where each element is a CommonSyntaxNodeOrToken instance.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ChildNodes">
            <summary>
            Gets a list of the child nodes in prefix document order. This list does not contain tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.Ancestors(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.AncestorsAndSelf(System.Boolean)">
            <summary>
            Gets a list of ancestor nodes (including this node) 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FirstAncestorOrSelf``1(System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Gets the first node of type TNode that matches the predicate.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodes(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodes(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndSelf(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndTokens(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndTokensAndSelf(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantNodesAndTokensAndSelf(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of the descendant nodes and tokens (including this node) in prefix document order.
            </summary>
            <param name="span">The span the node's full span must intersect.</param>
            <param name="descendIntoChildren">An optional function that determines if the search descends into the argument node's children.</param>
            <param name="descendIntoTrivia">Determines if nodes that are part of structured trivia are included in the list.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The first token or <c>default(CommonSyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last token of the tree rooted by this node. Skips zero-width tokens.
            </summary>
            <returns>The last token or <c>default(CommonSyntaxToken)</c> if it doesn't exist.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantTokens(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant tokens under this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantTokens(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Gets a list of descendant tokens under this node with a full span that intersects the specified span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)
            includes the position.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantTrivia(System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.DescendantTrivia(Roslyn.Compilers.TextSpan,System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean},System.Boolean)">
            <summary>
            Get a list of all the trivia associated with the descendant nodes and tokens.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.HasAnnotations(System.Type)">
            <summary>
            Determines whether this node has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this node has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotations(System.Type)">
            <summary>
            Gets all the annotations of the specified type attached to this node. 
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedNodesAndTokens(System.Type)">
            <summary>
            Gets all nodes and tokens with an annotation of the specified type. The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedNodesAndTokens(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Gets all nodes and tokens with the specified annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedTrivia(System.Type)">
            <summary>
            Gets all trivia with an annotation of the specified type. The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedTrivia(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Finds all trivia with this specific annotation attached, that are on or under the trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.CopyAnnotationsTo``1(``0)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name="node" />.
            </summary>
            <remarks>
            <para>
            If no annotations are copied, just returns <paramref name="node" />.
            </para>
            <para>
            It can also be used manually to preserve annotations in a more complex tree
            modification, even if the type of a node changes.
            </para>
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.IsEquivalentTo(Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the node are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ChildNodesAndTokensCore">
            <summary>
            The list of child nodes and tokens of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetLeadingTriviaCore">
            <summary>
            The list of trivia that appear before this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetTrailingTriviaCore">
            <summary>
            The list of trivia that appear after this node in the source code and are attached to a token that is a
            descendant of this node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.EquivalentToCore(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FindTokenCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="findInsideTrivia">
            True to return tokens that are part of trivia.
            If false finds the token whose full span (including trivia) includes the position.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FindTokenCore(System.Int32,System.Func{Roslyn.Compilers.Common.CommonSyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant token of this node whose span includes the supplied position. 
            </summary>
            <param name="position">The character position of the token relative to the beginning of the file.</param>
            <param name="stepInto">
            Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. 
            Pass null to skip all structured trivia.
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.FindTriviaCore(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ReplaceNodesCore(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxNode},System.Func{Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ReplaceNodeCore(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.RemoveNodeCore(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.RemoveNodesCore(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxNode},Roslyn.Compilers.SyntaxRemoveOptions)">
            <summary>
            Creates a new tree of nodes with the specified node removed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ReplaceTokensCore(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonSyntaxToken},System.Func{Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken})">
            <summary>
            Creates a new tree of nodes with the specified old node replaced with a new node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.ReplaceTokenCore(Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Creates a new tree of nodes with the specified old token replaced with a new token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedNodesAndTokensCore(System.Type)">
            <summary>
            Finds all nodes with an annotation of the specified type. The type must be a strict subtype of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedNodesAndTokensCore(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Finds all nodes with the specified annotation attached.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedTriviaCore(System.Type)">
            <summary>
            Finds all trivia with an annotation of the specified type. The type must be a strict subtype of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.GetAnnotatedTriviaCore(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Finds all the trivia with the specified annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNode.IsEquivalentToCore(Roslyn.Compilers.Common.CommonSyntaxNode,System.Boolean)">
            <summary>
            Determines if two nodes are the same, disregarding trivia differences.
            </summary>
            <param name="node">The node to compare against.</param>
            <param name="topLevel"> If true then the nodes are equivalent if the contained nodes and
            tokens declaring metadata visible symbolic information are equivalent, ignoring any
            differences of nodes inside method bodies or initializer expressions, otherwise all
            nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.Kind">
            <summary>
            An integer representing the language specific kind of this node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.SyntaxTree">
            <summary>
            Returns CommonSyntaxTree that owns the node or null if node does not belong to a
            CommonSyntaxTree
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.Span">
            <summary>
            The absolute span of this node in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.FullSpan">
            <summary>
            The absolute span of this node in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.IsMissing">
            <summary>
            Determines whether the node represents a language construct that was actually parsed
            from the source code. Missing nodes are generated by the parser in error scenarios to
            represent constructs that should have been present in the source code in order to
            compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.IsStructuredTrivia">
            <summary>
            Determines whether this node represents a structured trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.ContainsDirectives">
            <summary>
            Determines whether this node has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.ContainsDiagnostics">
            <summary>
            Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.HasLeadingTrivia">
            <summary>
            Determines whether this node has any leading trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.HasTrailingTrivia">
            <summary>
            Determines whether this node has any trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.ContainsAnnotations">
            <summary>
            Determines whether this node or any sub node, token or trivia has annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.KindCore">
            <summary>
            An integer representing the language specific kind of node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.ParentCore">
            <summary>
            The node that holds this node in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNode.SyntaxTreeCore">
            <summary>
            Returns CommonSyntaxTree that owns the node or null if node does not belong to a
            CommonSyntaxTree
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken">
            <summary>
            A wrapper for either a syntax node (<see cref="T:Roslyn.Compilers.CommonSyntaxNode"/>) or a syntax token (<see
            cref="T:Roslyn.Compilers.CommonSyntaxToken"/>).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.AsToken">
            <summary>
            Returns the underlying token if this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a
            token.
            </summary>
            <returns>
            The underlying token if this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a token.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.AsNode">
            <summary>
            Returns the underlying node if this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a
            node.
            </summary>
            <returns>
            The underlying node if this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a node.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ChildNodesAndTokens">
            <summary>
            The list of child nodes and tokens of the underlying node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ToString">
            <summary>
            Returns the string representation of this node or token, not including its leading and trailing
            trivia.
            </summary>
            <returns>The string representation of this node or token, not including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ToFullString">
            <summary>
            Returns the full string representation of this node or token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node or token including its leading and trailing
            trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node or token to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetLeadingTrivia">
            <summary>
            The list of trivia that appear before the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetTrailingTrivia">
            <summary>
            The list of trivia that appear after the underlying node or token in the source code and are attached to a
            token that is a descendant of the underlying node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.HasAnnotations(System.Type)">
            <summary>
            Determines whether this node or token has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines if this node or token has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetAnnotations(System.Type)">
            <summary>
            Gets all annotations of the specified type attached to this node or token.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Equals(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Equality(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken,Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Inequality(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken,Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Implicit(Roslyn.Compilers.Common.CommonSyntaxToken)~Roslyn.Compilers.Common.CommonSyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> that wraps the supplied token.
            </summary>
            <param name="token">The input token.</param>
            <returns>
            A <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> that wraps the supplied token.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)~Roslyn.Compilers.Common.CommonSyntaxToken">
            <summary>
            Returns the underlying token wrapped by the supplied <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying token wrapped by the supplied <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Implicit(Roslyn.Compilers.Common.CommonSyntaxNode)~Roslyn.Compilers.Common.CommonSyntaxNodeOrToken">
            <summary>
            Returns a new <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> that wraps the supplied node.
            </summary>
            <param name="node">The input node.</param>
            <returns>
            A <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/> that wraps the supplied node.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.op_Explicit(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)~Roslyn.Compilers.Common.CommonSyntaxNode">
            <summary>
            Returns the underlying node wrapped by the supplied <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>.
            </summary>
            <param name="nodeOrToken">
            The input <see cref="T:Roslyn.Compilers.CommonSyntaxNodeOrToken"/>.
            </param>
            <returns>
            The underlying node wrapped by the supplied <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetLocation">
            <summary>
            Get the location of this node or token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has this node as its root or
            associated with this token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Kind">
            <summary>
            An integer representing the language specific kind of the underlying node or token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Language">
            <summary>
            The language name that this node or token is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.IsMissing">
            <summary>
            Determines whether the underlying node or token represents a language construct that was actually parsed
            from source code. Missing nodes and tokens are typically generated by the parser in error scenarios to
            represent constructs that should have been present in the source code for the source code to compile
            successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Parent">
            <summary>
            The node that contains the underlying node or token in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.IsToken">
            <summary>
            Determines whether this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.IsNode">
            <summary>
            Determines whether this <see cref="T:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken"/> is wrapping a node.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.Span">
            <summary>
            The absolute span of the underlying node or token in characters, not including its leading and trailing
            trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.FullSpan">
            <summary>
            The absolute span of the underlying node or token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.HasLeadingTrivia">
            <summary>
            Determines whether the underlying node or token has any leading trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.HasTrailingTrivia">
            <summary>
            Determines whether the underlying node or token has any trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.HasChildren">
            <summary>
            Determines whether the underlying node or token has any child nodes or tokens.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ContainsDiagnostics">
            <summary>
            Determines whether the underlying node or token or any of its descendant nodes, tokens or trivia have any
            diagnostics on them. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ContainsDirectives">
            <summary>
            Determines whether the underlying node or token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.ContainsAnnotations">
            <summary>
            Determines whether this node or token (or any sub node, token or trivia) as annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxNodeOrToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxNodeOrToken.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxToken">
            <summary>
            Represents a token in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Roslyn.Compilers.CSharp.SyntaxToken"/> and <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.ToFullString">
            <summary>
            Returns the full string representation of this token including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this token including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this token to the specified TextWriter
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.HasAnnotations(System.Type)">
            <summary>
            True if this token has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this token or any of its trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetAnnotations(System.Type)">
            <summary>
            Gets all the annotations of the specified type attached to this token.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetAllTrivia">
            <summary>
            Gets a list of all the trivia (both leading and trailing) for this token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.op_Equality(Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/>s are equal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.op_Inequality(Roslyn.Compilers.Common.CommonSyntaxToken,Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/>s are unequal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.Equals(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Roslyn.Compilers.CommonSyntaxToken"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetNextToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that follows this token in the syntax tree.
            </summary>
            <returns>The token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetPreviousToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the token that precedes this token in the syntax tree.
            </summary>
            <returns>The next token that follows this token in the syntax tree.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to a given syntax token, creating a new syntax token of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.CopyAnnotationsTo(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this CommonSyntaxToken instance and attaches them to a new instance based on <paramref name="token" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="token" />.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetLocation">
            <summary>
            Gets the location for this token.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxToken.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Kind">
            <summary>
            An integer representing the language specific kind of this token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Language">
            <summary>
            The language name that this token is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.ContextualKind">
            <summary>
            The kind of token, given its position in the syntax. This differs from <see cref="P:Roslyn.Compilers.Common.CommonSyntaxToken.Kind"/> when a contextual keyword is used in a place in the syntax that gives it
            its keyword meaning.
            </summary>
            <remarks>
            The ContextualKind is relevant only on contextual keyword tokens. ContextualKind differs
            from Kind when a token is used in context where the token should be interpreted as a
            keyword.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Parent">
            <summary>
            The node that contains this token in its Children collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Width">
            <summary>
            The width of the token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.FullWidth">
            <summary>
            The complete width of the token in characters including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Span">
            <summary>
            The absolute span of this token in characters, not including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.FullSpan">
            <summary>
            The absolute span of this token in characters, including its leading and trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.IsMissing">
            <summary>
            Determines whether this token represents a language construct that was actually parsed from source code.
            Missing tokens are typically generated by the parser in error scenarios to represent constructs that should
            have been present in the source code for the source code to compile successfully but were actually missing.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer literal, then this property
            would return the actual integer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.ValueText">
            <summary>
            Returns the text representation of the value of the token. For example, if the token represents an integer
            literal, then this property would return a string representing the integer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.HasLeadingTrivia">
            <summary>
            Determines whether this token has any leading trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.HasTrailingTrivia">
            <summary>
            Determines whether this token has any trailing trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.LeadingWidth">
            <summary>
            Full width of the leading trivia of this token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.TrailingWidth">
            <summary>
            Full width of the trailing trivia of this token.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.ContainsDiagnostics">
            <summary>
            Determines whether this token or any of its descendant trivia have any diagnostics on them. 
            </summary>>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.ContainsDirectives">
            <summary>
            Determines whether this token has any descendant preprocessor directives.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.HasStructuredTrivia">
            <summary>
            Determines whether any of this token's trivia is structured.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.ContainsAnnotations">
            <summary>
            True if this token or its trivia has any annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.LeadingTrivia">
            <summary>
            The list of trivia that appear before this token in the source code.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.TrailingTrivia">
            <summary>
            The list of trivia that appear after this token in the source code and are attached to this token or any of
            its descendants.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxToken.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxToken.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxTrivia">
            <summary>
            Represents a trivia in the syntax tree. This is the language agnostic equivalent of <see
            cref="T:Roslyn.Compilers.CSharp.SyntaxTrivia"/> and <see cref="T:Roslyn.Compilers.VisualBasic.SyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.HasAnnotations(System.Type)">
            <summary>
            Determines where this trivia has annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.HasAnnotation(Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Determines whether this trivia has the specific annotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.GetAnnotations(System.Type)">
            <summary>
            Get all the annotations of the specified type attached to this trivia.
            The type must be a strict sub type of SyntaxAnnotation.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.GetStructure">
            <summary>
            Returns the child non-terminal node representing the syntax tree structure under this structured trivia.
            </summary>
            <returns>The child non-terminal node representing the syntax tree structure under this structured
            trivia.</returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.ToString">
            <summary> 
            Returns the string representation of this trivia. If this trivia is structured trivia then the returned string
            will not include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.ToFullString">
            <summary> 
            Returns the full string representation of this trivia. If this trivia is structured trivia then the returned string will
            include any leading or trailing trivia present on the StructuredTriviaSyntax node of this trivia.
            </summary>
            <returns>The full string representation of this trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this trivia to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.op_Equality(Roslyn.Compilers.Common.CommonSyntaxTrivia,Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/>s are equal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.op_Inequality(Roslyn.Compilers.Common.CommonSyntaxTrivia,Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Determines whether two <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/>s are unequal.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.Equals(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.Equals(System.Object)">
            <summary>
            Determines whether the supplied <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/> is equal to this
            <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.GetHashCode">
            <summary>
            Serves as hash function for <see cref="T:Roslyn.Compilers.CommonSyntaxTrivia"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.WithAdditionalAnnotations(Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Adds this annotation to the given syntax trivia, creating a new syntax trivia of the same type with the
            annotation on it.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.CopyAnnotationsTo(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Copies all SyntaxAnnotations, if any, from this CommonSyntaxTrivia instance and attaches them to a new instance based on <paramref name="trivia" />.
            </summary>
            <remarks>
            If no annotations are copied, just returns <paramref name="trivia" />.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.GetLocation">
            <summary>
            Get the location of this trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTrivia.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics associated with this trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.Kind">
            <summary>
            An integer representing the language specific kind of this trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.Language">
            <summary>
            The language name that this trivia is syntax of.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.Token">
            <summary>
            The parent token that contains this token in its LeadingTrivia or TrailingTrivia collection.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.Width">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            not include the widths of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.FullWidth">
            <summary>
            The width of this trivia in characters. If this trivia is a structured trivia then the returned width will
            include the widths of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.Span">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will not include spans of any leading or trailing trivia present on the child non-terminal node of this
            trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.FullSpan">
            <summary>
            The absolute span of this trivia in characters. If this trivia is a structured trivia then the returned span
            will include spans of any leading or trailing trivia present on the child non-terminal node of this trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.ContainsDiagnostics">
            <summary>
            Determines whether this trivia has any diagnostics on it. If this trivia is a structured trivia then the
            returned value will indicate whether this trivia or any of its descendant nodes, tokens or trivia have any
            diagnostics on them.
            </summary>>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.HasStructure">
            <summary>
            Determines whether this trivia is a structured trivia.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.ContainsAnnotations">
            <summary>
            Determines whether this trivia or any of its structure has annotations.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.IsDirective">
            <summary>
            Determines whether this trivia represents a preprocessor directive.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTrivia.SyntaxTree">
            <summary>
            SyntaxTree which contains current SyntaxTrivia.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CvtResFile">
            <summary>
            Parses .RES a file into its constituent resource elements.
            Mostly translated from cvtres.cpp.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Win32ResourceConversions.VersionResourceSerializer.PadKeyLen(System.Int32)">
            <summary>
            Assume that 3 WORDs preceded this string and that the they began 32-bit aligned.
            Given the string length compute the number of bytes that should be written to end
            the buffer on a 32-bit boundary</summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Win32ResourceConversions.VersionResourceSerializer.PadToDword(System.Int32)">
            <summary>
            assuming the length of bytes submitted began on a 32-bit boundary,
            round up this length as necessary so that it ends at a 32-bit boundary.
            </summary>
            <param name="cb"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Win32ResourceConversions.VersionResourceSerializer.KEYSIZE(System.String)">
            <summary>
            compute number of chars needed to end up on a 32-bit boundary assuming that three
            WORDS preceded this string.
            </summary>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonDiagnostic">
            <summary>
            A diagnostic (such as a compiler error or a warning), along with the location where it occurred.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonDiagnostic.ToString(System.IFormatProvider)">
            <summary>
            Formats the diagnostic using specified format provider (e.g. culture).
            </summary>
            <returns>
            String in format "{file}({location}): {error-code}: {message}". Some parts might be missing if not available.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonDiagnostic.Location">
            <summary>
            The primary location of the diagnostic.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonDiagnostic.AdditionalLocations">
            <summary>
            Get additional locations related to the diagnostic. Typically these are the locations of
            symbols that are mentioned in the message.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonDiagnostic.Info">
            <summary>
            Get the information about the diagnostic: the code, severity, message, etc.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DiagnosticBag">
            <summary>
            Represents a thread-safe, mutable bag of diagnostics. You can add diagnostics to the bag,
            and also get all the diagnostics out of the bag (the bag implements
            IEnumerable&lt;Diagnostics&gt;. Once added, diagnostics cannot be removed, and no ordering
            is guaranteed.
            
            The bag can also be sealed, after which attempts to add additional errors will throw an
            exception. This is a useful to present errors from being incorrectly added to a bag too
            late.
            </summary>
            <remarks>Thread Safe. It is optimized to be efficient when containing zero errors.</remarks>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticBag.HasAnyErrors">
            <summary>
            Returns true if the bag has any diagnostics with Severity=Error. Does not consider warnings or informationals.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticBag.Add(Roslyn.Compilers.Common.CommonDiagnostic)">
            <summary>
            Add a diagnostic to the bag.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticBag.Add(System.Collections.Generic.IEnumerable{Roslyn.Compilers.Common.CommonDiagnostic})">
            <summary>
            Add multiple diagnostics to the bag.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticBag.Add(Roslyn.Compilers.DiagnosticBag)">
            <summary>
            Add another DiagnosticBag to the bag.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticBag.Seal">
            <summary>
            Seal the bag so no further errors can be added, while clearing it and returning the old set of errors.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticBag.IsEmpty">
            <summary>
            Return if the bag is empty.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticBag.Bag">
            <summary>
            Get the underlying concurrent storage, creating it on demand if needed.
            
            NOTE: there are no strict guarantees that the storage still belongs to 
                  the current bag.
                  The method however guarantees that the storage is not null and
                  did belong to the current bag at some point.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.DiagnosticInfo">
            <summary>
            A DiagnosticInfo object has information about a diagnostic, but without any attached location information.
            </summary>
            <remarks>
            More specialized diagnostics with additional information (e.g., ambiguity errors) can derive from this class to
            provide access to additional information about the error, such as what symbols were involved in the ambiguity.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.DiagnosticInfo.GetMessage(System.Globalization.CultureInfo)">
            <summary>
            Get the text of the message in the given language.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.Code">
            <summary>
            The error code, as an integer.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.Severity">
            <summary>
            Returns whether this diagnostic is informational, warning, or error.
            For checking if it is a warning treated as an error, use IsWarningsAsError.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.WarningLevel">
            <summary>
            Returns the warning level for a warning, 1 through 4. Errors have warning level 0.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.IsWarningAsError">
            <summary>
            Returns if this warning is treated as an error.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.AdditionalLocations">
            <summary>
            If a derived class has additional information about other referenced symbols, it can
            expose the locations of those symbols in a general way, so they can be reported along
            with the error.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.DiagnosticInfo.MessageIdentifier">
            <summary>
            Get the message id (for example "CS1001") for the message. This includes both the error number
            and a prefix identifying the source.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ReportWarning">
            <summary>
            Describes how to report a warning diagnostic.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.ReportWarning.Default">
            <summary>
            Report a warning by default.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.ReportWarning.Error">
            <summary>
            Report a warning as an error.  
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.ReportWarning.Warn">
            <summary>
            Report a warning as a warning even though /warnaserror is specified.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.ReportWarning.Suppress">
            <summary>
            Suppress a warning.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonMessageProvider">
            <summary>
            Abstracts the ability to classify and load messages for error codes. Allows the error
            infrastructure to be reused between C# and VB.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonMessageProvider.GetSeverity(System.Int32)">
            <summary>
            Given an error code, get the severity (warning or error) of the code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonMessageProvider.LoadMessage(System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Load the message for the given error code. If the message contains
            "fill-in" placeholders, those should be expressed in standard string.Format notation
            and be in the string.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonMessageProvider.GetWarningLevel(System.Int32)">
            <summary>
            Get the warning level for warnings (e.g., 1 through 4 for C#). VB does not have warning
            levels and always uses 1. Errors should return 0.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonMessageProvider.CreateDiagnostic(System.Int32,Roslyn.Compilers.Common.CommonLocation,System.Object[])">
            <summary>
            Create a simple language speicific diagnostic for given error code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonMessageProvider.GetMessagePrefix(System.String,Roslyn.Compilers.DiagnosticSeverity,System.Boolean,System.Globalization.CultureInfo)">
            <summary>
            Given a message identifier (e.g., CS0219), severity, warning as error and a culture, 
            get the entire prefix (e.g., "error CS0219: Warning as Error:" for C# or "error BC42024:" for VB) used on error messages.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMessageProvider.CodePrefix">
            <summary>
            Get the text prefix (e.g., "CS" for C#) used on error messages.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMessageProvider.ErrorCodeType">
            <summary>
            Type that defines error codes. For testing purposes only.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonMessageProvider.NoLocation">
            <summary>
            Language specific instance representing an unspecified location.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonLocation">
            <summary>
            A program location in source code.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonLocation.GetLineSpan(System.Boolean)">
            <summary>
            Gets the location in terms of file name/line/column.  However, the file is actually whatever was passed in
            when asked to parse; there may not really be a file.
            </summary>
            <param name="usePreprocessorDirectives">
            If true, the path/line/column
            reported takes into account #line directives. If false, #line directives
            are ignored.
            </param>
            <returns>
            <see cref="T:Roslyn.Compilers.FileLinePositionSpan"/> that contains file, line and column information. 
            Returns an invalid span (see <see cref="P:Roslyn.Compilers.FileLinePositionSpan.IsValid"/>) if the information is not available.
            </returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.Kind">
            <summary>
            Location kind (None/SourceFile/MetadataFile).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.IsInSource">
            <summary>
            Returns true if the location represents a specific location in a source code file.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.IsInMetadata">
            <summary>
            Returns true if the location is in metadata.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.SourceTree">
            <summary>
            The syntax tree this error is located in. Throws an InvalidOperationException unless
            InSource is true.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.MetadataModule">
            <summary>
            Returns the metadata module the error is associated with or null if the module is not available.
            </summary>
            <remarks>
            Might return null even if <see cref="P:Roslyn.Compilers.Common.CommonLocation.IsInMetadata"/> returns true. The module symbol might not be available anymore, 
            for example, if the location is serialized and deserialized.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonLocation.SourceSpan">
            <summary>
            The location within the syntax tree that this error is associated with.
            </summary>
            <remarks>
            If IsInSource returns False this method returns an empty TextSpan which starts at position 0.
            </remarks>
        </member>
        <member name="T:Roslyn.Compilers.Grouping`2">
            <summary>
            A simple class to implement IGrouping.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
            <param name="currentKey"></param>
            <param name="newKey"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
            <param name="newKeyPart"></param>
            <param name="currentKey"></param>
            <returns></returns>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxWalker">
            <summary>
            Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The
            walker will perform a depth first walk of the tree.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.CommonSyntaxWalker.Depth">
            <summary>
            True if this walker will descend into structured trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxWalker.#ctor(Roslyn.Compilers.Common.SyntaxWalkerDepth)">
            <summary>
            Creates a new walker instance.
            </summary>
            <param name="depth">specify how much this walker will descent into
            trivia.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxWalker.Visit(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Called when the walker visits a node.  This method may be overridden if subclasses want
            to handle the node.  Overrides should call back into this base method if they want the
            children of this node to be visited.
            </summary>
            <param name="node">The current node that the walker is visiting.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxWalker.VisitToken(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Called when the walker visits a token.  This method may be overridden if subclasses want
            to handle the token.  Overrides should call back into this base method if they want the 
            trivia of this token to be visited.
            </summary>
            <param name="token">The current token that the walker is visiting.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxWalker.VisitTrivia(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Called when the walker visits a trivia syntax.  This method may be overridden if
            subclasses want to handle the token.  Overrides should call back into this base method if
            they want the children of this trivia syntax to be visited.
            </summary>
            <param name="trivia">The current trivia syntax that the walker is visiting.</param>
        </member>
        <member name="M:Roslyn.Compilers.Common.IBaseSyntaxNodeExt.GetUnderlyingGreenNode">
            <summary>
            If this is a red node, this returns it's underlying green node.  If this is a green node
            already, then this is returned.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IBaseSyntaxNodeExt.Width">
            <summary>
            The width of the node in characters, not including leading and trailing trivia
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IBaseSyntaxNodeExt.FullWidth">
            <summary>
            The complete width of the node in characters including leading and trailing trivia
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.IStructuredTriviaSyntax">
            <summary>
            Represents the root node of a structured trivia tree (for example, a preprocessor directive
            or a documentation comment). From this root node you can traverse back up to the containing
            trivia in the outer tree that contains it.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.IStructuredTriviaSyntax.ParentTrivia">
            <summary>
            Returns the parent trivia syntax for this structured trivia syntax.
            </summary>
            <returns>The parent trivia syntax for this structured trivia syntax.</returns>
        </member>
        <member name="T:Roslyn.Compilers.Common.ISyntaxReference">
            <summary>
            A reference to a syntax node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.ISyntaxReference.GetSyntax">
            <summary>
            Retrieves the original referenced syntax node.  May cause a parse to happen to recover
            the syntax node.
            </summary>
            <returns>The original referenced syntax node.</returns>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISyntaxReference.SyntaxTree">
            <summary>
            The syntax tree that this references a node within.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.ISyntaxReference.Span">
            <summary>
            The span of the node referenced.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.CommonSyntaxTree">
            <summary>
            The parsed representation of a source document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.TryGetText(Roslyn.Compilers.IText@)">
            <summary>
            Gets the syntax tree's text if it is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetText(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the text of the source document asynchronously.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.TryGetRoot(Roslyn.Compilers.Common.CommonSyntaxNode@)">
            <summary>
            Get's the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree, causing computation if necessary.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.WithChangedText(Roslyn.Compilers.IText)">
            <summary>
            Create a new syntax based off this tree using a new source text. 
            
            If the new source text is a minor change from the current source text an incremental parse will occur
            reusing most of the current syntax tree internal data.  Otherwise, a full parse will using the new
            source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnostics(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnostics(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnostics(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnostics(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetLineSpan(Roslyn.Compilers.TextSpan,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets a FileLinePositionSpan for a TextSpan. FileLinePositionSpans are used primarily for diagnostics and
            source locations.
            </summary>
            <param name="span"></param>
            <param name="usePreprocessorDirectives">An indicator that determines whether preprocessor #line directives
            are used to alter the resulting line span.</param>
            <param name="cancellationToken">The cancellation token.</param> 
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetLineVisibility(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns the visibility for the line at the given position.
            </summary>
            <param name="position">The position to check.</param>
            <param name="cancellationToken">The cancellation token.</param> 
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetLineSpanAndIsHidden(Roslyn.Compilers.TextSpan,System.Boolean@)">
            <summary>
            Gets a FileLinePositionSpan for a TextSpan and the information whether this span is considered to be hidden or not. 
            FileLinePositionSpans are used primarily for diagnostics and source locations.
            This method combines a call to GetLineSpan and IsHiddenPosition.
            </summary>
            <param name="span"></param>
            <param name="isHiddenPosition">Returns a boolean indicating whether this span is considered hidden or not.</param>
            <remarks>This function is being called only in the context of sequence point creation and therefore interprets the 
            LineVisibility accordingly (BeforeFirstRemappingDirective -> Visible).</remarks>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetChangedSpans(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetLocation(Roslyn.Compilers.TextSpan)">
            <summary>
            Gets a location for the specified text span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.IsEquivalentTo(Roslyn.Compilers.Common.CommonSyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetRootCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root of the syntax tree if it is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetRootAsyncCore(System.Threading.CancellationToken)">
            <summary>
            Gets the root fo the syntax tree asynchronously.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.TryGetRootCore(Roslyn.Compilers.Common.CommonSyntaxNode@)">
            <summary>
            Returns true if the root node of the syntax tree is available.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.WithChangedTextCore(Roslyn.Compilers.IText)">
            <summary>
            Create a new syntax based off this tree using a new source text. 
            
            If the new source text is a minor change from the current source text an incremental parse will occur
            reusing most of the current syntax tree internal data.  Otherwise, a full parse will using the new
            source text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnosticsCore(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnosticsCore(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnosticsCore(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnosticsCore(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetDiagnosticsCore(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetChangedSpansCore(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Returns a list of the changed regions between this tree and the specified tree. The list is conservative for
            performance reasons. It may return larger regions than what has actually changed.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetLocationCore(Roslyn.Compilers.TextSpan)">
            <summary>
            Gets a location for the specified text span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.IsEquivalentToCore(Roslyn.Compilers.Common.CommonSyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel"> If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetReference(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.CommonSyntaxTree.GetChanges(Roslyn.Compilers.Common.CommonSyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree.</param>
            <remarks>The list of changes may be different than the original changes that produced
            this tree.</remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTree.FilePath">
            <summary>
            The path of the source document file.
            </summary>
            <remarks>
            If this syntax tree is not associated with a file, this value can be empty.
            
            The file doesn't need to exist on disk. The path is opaque for the compiler.
            The only requirement on the path format is that the implementation of <see cref="T:Roslyn.Compilers.FileResolver"/> 
            passed to the compilation that contains the tree understands it.
            
            Clients must also not assume that the values of this property are unique
            within a Compilation.
            
            The path is used in two important ways:
               - When debug information is emitted, this path is embedded in the debug information.
               - When the GetLineSpan function on the SyntaxTree is called, it is used as the file path
                 in the returned FileLinePositionSpan.
               - When normalizing paths relative to the base directory in #r directives (paths like ".", "..", ".\foo", "..\bar", "\", "\baz") 
                 the directory of this path is used as a base directory. In these cases the path has to be non-empty, otherwise an error is reported.
            </remarks>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTree.Length">
            <summary>
            The length of the text of the syntax tree.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.Common.CommonSyntaxTree.OptionsCore">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.LineVisibility">
            <summary>
            The state of the visibility of a line.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineVisibility.BeforeFirstLineDirective">
            <summary>
            The line is located before any #line directive and there is at least one #line directive present in this syntax tree.
            This enum value is used for C# only to enable the consumer to define how to interpret the lines before the first
            line directive. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineVisibility.Hidden">
            <summary>
            The line is following a #line hidden directive.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineVisibility.Visible">
            <summary>
            The line is following a #line default directive or a #line directive with at least a line number.
            If there is no line directive at all, Visible is returned for all lines.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.LineDirectiveMap`1">
            <summary>
            The LineDirectiveMap is created to enable translating positions, using the #line directives
            in a file. The basic implementation creates an ordered array of line mapping entries, one
            for each #line directive in the file (plus one at the beginning). If the file has no
            directives, then the array has just one element in in. To map line numbers, a binary search
            of the mapping entries is done and nearest line mapping is applied.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.LineDirectiveMap`1.GetLineVisibility(Roslyn.Compilers.IText,System.Int32)">
            <summary>
            Determines whether the position is considered to be hidden from the debugger or not.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Common.LineDirectiveMap`1.TranslateSpanAndIsHidden(Roslyn.Compilers.IText,System.String,Roslyn.Compilers.TextSpan,System.Boolean@)">
            <summary>
            Combines TranslateSpan and IsHiddenPosition to not search the entries twice when emitting sequence points
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState">
            <summary>
            Enum that describes the state related to the #line or #externalsource directives at a position in source.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.Unknown">
            <summary>
            Used in VB when the position is not hidden, but it's not known yet that there is a (nonempty) #ExternalSource
            following.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.Unmapped">
            <summary>
            Used in C# for spans outside of #line directives
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.Remapped">
            <summary>
            Used in C# for spans inside of "#line linenumber" directive
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.RemappedAfterUnknown">
            <summary>
            Used in VB for spans inside of a "#ExternalSource" directive that followed an unknown span
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.RemappedAfterHidden">
            <summary>
            Used in VB for spans inside of a "#ExternalSource" directive that followed a hidden span
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.Common.LineDirectiveMap`1.PositionState.Hidden">
            <summary>
            Used in C# and VB for spans that are inside of #line hidden (C#) or outside of #ExternalSource (VB) 
            directives
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Assembly.AssemblyReferences">
            <summary>
            All assemblies this assembly references.
            </summary>
            <remarks>
            A concatenation of assemblies referenced by each module in the order they are listed in <see cref="F:Roslyn.Compilers.MetadataReader.Assembly.modules"/>.
            </remarks>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Assembly.ModuleReferenceCounts">
            <summary>
            The number of assemblies referenced by each module in <see cref="F:Roslyn.Compilers.MetadataReader.Assembly.modules"/>.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Assembly.identity">
            <summary>
            Assembly identity read from Assembly table, or null if the table is empty.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Assembly.lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Roslyn.Compilers.ThreeState"/> for atomicity.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Assembly.#ctor(Roslyn.Compilers.AssemblyMetadata,System.String,Roslyn.Compilers.ReadOnlyArray{Roslyn.Compilers.MetadataReader.Module})">
            <exception cref="T:System.BadImageFormatException"/>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetWinMdForwardedType(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Given the full name of a type, we forward it to the correct
            assembly and possibly change the name if required.
            
            This is typically only done for Windows Runtime types.
            </summary>
            <param name="fullName"></param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.IsAcceptableModOptModifier(System.UInt32,`0)">
            <summary>
            According to ECMA spec:
             The CMOD_OPT or CMOD_REQD is followed by a metadata token that
             indexes a row in the TypeDef table or the TypeRef table.
            i.e. No modopt in DecodeType (though it still works in DecodeModifier).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetExplicitlyOverriddenMethods(System.UInt32,System.UInt32,`0)">
            <summary>
            Find the methods that a given method explicitly overrides.
            </summary>
            <remarks>
            Methods may be on class or interfaces.
            Containing classes/interfaces will be supertypes of the implementing type.
            </remarks>
            <param name="implementingTypeDefRid">TypeDef table row ID of implementing type.</param>
            <param name="implementingMethodDefRid">Method table row ID of implementing method</param>
            <param name="implementingTypeSymbol">The type symbol for the implementing type.</param>
            <returns>Array of implemented methods.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.FindMethodSymbolInSuperType(System.UInt32,System.UInt32)">
            <summary>
            Search for the MethodSymbol corresponding to the a given MethodDef token.  Search amongst the supertypes
            (classes and interfaces) of a designated type.
            </summary>
            <remarks>
            Generally, the type will be a type that explicitly implements an interface and the method will be the
            implemented method (i.e. on the interface).
            </remarks>
            <param name="searchTypeToken">TypeDef token of the type from which the search should begin.</param>
            <param name="targetMethodToken">MethodDef token of the target method.</param>
            <returns>Corresponding MethodSymbol or null, if none is found.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.EnqueueTypeDefInterfacesAndBaseType(System.Collections.Generic.Queue{System.UInt32},System.Collections.Generic.Queue{`0},System.UInt32)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="searchTypeToken">Token of the TypeDef for which we want to enqueue supertypes.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.EnqueueTypeToken(System.Collections.Generic.Queue{System.UInt32},System.Collections.Generic.Queue{`0},System.UInt32)">
            <summary>
            Helper method for enqueueing a type token in the right queue.
            Def -> typeDefsToSearch
            Ref -> typeSymbolsToSearch
            null -> neither
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.EnqueueTypeSymbolInterfacesAndBaseTypes(System.Collections.Generic.Queue{System.UInt32},System.Collections.Generic.Queue{`0},`0)">
            <summary>
            Enqueue the interfaces implemented and the type extended by a given TypeDef.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol for which we want to enqueue supertypes.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.EnqueueTypeSymbol(System.Collections.Generic.Queue{System.UInt32},System.Collections.Generic.Queue{`0},`0)">
            <summary>
            Enqueue the given type as either a def or a ref.
            </summary>
            <param name="typeDefsToSearch">Queue of TypeDefs to search.</param>
            <param name="typeSymbolsToSearch">Queue of TypeSymbols (representing typeRefs to search).</param>
            <param name="typeSymbol">Symbol to enqueue.</param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.FindMethodSymbolInType(`0,System.UInt32)">
            <summary>
            Search the methods of a TypeSymbol to find the one that matches a given MethodDef token.
            </summary>
            <param name="type">Type to search for method.</param>
            <param name="targetMethodDefToken">MethodDef token of the method to find.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetMethodSymbolForMemberRef(System.UInt32,`0)">
            <summary>
            Given a MemberRef token for a method, we can find a corresponding MethodSymbol by
            searching for the name and signature.
            </summary>
            <param name="targetMemberRefToken">A MemberRef token for a method.</param>
            <param name="implementingTypeSymbol">Scope the search to supertypes of the implementing type.</param>
            <returns>The corresponding MethodSymbol or null.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetMethodDefToken(`1)">
            <summary>
            Given a method symbol, return the MethodDef token, if it is defined in
            this module, or a nil token, otherwise.
            </summary>
            <param name="method">The method symbol for which to return a MethodDef token.</param>
            <returns>A MethodDef token or nil.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.LookupTopLevelTypeDefSymbol(Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a type defined in this module.
            </summary>
            <param name="emittedName"></param>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.LookupTopLevelTypeDefSymbol(System.Int32,Roslyn.Compilers.Internal.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.SubstituteTypeParameters(`0,`0[],System.Boolean[])">
            <summary>
            Produce constructed type symbol.
            </summary>
            <param name="generic">
            Symbol for generic type.
            </param>
            <param name="arguments">
            Generic type arguments, including those for nesting types.
            </param>
            <param name="refersToNoPiaLocalType">
            Flags for arguments. Each item indicates whether corresponding argument refers to NoPia local types.
            </param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetAssemblyForForwardedType(Roslyn.Compilers.Internal.MetadataTypeName@,System.Boolean)">
            <summary>
            If this assembly forwards the given type to another assembly, return that assembly;
            otherwise, return null.
            </summary>
            <param name="fullName">Type to look up.</param>
            <param name="ignoreCase">Pass true to look up fullName case-insensitively.  WARNING: more expensive.</param>
            <returns>Assembly symbol or null.</returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.GetMemberRefTypeSymbol(System.UInt32)">
            <summary>
            Given a MemberRef token, return the TypeSymbol for its Class field.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.DoPropertySignaturesMatch(Roslyn.Compilers.MetadataReader.MetadataDecoder{`0,`1,`2,`3}.ParamInfo[],Roslyn.Compilers.MetadataReader.MetadataDecoder{`0,`1,`2,`3}.ParamInfo[],System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Checks whether signatures match where the signatures are either from a property
            and an accessor or two accessors. When comparing a property or getter to setter, the
            setter signature must be the second argument and 'comparingToSetter' must be true.
            </summary>
            <param name="signature1">
            Signature of the property containing the accessor, or the getter (type, then parameters).
            </param>
            <param name="signature2">
            Signature of the accessor when comparing property and accessor,
            or the setter when comparing getter and setter (return type and then parameters).
            </param>
            <param name="comparingToSetter">
            True when comparing a property or getter to a setter, false otherwise.
            </param>
            <param name="compareParamByRef">
            True if differences in IsByRef for parameters should be treated as significant.
            </param>
            <param name="compareReturnByRef">
            True if differences in IsByRef for return value should be treated as significant.
            </param>
            <returns>True if the accessor signature is appropriate for the containing property.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MetadataDecoder`4.DoesSignatureMatchEvent(`0,Roslyn.Compilers.MetadataReader.MetadataDecoder{`0,`1,`2,`3}.ParamInfo[])">
            <summary>
            Check whether an event accessor has an appropriate signature.
            </summary>
            <param name="eventType">Type of the event containing the accessor.</param>
            <param name="methodParams">Signature of the accessor (return type and then parameters).</param>
            <returns>True if the accessor signature is appropriate for the containing event.</returns>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Module.lazyContainsNoPiaLocalTypes">
            <summary>
            Using <see cref="T:Roslyn.Compilers.ThreeState"/> as a type for atomicity.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Module.lazyNoPiaLocalTypeCheckBitMap">
            <summary>
            If bitmap is not null, each bit indicates whether a TypeDef 
            with corresponding RowId has been checked if it is a NoPia 
            local type. If the bit is 1, local type will have an entry 
            in m_lazyTypeDefToTypeIdentifierMap.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.Module.lazyTypeDefToTypeIdentifierMap">
            <summary>
            For each TypeDef that has 1 in m_lazyNoPiaLocalTypeCheckBitMap,
            this map stores corresponding TypeIdentifier row id combined with
            index of target constructor signature ((rowid &lt;&lt; 8) | index) 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.ComputeSHA1">
            <summary>
            Compute SHA1 hash of the module.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GroupTypesByNamespace(System.StringComparer)">
            <summary>
            The function groups types defined in the module by their fully-qualified namespace name.
            The case-sensitivity of the grouping depends upon the provided StringComparer.
            
            The sequence is sorted by name by using provided comparer. Therefore, if there are multiple 
            groups for a namespace name (e.g. because they differ in case), the groups are going to be 
            adjacent to each other. 
            
            Empty string is used as namespace name for types in the Global namespace. Therefore, all types 
            in the Global namespace, if any, should be in the first group (assuming a reasonable StringComparer).
            </summary>
            Comparer to sort the groups.
            <param name="nameComparer">
            </param>
            <returns>A sorted list of TypeDef row ids, grouped by fully-qualified namespace name.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetTypeNamespaceNames(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{System.UInt32}})">
            <summary>
            Groups together the RowIds of types in a given namespaces.  The types considered are
            those defined in this module.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetForwardedTypeNamespaceNames(System.Collections.Generic.Dictionary{System.String,Roslyn.Compilers.ArrayBuilder{System.UInt32}})">
            <summary>
            Supplements the namespace-to-RowIDs map with the namespaces of forwarded types.
            These types will not have associated row IDs (represented as null, for efficiency).
            These namespaces are important because we want lookups of missing forwarded types
            to succeed far enough that we can actually find the type forwarder and provide
            information about the target assembly.
            
            For example, consider the following forwarded type:
            
            .class extern forwarder Namespace.Type {}
            
            If this type is referenced in source as "Namespace.Type", then dev10 reports
            
            error CS1070: The type name 'Namespace.Name' could not be found. This type has been 
            forwarded to assembly 'pe2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'. 
            Consider adding a reference to that assembly.
            
            If we did not include "Namespace" as a child of the global namespace of this module
            (the forwarding module), then Roslyn would report that the type "Namespace" was not
            found and say nothing about "Name" (because of the diagnostic already attached to 
            the qualifier).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetInterfacesOfType(System.UInt32)">
            <summary>
            Returns an array of tokens for implemented intefaces. Null reference if none.
            </summary>
            <param name="typeDefRowId"></param>
            <returns>
            An array of tokens for implemented intefaces. Null reference if none.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.IsTypeIdentifierAttribute(System.UInt32)">
            <summary>
            Determine if custom attribute application is 
            NoPia TypeIdentifier.
            </summary>
            <param name="customAttributeRowId"></param>
            <returns>
            An index of the target constructor signature in 
            signaturesOfTypeIdentifierAttribute array, -1 if
            this is not NoPia TypeIdentifier.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.IsTargetAttribute(System.UInt32,System.String,System.String,System.UInt32@,System.Boolean)">
            <summary>
            Determines if a custom attribute matches a namespace and name.
            </summary>
            <param name="constructor">The custom attribute's constructor</param>
            <param name="namespaceName">The custom attribute's namespace in metadata format (case sensitive)</param>
            <param name="typeName">The custom attribute's type name in metadata format (case sensitive)</param>
            <param name="ctorSignature">The signature blob of the custom attribute constructor</param>
            <param name="ignoreCase">Should case be ignored for name comparison?</param>
            <returns>true if match is found</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetAssemblyRef(System.String)">
            <summary>
            Returns mdToken for assembly ref matching name
            </summary>
            <param name="assemblyName">The assembly name in metadata format (case sensitive)</param>
            <returns>Matching assembly ref token or nil (0)</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetTypeRef(System.UInt32,System.String,System.String)">
            <summary>
            Returns mdToken for type ref matching resolution scope and name
            </summary>
            <param name="resolutionScope">The resolution scope token</param>
            <param name="namespaceName">The namespace name in metadata format (case sensitive)</param>
            <param name="typeName">The type name in metadata format (case sensitive)</param>
            <returns>Matching type ref token or nil (0)</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetTargetAttributeSignatureIndex(System.UInt32,Roslyn.Compilers.AttributeDescription)">
            <summary>
            Determine if custom attribute matches the target attribute.
            </summary>
            <param name="constructor">
            Token of the constructor (customAttribute.Type).
            </param>
            <param name="description">The attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetTypeAndSignatureFromCtorToken(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>
            Given a token for a constructor, return the token for the constructor's type and the blob containing the
            constructor's signature.
            </summary>
            <param name="constructor"></param>
            <param name="ctorType"></param>
            <param name="ctorSignature"></param>
            <returns>True if the function successfully returns the type and signature.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetNameAndNamespaceFromTypeToken(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>
            Given a token for a type, return the type's name and namespace.  Only works for top level types. 
            </summary>
            <param name="ctorType"></param>
            <param name="ctorTypeNamespace"></param>
            <param name="ctorTypeName"></param>
            <returns>True if the function successfully returns the name and namespace.</returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.Module.GetGenericParamConstraints(System.UInt32)">
            <summary>
            Returns an array of tokens for type constraints. Null reference if none.
            </summary>
            <param name="paramRowId"></param>
            <returns>
            An array of tokens for type constraints. Null reference if none.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFile.FieldLayoutTableReader.GetOffset(System.UInt32)">
            <summary>
            Returns field offset for given field RowId, or -1 if not available. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFile.PEFileReader.ReadMetadataHeader(Roslyn.Compilers.MetadataReader.UtilityDataStructures.MemoryReader@)">
            <summary>
            Looks like this function reads beginning of the header described in
            Ecma-335 24.2.1 Metadata root
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFile.PEFileReader.ReadStorageHeader(Roslyn.Compilers.MetadataReader.UtilityDataStructures.MemoryReader@)">
            <summary>
            Looks like this function reads the end of the header described in
            Ecma-335 24.2.1 Metadata root
            </summary>
            <param name="memReader"></param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFile.PEFileReader.ReadStreamHeaders(Roslyn.Compilers.MetadataReader.UtilityDataStructures.MemoryReader@)">
            <summary>
            Looks like this function reads stream headers described in
            Ecma-335 24.2.2 Stream header
            </summary>
            <param name="memReader"></param>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFile.PEFileReader.ReadMetadataTableInformation(Roslyn.Compilers.MetadataReader.UtilityDataStructures.MemoryReader@)">
            <summary>
            Looks like this function reads stream header described in
            Ecma-335 24.2.6 #~ stream
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.PEFileFlags.AssemblyFlags.PublicKey">
            <summary>
            The assembly reference holds the full (unhashed) public key.
            Not applicable on assembly definition.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.PEFileFlags.AssemblyFlags.Retargetable">
            <summary>
            The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.MetadataReader.PEFileFlags.AssemblyFlags.ContentTypeMask">
            <summary>
            Content type mask. Masked bits correspond to values of <see cref="T:System.Reflection.AssemblyContentType"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.PEFileFlags.EnumConversions.ToCharSet(Roslyn.Compilers.MetadataReader.PEFileFlags.TypeDefFlags)">
            <summary>
            Extracts <see cref="T:System.Runtime.InteropServices.CharSet"/> information from TypeDef flags.
            Returns 0 if the value is invalid.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MetadataReader.MemoryMappedFile">
            <summary>
            Class representing the unmanaged memory mapped file. This can be used to open the file as memory mapped file and get the pointer to the buffer of file content.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MemoryMappedFile.CreateMemoryMappedFile(System.IO.FileStream,System.String)">
            <exception cref="T:System.IO.IOException">Unable to memory-map the file.</exception>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.MemoryMappedFile.OpenFileMemoryMap(System.IO.FileStream,System.Byte*@,System.UInt32@)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Compilers.MetadataReader.UtilityDataStructures.MemoryReader.ReadCompressedUInt32">
            <summary>
            Returns -1 if the first byte is 0xFF. This is used to represent the index for the null string.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.GetInfoForImmediateNamespaceMembers(System.Int32,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}},System.StringComparer,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.UInt32}}}}@)">
            <summary>
            Calculates information about types and namespaces immediately contained within a namespace.
            </summary>
            <param name="namespaceNameLength">
            Length of the fully-qualified name of this namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name in case-sensitive manner. 
            Key of each IGrouping is a fully-qualified namespace name, which starts with the name of 
            this namespace. There could be multiple groups for each fully-qualified namespace name.
            
            The groups must be sorted by the keys in a manner consistent with comparer passed in as
            nameComparer. Therefore, all types immediately contained within THIS namespace, if any, 
            must be in several IGrouping at the very beginning of the sequence.
            </param>
            <param name="nameComparer">
            Equality comparer to compare namespace names.
            </param>
            <param name="types">
            Output parameter, never null:
            A sequence of groups of TypeDef row ids for types immediately contained within this namespace.
            </param>
            <param name="namespaces">
            Output parameter, never null:
            A sequence with information about namespaces immediately contained within this namespace.
            For each pair:
              Key - contains simple name of a child namespace.
              Value  contains a sequence similar to the one passed to this function, but
                      calculated for the child namespace. 
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.ExtractSimpleNameOfChildNamespace(System.Int32,System.String)">
            <summary>
            Extract a simple name of a top level child namespace from potentially qualified namespace name.
            </summary>
            <param name="parentNamespaceNameLength">
            Parent namespace name length plus the dot.
            </param>
            <param name="fullName">
            Fully qualified namespace name.
            </param>
            <returns>
            Simple name of a top level child namespace, the left-most name following parent namespace name 
            in the fully qualified name.
            </returns>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.IsValidMetadataIdentifier(System.String)">
            <summary>
            Determines whether given string can be used as a non-empty metadata identifier (a NUL-terminated UTF8 string).
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.IsValidUnicodeString(System.String)">
            <summary>
            True if the string doesn't contain incomplete surrogates.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.Internal.MetadataHelpers.SerializedTypeDecoder">
            <summary>
            Decodes a serialized type name in its canonical form. The canonical name is its full type name, followed
            optionally by the assembly where it is defined, its version, culture and public key token.  If the assembly
            name is omitted, the type name is in the current assembly otherwise it is in the referenced assembly. The
            full type name is the fully qualified metadata type name. 
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.SerializedTypeDecoder.DecodeTypeName(System.Boolean,System.Boolean)">
            <summary>
            Decodes a type name.  A type name is a string which is terminated by the end of the string or one of the
            delimiters '+', ',', '[', ']'. '+' separates nested classes. '[' and ']'
            enclosed generic type arguments.  ',' separates types.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.Internal.MetadataHelpers.SerializedTypeDecoder.DecodeGenericName(System.Int32)">
            <summary>
            Decodes a generic name.  This is a type name followed optionally by a type parameter count
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAliasForType">
            <summary>
            Alias type to represent exported types and typedef.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAliasForType.AliasedType">
            <summary>
            Type reference of the type for which this is the alias
            </summary>
        </member>
        <member name="T:Microsoft.Cci.BaseMetadataTraverser">
            <summary>
            A visitor base class that traverses the object model in depth first, left to right order.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMetadataVisitor">
            <summary>
            Implemented by classes that visit nodes of object graphs via a double dispatch mechanism, usually performing some computation of a subset of the nodes in the graph.
            Contains a specialized Visit routine for each standard type of object defined in this object model. 
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IAliasForType)">
            <summary>
            Performs some computation with the alias for type.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Performs some computation with the given array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IAssembly)">
            <summary>
            Performs some computation with the given assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Performs some computation with the given assembly reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.ICustomAttribute)">
            <summary>
            Performs some computation with the given custom attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.ICustomModifier)">
            <summary>
            Performs some computation with the given custom modifier.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IEventDefinition)">
            <summary>
            Performs some computation with the given event definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Performs some computation with the given field definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IFieldReference)">
            <summary>
            Performs some computation with the given field reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IFileReference)">
            <summary>
            Performs some computation with the given file reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IFunctionPointerTypeReference)">
            <summary>
            Performs some computation with the given function pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Performs some computation with the given generic method instance reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodParameter)">
            <summary>
            Performs some computation with the given generic method parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericMethodParameterReference)">
            <summary>
            Performs some computation with the given generic method parameter reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGlobalFieldDefinition)">
            <summary>
            Performs some computation with the given global field definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGlobalMethodDefinition)">
            <summary>
            Performs some computation with the given global method definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            Performs some computation with the given generic type instance reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeParameter)">
            <summary>
            Performs some computation with the given generic parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IGenericTypeParameterReference)">
            <summary>
            Performs some computation with the given generic type parameter reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IManagedPointerTypeReference)">
            <summary>
            Performs some computation with the given managed pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMarshallingInformation)">
            <summary>
            Performs some computation with the given marshalling information.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Performs some computation with the given metadata constant.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMetadataCreateArray)">
            <summary>
            Performs some computation with the given metadata array creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMetadataExpression)">
            <summary>
            Performs some computation with the given metadata expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMetadataNamedArgument)">
            <summary>
            Performs some computation with the given metadata named argument expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMetadataTypeOf)">
            <summary>
            Performs some computation with the given metadata typeof expression.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMethodBody)">
            <summary>
            Performs some computation with the given method body.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Performs some computation with the given method definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMethodImplementation)">
            <summary>
            Performs some computation with the given method implementation.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IMethodReference)">
            <summary>
            Performs some computation with the given method reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IModifiedTypeReference)">
            <summary>
            Performs some computation with the given modified type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IModule)">
            <summary>
            Performs some computation with the given module.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IModuleReference)">
            <summary>
            Performs some computation with the given module reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.INamespaceTypeDefinition)">
            <summary>
            Performs some computation with the given namespace type definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.INamespaceTypeReference)">
            <summary>
            Performs some computation with the given namespace type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.INestedTypeDefinition)">
            <summary>
            Performs some computation with the given nested type definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.INestedTypeReference)">
            <summary>
            Performs some computation with the given nested type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Performs some computation with the given parameter definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Performs some computation with the given parameter type information.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IPointerTypeReference)">
            <summary>
            Performs some computation with the given pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            Performs some computation with the given property definition.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IResourceReference)">
            <summary>
            Performs some computation with the given reference to a manifest resource.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.SecurityAttribute)">
            <summary>
            Performs some computation with the given security attribute.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMetadataVisitor.Visit(Microsoft.Cci.IWin32Resource)">
            <summary>
            Performs some computation with the given Win32 resource.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Cci.BaseMetadataTraverser.path">
            <summary>
            
            </summary>
        </member>
        <member name="F:Microsoft.Cci.BaseMetadataTraverser.stopTraversal">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAliasForType})">
            <summary>
            Visits the specified aliases for types.
            </summary>
            <param name="aliasesForTypes">The aliases for types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAliasForType)">
            <summary>
            Visits the specified alias for type.
            </summary>
            <param name="aliasForType">Type of the alias for.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IArrayTypeReference)">
            <summary>
            Performs some computation with the given array type reference.
            </summary>
            <param name="arrayTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAssembly)">
            <summary>
            Performs some computation with the given assembly.
            </summary>
            <param name="assembly"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAssemblyReference})">
            <summary>
            Visits the specified assembly references.
            </summary>
            <param name="assemblyReferences">The assembly references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Performs some computation with the given assembly reference.
            </summary>
            <param name="assemblyReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomAttribute})">
            <summary>
            Visits the specified custom attributes.
            </summary>
            <param name="customAttributes">The custom attributes.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ICustomAttribute)">
            <summary>
            Performs some computation with the given custom attribute.
            </summary>
            <param name="customAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomModifier})">
            <summary>
            Visits the specified custom modifiers.
            </summary>
            <param name="customModifiers">The custom modifiers.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ICustomModifier)">
            <summary>
            Performs some computation with the given custom modifier.
            </summary>
            <param name="customModifier"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IEventDefinition})">
            <summary>
            Visits the specified events.
            </summary>
            <param name="events">The events.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IEventDefinition)">
            <summary>
            Performs some computation with the given event definition.
            </summary>
            <param name="eventDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IFieldDefinition})">
            <summary>
            Visits the specified fields.
            </summary>
            <param name="fields">The fields.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFieldDefinition)">
            <summary>
            Performs some computation with the given field definition.
            </summary>
            <param name="fieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFieldReference)">
            <summary>
            Performs some computation with the given field reference.
            </summary>
            <param name="fieldReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IFileReference})">
            <summary>
            Visits the specified file references.
            </summary>
            <param name="fileReferences">The file references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFileReference)">
            <summary>
            Performs some computation with the given file reference.
            </summary>
            <param name="fileReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IFunctionPointerTypeReference)">
            <summary>
            Performs some computation with the given function pointer type reference.
            </summary>
            <param name="functionPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodInstanceReference)">
            <summary>
            Performs some computation with the given generic method instance reference.
            </summary>
            <param name="genericMethodInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IGenericMethodParameter})">
            <summary>
            Visits the specified generic parameters.
            </summary>
            <param name="genericParameters">The generic parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodParameter)">
            <summary>
            Performs some computation with the given generic method parameter.
            </summary>
            <param name="genericMethodParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericMethodParameterReference)">
            <summary>
            Performs some computation with the given generic method parameter reference.
            </summary>
            <param name="genericMethodParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericParameter)">
            <summary>
            Visits the specified generic parameter.
            </summary>
            <param name="genericParameter">The generic parameter.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeInstanceReference)">
            <summary>
            Performs some computation with the given generic type instance reference.
            </summary>
            <param name="genericTypeInstanceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IGenericTypeParameter})">
            <summary>
            Visits the specified generic parameters.
            </summary>
            <param name="genericParameters">The generic parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeParameter)">
            <summary>
            Performs some computation with the given generic parameter.
            </summary>
            <param name="genericTypeParameter"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGenericTypeParameterReference)">
            <summary>
            Performs some computation with the given generic type parameter reference.
            </summary>
            <param name="genericTypeParameterReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGlobalFieldDefinition)">
            <summary>
            Performs some computation with the given global field definition.
            </summary>
            <param name="globalFieldDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IGlobalMethodDefinition)">
            <summary>
            Performs some computation with the given global method definition.
            </summary>
            <param name="globalMethodDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ILocalDefinition})">
            <summary>
            Visits the specified local definitions.
            </summary>
            <param name="localDefinitions">The local definitions.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ILocalDefinition)">
            <summary>
            Visits the specified local definition.
            </summary>
            <param name="localDefinition">The local definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IManagedPointerTypeReference)">
            <summary>
            Performs some computation with the given managed pointer type reference.
            </summary>
            <param name="managedPointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMarshallingInformation)">
            <summary>
            Performs some computation with the given marshalling information.
            </summary>
            <param name="marshallingInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataConstant)">
            <summary>
            Performs some computation with the given metadata constant.
            </summary>
            <param name="constant"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataCreateArray)">
            <summary>
            Performs some computation with the given metadata array creation expression.
            </summary>
            <param name="createArray"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMetadataExpression})">
            <summary>
            Visits the specified expressions.
            </summary>
            <param name="expressions">The expressions.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataExpression)">
            <summary>
            Performs some computation with the given metadata expression.
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMetadataNamedArgument})">
            <summary>
            Visits the specified named arguments.
            </summary>
            <param name="namedArguments">The named arguments.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataNamedArgument)">
            <summary>
            Performs some computation with the given metadata named argument expression.
            </summary>
            <param name="namedArgument"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMetadataTypeOf)">
            <summary>
            Performs some computation with the given metadata typeof expression.
            </summary>
            <param name="typeOf"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodBody)">
            <summary>
            Performs some computation with the given method body.
            </summary>
            <param name="methodBody"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodDefinition})">
            <summary>
            Visits the specified methods.
            </summary>
            <param name="methods">The methods.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodDefinition)">
            <summary>
            Performs some computation with the given method definition.
            </summary>
            <param name="method"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodImplementation})">
            <summary>
            Visits the specified method implementations.
            </summary>
            <param name="methodImplementations">The method implementations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodImplementation)">
            <summary>
            Performs some computation with the given method implementation.
            </summary>
            <param name="methodImplementation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IMethodReference})">
            <summary>
            Visits the specified method references.
            </summary>
            <param name="methodReferences">The method references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IMethodReference)">
            <summary>
            Performs some computation with the given method reference.
            </summary>
            <param name="methodReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModifiedTypeReference)">
            <summary>
            Performs some computation with the given modified type reference.
            </summary>
            <param name="modifiedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModule)">
            <summary>
            Performs some computation with the given module.
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IModuleReference})">
            <summary>
            Visits the specified module references.
            </summary>
            <param name="moduleReferences">The module references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IModuleReference)">
            <summary>
            Performs some computation with the given module reference.
            </summary>
            <param name="moduleReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamedTypeDefinition})">
            <summary>
            Visits the specified types.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceTypeDefinition)">
            <summary>
            Performs some computation with the given namespace type definition.
            </summary>
            <param name="namespaceTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INamespaceTypeReference)">
            <summary>
            Performs some computation with the given namespace type reference.
            </summary>
            <param name="namespaceTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.VisitNestedTypes(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamedTypeDefinition})">
            <summary>
            Visits the specified nested types.
            </summary>
            <param name="nestedTypes">The nested types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedTypeDefinition)">
            <summary>
            Performs some computation with the given nested type definition.
            </summary>
            <param name="nestedTypeDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.INestedTypeReference)">
            <summary>
            Performs some computation with the given nested type reference.
            </summary>
            <param name="nestedTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IOperationExceptionInformation})">
            <summary>
            Visits the specified operation exception informations.
            </summary>
            <param name="operationExceptionInformations">The operation exception informations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IOperationExceptionInformation)">
            <summary>
            Visits the specified operation exception information.
            </summary>
            <param name="operationExceptionInformation">The operation exception information.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterDefinition})">
            <summary>
            Visits the specified parameters.
            </summary>
            <param name="parameters">The parameters.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IParameterDefinition)">
            <summary>
            Performs some computation with the given parameter definition.
            </summary>
            <param name="parameterDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IParameterTypeInformation})">
            <summary>
            Visits the specified parameter type informations.
            </summary>
            <param name="parameterTypeInformations">The parameter type informations.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IParameterTypeInformation)">
            <summary>
            Performs some computation with the given parameter type information.
            </summary>
            <param name="parameterTypeInformation"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPlatformInvokeInformation)">
            <summary>
            Visits the specified platform invoke information.
            </summary>
            <param name="platformInvokeInformation">The platform invoke information.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPointerTypeReference)">
            <summary>
            Performs some computation with the given pointer type reference.
            </summary>
            <param name="pointerTypeReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IPropertyDefinition})">
            <summary>
            Visits the specified properties.
            </summary>
            <param name="properties">The properties.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IPropertyDefinition)">
            <summary>
            Performs some computation with the given property definition.
            </summary>
            <param name="propertyDefinition"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IResourceReference})">
            <summary>
            Visits the specified resource references.
            </summary>
            <param name="resourceReferences">The resource references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IResourceReference)">
            <summary>
            Performs some computation with the given reference to a manifest resource.
            </summary>
            <param name="resourceReference"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.SecurityAttribute)">
            <summary>
            Performs some computation with the given security attribute.
            </summary>
            <param name="securityAttribute"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.SecurityAttribute})">
            <summary>
            Visits the specified security attributes.
            </summary>
            <param name="securityAttributes">The security attributes.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinitionMember})">
            <summary>
            Visits the specified type members.
            </summary>
            <param name="typeMembers">The type members.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeDefinition})">
            <summary>
            Visits the specified types.
            </summary>
            <param name="types">The types.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeDefinition)">
            <summary>
            Visits the specified type definition.
            </summary>
            <param name="typeDefinition">The type definition.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeDefinitionMember)">
            <summary>
            Visits the specified type member.
            </summary>
            <param name="typeMember">The type member.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeMemberReference)">
            <summary>
            Visits the specified type member reference.
            </summary>
            <param name="typeMemberReference">The type member reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ITypeReference})">
            <summary>
            Visits the specified type references.
            </summary>
            <param name="typeReferences">The type references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.ITypeReference)">
            <summary>
            Visits the specified type reference.
            </summary>
            <param name="typeReference">The type reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.DispatchAsReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Use this routine, rather than ITypeReference.Dispatch, to call the appropriate derived overload of an ITypeReference.
            The former routine will call Visit(INamespaceTypeDefinition) rather than Visit(INamespaceTypeReference), etc., 
            in the case where a definition is used as a reference to itself.
            </summary>
            <param name="typeReference">A reference to a type definition. Note that a type definition can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IUnitReference})">
            <summary>
            Visits the specified unit references.
            </summary>
            <param name="unitReferences">The unit references.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IUnitReference)">
            <summary>
            Visits the specified unit reference.
            </summary>
            <param name="unitReference">The unit reference.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.DispatchAsReference(Microsoft.Cci.IUnitReference)">
            <summary>
            Use this routine, rather than IUnitReference.Dispatch, to call the appropriate derived overload of an IUnitReference.
            The former routine will call Visit(IAssembly) rather than Visit(IAssemblyReference), etc.
            in the case where a definition is used as the reference to itself.
            </summary>
            <param name="unitReference">A reference to a unit. Note that a unit can serve as a reference to itself.</param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.Visit(Microsoft.Cci.IWin32Resource)">
            <summary>
            Performs some computation with the given Win32 resource.
            </summary>
            <param name="win32Resource"></param>
        </member>
        <member name="M:Microsoft.Cci.BaseMetadataTraverser.VisitMethodReturnAttributes(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICustomAttribute})">
            <summary>
            Visits the method return attributes.
            </summary>
            <param name="customAttributes">The custom attributes.</param>
        </member>
        <member name="T:Microsoft.Cci.IDocument">
            <summary>
            An object that represents a document. This can be either source or binary or designer surface etc
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IDocument.Location">
            <summary>
            The location where this document was found, or where it should be stored.
            This will also uniquely identify the source document within an instance of compilation host.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IDocument.Name">
            <summary>
            The name of the document. For example the name of the file if the document corresponds to a file.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameter">
            <summary>
            The definition of a type parameter of a generic type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameter">
            <summary>
            The definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericParameterReference">
            <summary>
            A reference to the definition of a type parameter of a generic type or method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericParameter.GetConstraints(System.Object)">
            <summary>
            A list of classes or interfaces. All type arguments matching this parameter must be derived from all of the classes and implement all of the interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeReferenceType">
            <summary>
            True if all type arguments matching this parameter are constrained to be reference types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustBeValueType">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.MustHaveDefaultConstructor">
            <summary>
            True if all type arguments matching this parameter are constrained to be value types or concrete classes with visible default constructors.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericParameter.Variance">
            <summary>
            Indicates if the generic type or method with this type parameter is co-, contra-, or non variant with respect to this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeParameterReference">
            <summary>
            A reference to a type parameter of a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameterReference.DefiningType">
            <summary>
            A reference to the generic type that defines the referenced type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeParameter.DefiningType">
            <summary>
            The generic type that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CallingConvention">
            <summary>
            Specifies how the callee passes parameters to the callee and who cleans up the stack.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.C">
            <summary>
            C/C++ style calling convention for unmanaged methods. The call stack is cleaned up by the caller, 
            which makes this convention suitable for calling methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Default">
            <summary>
            The convention for calling managed methods with a fixed number of arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExtraArguments">
            <summary>
            The convention for calling managed methods that accept extra arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.FastCall">
            <summary>
            Arguments are passed in registers when possible. This calling convention is not yet supported.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Standard">
            <summary>
            Win32 API calling convention for calling unmanged methods via PlatformInvoke. The call stack is cleaned up by the callee.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ThisCall">
            <summary>
            C++ member unmanaged method (non-vararg) calling convention. The callee cleans the stack and the this pointer is pushed on the stack last.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.Generic">
            <summary>
            The convention for calling a generic method.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.HasThis">
            <summary>
            The convention for calling an instance method with an implicit this parameter (the method does not have an explicit parameter definition for this).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.CallingConvention.ExplicitThis">
            <summary>
            The convention for calling an instance method that explicitly declares its first parameter to correspond to the this instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IEventDefinition">
            <summary>
            An event is a member that enables an object or class to provide notifications. Clients can attach executable code for events by supplying event handlers.
            This interface models the metadata representation of an event.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IEventDefinition.GetType(System.Object)">
            <summary>
            The (delegate) type of the handlers that will handle the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Accessors">
            <summary>
            A list of methods that are associated with the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Adder">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Caller">
            <summary>
            The method used to call the event handlers when the event occurs. May be null.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsRuntimeSpecial">
            <summary>
            True if the event gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.IsSpecialName">
            <summary>
            This event is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IEventDefinition.Remover">
            <summary>
            The method used to add a handler to the event.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.HandlerKind">
            <summary>
            The kind of handler for the SEH
            </summary>
        </member>
        <member name="F:Microsoft.Cci.HandlerKind.Catch">
            <summary>
            Handler is for Catch
            </summary>
        </member>
        <member name="F:Microsoft.Cci.HandlerKind.Filter">
            <summary>
            Handler is filter
            </summary>
        </member>
        <member name="F:Microsoft.Cci.HandlerKind.Finally">
            <summary>
            Handler is finally
            </summary>
        </member>
        <member name="F:Microsoft.Cci.HandlerKind.Fault">
            <summary>
            Handler is Fault
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodBody">
            <summary>
            A metadata (IL) level represetation of the body of a method or of a property/event accessor.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodBody.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDoubleDispatcher. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.OperationExceptionInformation">
            <summary>
            A list exception data within the method body IL.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalsAreZeroed">
            <summary>
            True if the locals are initialized by zeroeing the stack upon method entry.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.LocalVariables">
            <summary>
            The local variables of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MethodDefinition">
            <summary>
            The definition of the method whose body this is.
            If this is the body of an event or property accessor, this will hold the corresponding adder/remover/setter or getter method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.MaxStack">
            <summary>
            The maximum number of elements on the evaluation stack during the execution of the method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.PrivateHelperTypes">
            <summary>
            Any types that are implicitly defined in order to implement the body semantics.
            In case of AST to instructions conversion this lists the types produced.
            In case of instructions to AST decompilation this should ideally be list of all types
            which are local to method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodBody.CustomDebugInfoKind">
            <summary>
            The PDB content for custom debug information is different between Visual Basic and CSharp.
            E.g. CS always includes a CustomMetadata Header (MD2) that contains the namespace scope counts, where 
            as VB only outputs namespace imports into the namespace scopes. CS defines forwards in that header, VB includes
            them into the scopes list.
            This enum is used to distinguish which style to pick while writing the PDB information.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.CustomDebugInfoKind">
            <summary>
            This enum is used to distinguish which style to pick while writing the PDB information.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodDefinition">
            <summary>
            This interface models the metadata representation of a method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodDefinition.GetBody(System.Object)">
            <summary>
            A container for a list of IL instructions providing the implementation (if any) of this method.
            </summary>
            <remarks>
            When emitting metadata-only assemblies this returns null even if <see cref="M:Cci.Extensions.HasBody"/> returns true.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.GenericParameters">
            <summary>
            If the method is generic then this list contains the type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity">
            <summary>
            True if this method has a non empty collection of SecurityAttributes or the System.Security.SuppressUnmanagedCodeSecurityAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAbstract">
            <summary>
            True if the method does not provide an implementation.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride">
            <summary>
            True if the method can only be overridden when it is also accessible. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsConstructor">
            <summary>
            True if the method is a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsExternal">
            <summary>
            True if the method has an external implementation (i.e. not supplied by this definition).
            </summary>
            <remarks>
            If the method is not external and not abstract it has to provide an IL body.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsHiddenBySignature">
            <summary>
            True if this method is hidden if a derived type declares a method with the same name and signature. 
            If false, any method with the same name hides this method. This flag is ignored by the runtime and is only used by compilers.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsNewSlot">
            <summary>
            The method always gets a new slot in the virtual method table. 
            This means the method will hide (not override) a base type method with the same name and signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsPlatformInvoke">
            <summary>
            True if the method is implemented via the invocation of an underlying platform method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial">
            <summary>
            True if the method gets special treatment from the runtime. For example, it might be a constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSealed">
            <summary>
            True if the method may not be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsSpecialName">
            <summary>
            True if the method is special in some way for tools. For example, it might be a property getter or setter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsStatic">
            <summary>
            True if the method does not require an instance of its declaring type as its first argument.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.IsVirtual">
            <summary>
            True if the method may be overridden (or if it is an override).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ImplementationAttributes">
            <summary>
            Implementation flags.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.PlatformInvokeData">
            <summary>
            Detailed information about the PInvoke stub. Identifies which method to call, which module has the method and the calling convention among other things.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code. If this flag is set, the method
            should have System.Security.DynamicSecurityMethodAttribute present in its list of custom attributes.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the method's return value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly">
            <summary>
            The return value has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation">
            <summary>
            Specifies how the return value is marshalled when the method is called from unmanaged code.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodDefinition.SecurityAttributes">
            <summary>
            Declarative security actions for this method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IParameterDefinition">
            <summary>
            This interface models the metadata representation of a method or property parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterDefinition.GetDefaultValue">
            <summary>
            A compile time constant value that should be supplied as the corresponding argument value by callers that do not explicitly specify an argument value for this parameter.
            Null if the parameter doesn't have default value.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IParameterDefinition.ParamArrayElementType(System.Object)">
            <summary>
            The element type of the parameter array.
            ^ requires this.IsParameterArray;
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.HasDefaultValue">
            <summary>
            True if the parameter has a default value that should be supplied as the argument value by a caller for which the argument value has not been explicitly specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsIn">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsMarshalledExplicitly">
            <summary>
            This parameter has associated marshalling information.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOptional">
            <summary>
            True if the argument value must be included in the marshalled arguments passed to a remote callee only if it is different from the default value (if there is one).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsOut">
            <summary>
            True if the final value assigned to the parameter will be marshalled with the return values passed back from a remote callee.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.IsParameterArray">
            <summary>
            True if the parameter has the ParamArrayAttribute custom attribute.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IParameterDefinition.MarshallingInformation">
            <summary>
            Specifies how this parameter is marshalled when it is accessed from unmanaged code.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPropertyDefinition">
            <summary>
            A property is a member that provides access to an attribute of an object or a class.
            This interface models the metadata representation of a property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Accessors">
            <summary>
            A list of methods that are associated with the property.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.DefaultValue">
            <summary>
            A compile time constant value that provides the default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Getter">
            <summary>
            The method used to get the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.HasDefaultValue">
            <summary>
            True if this property has a compile time constant associated with that serves as a default value for the property. (Who uses this and why?)
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsRuntimeSpecial">
            <summary>
            True if this property gets special treatment from the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.IsSpecialName">
            <summary>
            True if this property is special in some way, as specified by the name.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Parameters">
            <summary>
            The parameters forming part of this signature.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.ReturnValueAttributes">
            <summary>
            Custom attributes associated with the property's return value.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPropertyDefinition.Setter">
            <summary>
            The method used to set the value of this property. May be absent (null).
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedEventDefinition">
            <summary>
            Represents the specialized event definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedEventDefinition.UnspecializedVersion">
            <summary>
            The event that has been specialized to obtain this event. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedFieldReference">
            <summary>
            Represents reference specialized field.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion">
            <summary>
            A reference to the field definition that has been specialized to obtain the field definition referred to by this field reference. 
            When the containing type of the referenced specialized field definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized field reference refers to the corresponding field definition from the unspecialized containing type definition.
            (I.e. the unspecialized field reference always refers to a field definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedMethodReference">
            <summary>
            Represents reference specialized method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion">
            <summary>
            A reference to the method definition that has been specialized to obtain the method definition referred to by this method reference. 
            When the containing type of the referenced specialized method definition is itself a specialized nested type of a generic type instance, 
            then the unspecialized method reference refers to the corresponding method definition from the unspecialized containing type definition.
            (I.e. the unspecialized method reference always refers to a method definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedPropertyDefinition">
            <summary>
            Represents the specialized property definition.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedPropertyDefinition.UnspecializedVersion">
            <summary>
            The property that has been specialized to obtain this property. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodInstanceReference">
            <summary>
            A reference to generic method instantiated with a list of type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericMethodInstanceReference.GetGenericArguments(System.Object)">
            <summary>
            The type arguments that were used to instantiate this.GenericMethod in order to create this method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodInstanceReference.GenericMethod">
            <summary>
            Returns the generic method of which this method is an instance.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalFieldDefinition">
            <summary>
            Represents a global field in symbol table.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGlobalMethodDefinition">
            <summary>
            Represents a global method in symbol table.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGlobalMethodDefinition.Name">
            <summary>
            The name of the method.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.MethodBody">
            <summary>
            Holds on to the method body data.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.MethodBody.NamespaceScopes">
            <summary>
            This is a list of the using directives that were in scope for this method body.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.Function`2">
            <summary>
            A Function that takes a single argument of type P and returns a value of type R.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IteratorHelper">
            <summary>
            A container for static helper methods that are used for manipulating and computing iterators.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.GetEmptyEnumerable``1">
            <summary>
            Returns an enumerable containing no objects.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsNotEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is not null and contains at least one element.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableIsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            True if the given enumerable is null or contains no elements
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IteratorHelper.EnumerableCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the number of elements in the given enumerable. A null enumerable is allowed and results in 0.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.SecurityAttribute">
            <summary>
            A declarative specification of a security action applied to a set of permissions. Used by the CLR loader to enforce security restrictions.
            Each security attribute represents a serialized permission or permission set for a specified security action.
            The union of the security attributes with identical security action, define the permission set to which the security action applies.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PInvokeAttributes">
            <summary>
            This enum is used internally by BCL. It includes flags that are not in the metadata spec.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IWin32Resource">
            <summary>
            A resource file formatted according to Win32 API conventions and typically obtained from a Portable Executable (PE) file.
            See the Win32 UpdateResource method for more details.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeName">
            <summary>
            A string that identifies what type of resource this is. Only valid if this.TypeId &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.TypeId">
            <summary>
            An integer tag that identifies what type of resource this is. If the value is less than 0, this.TypeName should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Name">
            <summary>
            The name of the resource. Only valid if this.Id &lt; 0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Id">
            <summary>
            An integer tag that identifies this resource. If the value is less than 0, this.Name should be used instead.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.LanguageId">
            <summary>
            The language for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.CodePage">
            <summary>
            The code page for which this resource is appropriate.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IWin32Resource.Data">
            <summary>
            The data of the resource.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.OperationCheckFlags">
            <summary>
            Flags for IL No Operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoTypeCheck">
            <summary>
            No type check needs to be performed for next operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoRangeCheck">
            <summary>
            No range check needs to be performed for next operation
            </summary>
        </member>
        <member name="F:Microsoft.Cci.OperationCheckFlags.NoNullCheck">
            <summary>
            No null check needs to be performed for next operation
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PESectionKind">
            <summary>
            An enumeration indicating the section inside the PE File
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.Illegal">
            <summary>
            Section is unrecognized
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.ConstantData">
            <summary>
            Section for initialized constant data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.CoverageData">
            <summary>
            Section for code coverage data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.StaticData">
            <summary>
            Section for intialized writable data.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.Text">
            <summary>
            Section for IL and Metadata.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PESectionKind.ThreadLocalStorage">
            <summary>
            Section for initialized thread local storage.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModifiedTypeReference">
            <summary>
            A type reference that has custom modifiers associated with it. For example a reference to the target type of a managed pointer to a constant.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.CustomModifiers">
            <summary>
            Returns the list of custom modifiers associated with the type reference. Evaluate this property only if IsModified is true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModifiedTypeReference.UnmodifiedType">
            <summary>
            An unmodified type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.FoldStrings">
            <summary>
            Fills in stringIndexMap with data from stringIndex and write to stringWriter.  
            Releases stringIndex as the stringTable is sealed after this point.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.PeWriter.UnwrapTypeReference(Microsoft.Cci.ITypeReference)">
            <summary>
            Strip off *, &amp;, and [].
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.StringIdx">
            <summary>
            Wraps a virtual string table index.
            An override to SerializeIndex does the resolving at the right time.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.SuffixSort">
            <summary>
            Sorts strings such that a string is followed immediately by all strings
            that are a suffix of it.  
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PeWriter.AssemblyReferenceComparer">
            <summary>
            Compares quality of assembly references to achieve unique rows in AssemblyRef table.
            Metadata spec: "The AssemblyRef table shall contain no duplicates (where duplicate rows are deemd to 
            be those having the same MajorVersion, MinorVersion, BuildNumber, RevisionNumber, PublicKeyOrToken, 
            Name, and Culture)".
            </summary>
        </member>
        <member name="T:Microsoft.Cci.RootModuleType">
            <summary>
            Special type &lt;Module&gt;
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UsedNamespaceOrTypeKind">
            <summary>
            
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.GetDefiningUnitReference(Microsoft.Cci.ITypeReference,System.Object)">
            <summary>
            Returns a reference to the unit that defines the given referenced type. If the referenced type is a structural type, such as a pointer or a generic type instance,
            then the result is null.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.TypeHelper.TypesAreEquivalent(Microsoft.Cci.ITypeReference,Microsoft.Cci.ITypeReference)">
            <summary>
            Returns true if the given two types are to be considered equivalent for the purpose of signature matching and so on.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISourceLocation">
            <summary>
            A range of source text that corresponds to an identifiable entity.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceLocation.Contains(Microsoft.Cci.ISourceLocation)">
            <summary>
            True if the source at the given location is completely contained by the source at this location.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceLocation.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the specified number of characters to the destination character array, starting
            at the specified offset from the start if the source location. Returns the number of
            characters actually copied. This number will be greater than zero as long as position is
            less than this.Length. The number will be precisely the number asked for unless there
            are not enough characters left in the document.
            </summary>
            <param name="offset">The starting index to copy from. Must be greater than zero and less than this.Length.</param>
            <param name="destination">The destination array. Must have at least destinationOffset+length elements.</param>
            <param name="destinationOffset">The starting index where the characters must be copied to in the destination array.</param>
            <param name="length">The maximum number of characters to copy.</param>
        </member>
        <member name="P:Microsoft.Cci.ISourceLocation.EndIndex">
            <summary>
            The character index after the last character of this location, when treating the source document as a single string.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceLocation.Length">
            <summary>
            The number of characters in this source location.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceLocation.SourceDocument">
            <summary>
            The document containing the source text of which this location is a subrange.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceLocation.Source">
            <summary>
            The source text corresponding to this location.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceLocation.StartIndex">
            <summary>
            The character index of the first character of this location, when treating the source document as a single string.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISourceDocument">
            <summary>
            An object that represents a source document, such as a text file containing C# source code.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceDocument.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies no more than the specified number of characters to the destination character array, starting at the specified position in the source document.
            Returns the actual number of characters that were copied. This number will be greater than zero as long as position is less than this.Length.
            The number will be precisely the number asked for unless there are not enough characters left in the document.
            </summary>
            <param name="position">The starting index to copy from. Must be greater than or equal to zero and position+length must be less than or equal to this.Length;</param>
            <param name="destination">The destination array.</param>
            <param name="destinationOffset">The starting index where the characters must be copied to in the destination array.</param>
            <param name="length">The maximum number of characters to copy. Must be greater than 0 and less than or equal to the number elements of the destination array.</param>
        </member>
        <member name="M:Microsoft.Cci.ISourceDocument.GetCorrespondingSourceLocation(Microsoft.Cci.ISourceLocation)">
            <summary>
            Returns a source location in this document that corresponds to the given source location from a previous version
            of this document.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceDocument.GetSourceLocation(System.Int32,System.Int32)">
            <summary>
            Obtains a source location instance that corresponds to the substring of the document specified by the given start position and length.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceDocument.GetText">
            <summary>
            Returns the source text of the document in string form. Each call may do significant work, so be sure to cache this.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.ISourceDocument.IsUpdatedVersionOf(Microsoft.Cci.ISourceDocument)">
            <summary>
            Returns true if this source document has been created by editing the given source document (or an updated
            version of the given source document).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceDocument.Length">
            <summary>
            The length of the source string.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceDocument.SourceLanguage">
            <summary>
            The language that determines how the document is parsed and what it means.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISourceDocument.SourceLocation">
            <summary>
            A source location corresponding to the entire document.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPrimarySourceDocument">
            <summary>
            An object that represents a source document corresponding to a user accessible entity such as file.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPrimarySourceDocument.GetPrimarySourceLocation(System.Int32,System.Int32)">
            <summary>
            Obtains a source location instance that corresponds to the substring of the document specified by the given start position and length.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPrimarySourceDocument.ToLineColumn(System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Maps the given (zero based) source position to a (one based) line and column, by scanning the source character by character, counting
            new lines until the given source position is reached. The source position and corresponding line+column are remembered and scanning carries
            on where it left off when this routine is called next. If the given position precedes the last given position, scanning restarts from the start.
            Optimal use of this method requires the client to sort calls in order of position.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPrimarySourceDocument.DocumentType">
            <summary>
            A Guid that identifies the kind of document to applications such as a debugger. Typically System.Diagnostics.SymbolStore.SymDocumentType.Text.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPrimarySourceDocument.Language">
            <summary>
            A Guid that identifies the programming language used in the source document. Typically used by a debugger to locate language specific logic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPrimarySourceDocument.LanguageVendor">
            <summary>
            A Guid that identifies the compiler vendor programming language used in the source document. Typically used by a debugger to locate vendor specific logic.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IPrimarySourceDocument.PrimarySourceLocation">
            <summary>
            A source location corresponding to the entire document.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IArrayTypeReference">
            <summary>
            This interface models the metadata representation of an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IArrayTypeReference.GetElementType(System.Object)">
            <summary>
            The type of the elements of this array.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.IsVector">
            <summary>
            This type of array is a single dimensional array with zero lower bound for index values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.LowerBounds">
            <summary>
            A possibly empty list of lower bounds for dimension indices. When not explicitly specified, a lower bound defaults to zero.
            The first lower bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Rank">
            <summary>
            The number of array dimensions.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IArrayTypeReference.Sizes">
            <summary>
            A possible empty list of upper bounds for dimension indices.
            The first upper bound in the list corresponds to the first dimension. Dimensions cannot be skipped.
            An unspecified upper bound means that instances of this type can have an arbitrary upper bound for that dimension.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ICustomModifier">
            <summary>
            Modifies the set of allowed values for a type, or the semantics of operations allowed on those values. 
            Custom modifiers are not associated directly with types, but rather with typed storage locations for values.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomModifier.IsOptional">
            <summary>
            If true, a language may use the modified storage location without being aware of the meaning of the modification.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ICustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies to the storage location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IFunctionPointerTypeReference">
            <summary>
            This interface models the metadata representation of a function pointer type reference.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IFunctionPointerTypeReference.ExtraArgumentTypes">
            <summary>
            The types and modifiers of extra arguments that the caller will pass to the methods that are pointed to by this pointer.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameter">
            <summary>
            The definition of a type parameter of a generic method.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericMethodParameterReference">
            <summary>
            A reference to a type parameter of a generic method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod">
            <summary>
            A reference to the generic method that defines the referenced type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericMethodParameter.DefiningMethod">
            <summary>
            The generic method that defines this type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IGenericTypeInstanceReference">
            <summary>
            A generic type instantiated with a list of type arguments
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IGenericTypeInstanceReference.GetGenericArguments(System.Object)">
            <summary>
            The type arguments that were used to instantiate this.GenericType in order to create this type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IGenericTypeInstanceReference.GenericType">
            <summary>
            Returns the generic type of which this type is an instance.
            Equivalent to Symbol.OriginalDefinition
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ISpecializedNestedTypeReference">
            <summary>
            A reference to a type definition that is a specialized nested type.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion">
            <summary>
            A reference to the nested type that has been specialized to obtain this nested type reference. When the containing type is an instance of type which is itself a specialized member (i.e. it is a nested
            type of a generic type instance), then the unspecialized member refers to a member from the unspecialized containing type. (I.e. the unspecialized member always
            corresponds to a definition that is not obtained via specialization.)
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IMethodImplementation">
            <summary>
            Models an explicit implemenation or override of a base class virtual method or an explicit implementation of an interface method.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IMethodImplementation.Dispatch(Microsoft.Cci.IMetadataVisitor)">
            <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IDefinition. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ContainingType">
            <summary>
            The type that is explicitly implementing or overriding the base class virtual method or explicitly implementing an interface method.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ImplementedMethod">
            <summary>
            A reference to the method whose implementation is being provided or overridden.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IMethodImplementation.ImplementingMethod">
            <summary>
            A reference to the method that provides the implementation.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IPointerTypeReference">
            <summary>
            This interface models the metadata representation of a pointer to a location in unmanaged memory.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IPointerTypeReference.GetTargetType(System.Object)">
            <summary>
            The type of value stored at the target memory location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IManagedPointerTypeReference">
            <summary>
            This interface models the metadata representation of a managed pointer.
            Remark: This should be only used in attributes. For other objects like Local variables etc
            there is explicit IsReference field that should be used.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IManagedPointerTypeReference.GetTargetType(System.Object)">
            <summary>
            The type of value stored at the target memory location.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.PrimitiveTypeCode">
            <summary>
            A enumeration of all of the value types that are built into the Runtime (and thus have specialized IL instructions that manipulate them).
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Boolean">
            <summary>
            A single bit.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Char">
            <summary>
            An usigned 16 bit integer representing a Unicode UTF16 code point.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int8">
            <summary>
            A signed 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float32">
            <summary>
            A 32 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Float64">
            <summary>
            A 64 bit IEEE floating point number.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int16">
            <summary>
            A signed 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int32">
            <summary>
            A signed 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Int64">
            <summary>
            A signed 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.IntPtr">
            <summary>
            A signed 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Pointer">
            <summary>
            A pointer to fixed or unmanaged memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Reference">
            <summary>
            A reference to managed memory.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.String">
            <summary>
            A string.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt8">
            <summary>
            An unsigned 8 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt16">
            <summary>
            An unsigned 16 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt32">
            <summary>
            An unsigned 32 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UInt64">
            <summary>
            An unsigned 64 bit integer.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.UIntPtr">
            <summary>
            An unsigned 32 bit integer or 64 bit integer, depending on the native word size of the underlying processor.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Void">
            <summary>
            A type that denotes the absense of a value.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.NotPrimitive">
            <summary>
            Not a primitive type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.PrimitiveTypeCode.Invalid">
            <summary>
            Type is a dummy type.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeMemberVisibility">
            <summary>
            Enumerates the different kinds of levels of visibility a type member can have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Default">
            <summary>
            The visibility has not been specified. Use the applicable default.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Assembly">
            <summary>
            The member is visible only within its own assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Family">
            <summary>
            The member is visible only within its own type and any subtypes.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyAndAssembly">
            <summary>
            The member is visible only within the intersection of its family (its own type and any subtypes) and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.FamilyOrAssembly">
            <summary>
            The member is visible only within the union of its family and assembly. 
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Other">
            <summary>
            The member is visible only to the compiler producing its assembly.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Private">
            <summary>
            The member is visible only within its own type.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Public">
            <summary>
            The member is visible everywhere its declaring type is visible.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeMemberVisibility.Mask">
            <summary>
            A mask that can be used to mask out flag bits when the latter are stored in the same memory word as this enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.TypeParameterVariance">
            <summary>
            Enumerates the different kinds of variance a generic method or generic type parameter may have.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.NonVariant">
            <summary>
            Two type or method instances are compatible only if they have exactly the same type argument for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Covariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a subtype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Contravariant">
            <summary>
            A type or method instance will match another instance if it has a type for this parameter that is the same or a supertype of the type the
            other instance has for this parameter.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.TypeParameterVariance.Mask">
            <summary>
            A mask that can be used to mask out flag bits when the latter are stored in the same memory word as the enumeration.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.UnitHelper">
            <summary>
            Class containing helper routines for Units
            </summary>
        </member>
        <member name="M:Microsoft.Cci.UnitHelper.StrongName(Microsoft.Cci.IAssemblyReference)">
            <summary>
            Computes the string representing the strong name of the given assembly reference.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.ModuleKind">
            <summary>
            The kind of metadata stored in the module. For example whether the module is an executable or a manifest resource file.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.ConsoleApplication">
            <summary>
            The module is an executable with an entry point and has a console.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.WindowsApplication">
            <summary>
            The module is an executable with an entry point and does not have a console.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.DynamicallyLinkedLibrary">
            <summary>
            The module is a library of executable code that is dynamically linked into an application and called via the application.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.ManifestResourceFile">
            <summary>
            The module contains no executable code. Its contents is a resource stream for the modules that reference it.
            </summary>
        </member>
        <member name="F:Microsoft.Cci.ModuleKind.UnmanagedDynamicallyLinkedLibrary">
            <summary>
            The module is a library of executable code but contains no .NET metadata and is specific to a processor instruction set.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAssembly">
            <summary>
            Represents a .NET assembly.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModule">
            <summary>
            An object that represents a .NET module.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnit">
            <summary>
            A unit of metadata stored as a single artifact and potentially produced and revised independently from other units.
            Examples of units include .NET assemblies and modules, as well C++ object files and compiled headers.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IUnitReference">
            <summary>
            A reference to a instance of <see cref="T:Microsoft.Cci.IUnit"/>.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IModuleReference">
            <summary>
            A reference to a .NET module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModuleReference.ContainingAssembly">
            <summary>
            The Assembly that contains this module. May be null if the module is not part of an assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetStrings">
            <summary>
            Returns zero or more strings used in the module. If the module is produced by reading in a CLR PE file, then this will be the contents
            of the user string heap. If the module is produced some other way, the method may return an empty enumeration or an enumeration that is a
            subset of the strings actually used in the module. The main purpose of this method is to provide a way to control the order of strings in a
            prefix of the user string heap when writing out a module as a PE file.
            </summary>
        </member>
        <member name="M:Microsoft.Cci.IModule.GetAllTypes">
            <summary>
            Returns all of the types defined in the current module. These are always named types, in other words: INamespaceTypeDefinition or INestedTypeDefinition instances.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.AssemblyAttributes">
            <summary>
            A list of objects representing persisted instances of types that extend System.Attribute. Provides an extensible way to associate metadata
            with this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.AssemblySecurityAttributes">
            <summary>
            A list of objects representing persisted instances of pairs of security actions and sets of security permissions.
            These apply by default to every method reachable from the module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.AssemblyReferences">
            <summary>
            A list of the assemblies that are referenced by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.CorLibrary">
            <summary>
            CorLibrary assembly referenced by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.BaseAddress">
            <summary>
            The preferred memory address at which the module is to be loaded at runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ContainingAssembly">
            <summary>
            The Assembly that contains this module. If this module is main module then this returns this.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.DllCharacteristics">
            <summary>
            Flags that control the behavior of the target operating system. CLI implementations are supposed to ignore this, but some operating system pay attention.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.EntryPoint">
            <summary>
            The method that will be called to start execution of this executable module. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.FileAlignment">
            <summary>
            The alignment of sections in the module's image file.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ILOnly">
            <summary>
            True if the module contains only IL and is processor independent.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Kind">
            <summary>
            The kind of metadata stored in this module. For example whether this module is an executable or a manifest resource file.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.LinkerMajorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 8 in 8.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.LinkerMinorVersion">
            <summary>
            The first part of a two part version number indicating the version of the linker that produced this module. For example, the 0 in 8.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.MetadataFormatMajorVersion">
            <summary>
            The first part of a two part version number indicating the version of the format used to persist this module. For example, the 1 in 1.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.MetadataFormatMinorVersion">
            <summary>
            The second part of a two part version number indicating the version of the format used to persist this module. For example, the 0 in 1.0.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleAttributes">
            <summary>
            A list of objects representing persisted instances of types that extend System.Attribute. Provides an extensible way to associate metadata
            with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleName">
            <summary>
            The name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.ModuleReferences">
            <summary>
            A list of the modules that are referenced by this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.PersistentIdentifier">
            <summary>
            A globally unique persistent identifier for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.RequiresAmdInstructionSet">
            <summary>
            If set, the module contains instructions or assumptions that are specific to the AMD 64 bit instruction set. Setting this flag to
            true also sets Requires64bits to true.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Requires32bits">
            <summary>
            If set, the module contains instructions that assume a 32 bit instruction set. For example it may depend on an address being 32 bits.
            This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Prefers32bits">
            <summary>
            True if the module contains only IL and is processor independent. Should there be a choice between launching as a 64-bit or 32-bit
            process, this setting will cause the host to launch it as a 32-bit process. 
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Requires64bits">
            <summary>
            If set, the module contains instructions that assume a 64 bit instruction set. For example it may depend on an address being 64 bits.
            This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfHeapCommit">
            <summary>
            The size of the virtual memory initially committed for the initial process heap.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfHeapReserve">
            <summary>
            The size of the virtual memory to reserve for the initial process heap.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfStackCommit">
            <summary>
            The size of the virtual memory initially committed for the initial thread's stack.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.SizeOfStackReserve">
            <summary>
            The size of the virtual memory to reserve for the initial thread's stack.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.TargetRuntimeVersion">
            <summary>
            Identifies the version of the CLR that is required to load this module or assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.TrackDebugData">
            <summary>
            True if the instructions in this module must be compiled in such a way that the debugging experience is not compromised.
            To set the value of this property, add an instance of System.Diagnostics.DebuggableAttribute to the MetadataAttributes list.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IModule.Win32Resources">
            <summary>
            A list of named byte sequences persisted with the module and used during execution, typically via the Win32 API.
            A module will define Win32 resources rather than "managed" resources mainly to present metadata to legacy tools
            and not typically use the data in its own code. This list of IWin32Resources must be sorted first by type then
            by name.
            </summary>
        </member>
        <member name="T:Microsoft.Cci.IAssemblyReference">
            <summary>
            A reference to a .NET assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.Culture">
            <summary>
            Identifies the culture associated with the assembly reference. Typically specified for sattelite assemblies with localized resources.
            Empty or null if not specified.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.IsRetargetable">
            <summary>
            True if the implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.ContentType">
            <summary>
            Type of code contained in an assembly. Determines assembly binding model.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.PublicKeyToken">
            <summary>
            The hashed 8 bytes of the public key of the referenced assembly. This is empty or null if the referenced assembly does not have a public key.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.Version">
            <summary>
            The version of the assembly reference. Null means Version(0, 0, 0, 0).
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssemblyReference.Location">
            <summary>
            Full path to assembly file or null if not specified.
            </summary>
            <remarks>
            The location is available when full path to the reference was provided in addition to an assembly name.
            </remarks>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.ExportedTypes">
            <summary>
            Public types defined in other modules making up this assembly and to which other assemblies may refer to via this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.Files">
            <summary>
            A list of the files that constitute the assembly. These are not the source language files that may have been
            used to compile the assembly, but the files that contain constituent modules of a multi-module assembly as well
            as any external resources. It corresonds to the File table of the .NET assembly file format.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.Flags">
            <summary>
            A set of bits and bit ranges representing properties of the assembly. The value of <see cref="P:Microsoft.Cci.IAssembly.Flags"/> can be set
            from source code via the AssemblyFlags assembly custom attribute. The interpretation of the property depends on the target platform.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.PublicKey">
            <summary>
            The public part of the key used to encrypt the SHA1 hash over the persisted form of this assembly. Empty or null if not specified.
            This value is used by the loader to decrypt an encrypted hash value stored in the assembly, which it then compares with a freshly computed hash value
            in order to verify the integrity of the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Cci.IAssembly.Resources">
            <summary>
            A list of named byte sequences persisted with the assembly and used during execution, typically via .NET Framework helper classes.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.RuntimeMembers.MemberDescriptor">
            <summary>
            Structure that describes a member of a type.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.RuntimeMembers.MemberDescriptor.DeclaringTypeId">
            <summary>
            Id/token of containing type, usually value from some enum.
            For example from SpecialType enum.
            I am not using SpecialType as the type for this field because
            VB runtime types are not part of SpecialType.
            
            So, the implication is that any type ids we use outside of the SpecialType 
            (either for the VB runtime classes, or types like System.Task etc.) will need 
            to use IDs that are all mutually disjoint. 
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.RuntimeMembers.MemberDescriptor.Signature">
            <summary>
            Signature of the field or method, similar to metadata signature, 
            but with the following exceptions:
               1) Truncated on the left, for methods starts at [ParamCount], for fields at [Type]
               2) Type tokens are not compressed
               3) BOOLEAN | CHAR | I1 | U1 | I2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U | Void types are encoded by 
                  using VALUETYPE+typeId notation.
               4) array bounds are not included.
               5) modifiers are not included.
               6) (CLASS | VALUETYPE) are omitted after GENERICINST
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5">
            <summary>
            Helper class to match signatures in format of 
            MemberDescriptor.Signature to members.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.MatchFieldSignature(`1,Roslyn.Compilers.ReadOnlyArray{System.Int32})">
            <summary>
            Returns true if signature matches signature of the field.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.MatchPropertySignature(`2,Roslyn.Compilers.ReadOnlyArray{System.Int32})">
            <summary>
            Returns true if signature matches signature of the property.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.MatchMethodSignature(`0,Roslyn.Compilers.ReadOnlyArray{System.Int32})">
            <summary>
            Returns true if signature matches signature of the method.
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.MatchType(`3,Roslyn.Compilers.ReadOnlyArray{System.Int32},System.Int32@)">
            <summary>
            Does pretty much the same thing as MetadataDecoder.DecodeType only instead of 
            producing a type symbol it compares encoded type to the target.
            
            Signature should be in format described in MemberDescriptor.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.GetGenericTypeArgument(`3,System.Int32)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.GetGenericTypeDefinition(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.GetPointedToType(`3)">
            <summary>
            Should only accept Pointer types.
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.GetSZArrayElementType(`3)">
            <summary>
            Should return null in case of error.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.MatchArrayRank(`3,System.Int32)">
            <summary>
            Should only accept multi-dimansional arrays.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.RuntimeMembers.SignatureComparer`5.GetArrayElementType(`3)">
            <summary>
            Should only accept multi-dimansional arrays.
            Should return null in case of error.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.SpecialTypes.emittedNames">
            <summary>
            Array of names for types from Cor Libraray.
            The names should correspond to ids from TypeId enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Roslyn.Compilers.SpecialTypes.GetMetadataName(Roslyn.Compilers.SpecialType)">
            <summary>
            Gets the name of the special type as it would appear in metadata.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a hash-set of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.WithAdditionalAnnotations``1(``0,Roslyn.Compilers.SyntaxAnnotation[])">
            <summary>
            Creates a new node identical to this node with the specified annotations attached.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotatedNodesAndTokens``1(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets all nodes or tokens with annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotatedNodesAndTokens(Roslyn.Compilers.Common.CommonSyntaxNode,Roslyn.Compilers.SyntaxAnnotation)">
            <summary>
            Gets all nodes or tokens with this specific annotation attached.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotatedTrivia``1(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets all trivia with annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.HasAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Determines if the node as annotations of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxNode)">
            <summary>
            Gets all annotations of the specific type attached to the node.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.HasAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Determines if this token or any of its trivia has an annotation of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxToken)">
            <summary>
            Gets all the annotations of the specified type on this token or any of its trivia.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.HasAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Determines whether this trivia or its sub structure has an annotation of the specified type.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxTrivia)">
            <summary>
            Get all the annotations of the specified type on this trivia or any of its sub structure.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.HasAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Determines if this node or token has any annotation of the specified type attached.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.CommonAnnotationExtensions.GetAnnotations``1(Roslyn.Compilers.Common.CommonSyntaxNodeOrToken)">
            <summary>
            Gets all the annotations of the specified type attached to this node or token (or any sub  node).
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.IText">
            <summary>
            Represents an immutable snapshot of text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetLineFromLineNumber(System.Int32)">
            <summary>
            Gets the line corresponding to the provided line number.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetLineFromPosition(System.Int32)">
            <summary>
            Gets the line which encompasses the provided position.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetLineNumberFromPosition(System.Int32)">
            <summary>
            Gets the number of the line that contains the character at the specified position.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetLinePosition(System.Int32)">
            <summary>
            Gets a line number, and position within that line, for the character at the 
            specified position
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.ToString">
            <summary>
            Returns a string representation of the contents of this IText.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.ToString(Roslyn.Compilers.TextSpan)">
            <summary>
            Returns a string representation of the contents of this IText within the given span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetSubText(Roslyn.Compilers.TextSpan)">
            <summary>
            Gets the a new IText that corresponds to the contents of this IText for the given span.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy the count contents of IText starting from sourceIndex to destination starting at
            destinationIndex.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.Write(System.IO.TextWriter)">
            <summary>
            Write the text to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.IText.GetChangeRanges(Roslyn.Compilers.IText)">
            <summary>
            Gets the set of TextChangeRanges that describe how the text changed between this text and
            the old version. Some texts keep track of changes between themselves and previous instances
            and may report detailed changes. Others many simply report a single change encompassing the
            entire text.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.IText.Container">
            <summary>
            The container for the text.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.IText.Length">
            <summary>
            Total number of characters in the text source.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.IText.LineCount">
            <summary>
            Total number of lines in the text.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.IText.Lines">
            <summary>
            Returns the collection of line information for the <see cref="T:IText"/> instance.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.IText.Item(System.Int32)">
            <summary>
            Return the char at position in the IText.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ITextContainer">
            <summary>
            An object that contains an instance of an IText and raises events when its current instance
            changes.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextContainer.CurrentText">
            <summary>
            The current text instance.
            </summary>
        </member>
        <member name="E:Roslyn.Compilers.ITextContainer.TextChanged">
            <summary>
            Raised when the current text instance changes.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.TextBase.lazyLineStarts">
            <summary>
            The line start position of each line.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextBase.ToString">
            <summary>
            Provides a string representation of the TextBase.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextBase.ToString(Roslyn.Compilers.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="M:Roslyn.Compilers.TextBase.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy a range of characters from this IText to a destination array.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextBase.Write(System.IO.TextWriter)">
            <summary>
            Write this IText to a text writer.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextBase.Write(System.IO.TextWriter,Roslyn.Compilers.TextSpan)">
            <summary>
            Write a span of text to a text writer.
            </summary>
            <param name="writer"></param>
            <param name="span"></param>
        </member>
        <member name="P:Roslyn.Compilers.TextBase.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextBase.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="P:Roslyn.Compilers.TextBase.Container">
            <summary>
            The container of this IText
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextBase.LineCount">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextBase.Roslyn#Compilers#IText#Lines">
            <summary>
            The sequence of lines represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.CompositeText">
            <summary>
            An IText that is a composite of a sequence of ITexts
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.SubText">
            <summary>
            An IText that represents a subrange of another IText.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextExtensions.WithChanges(Roslyn.Compilers.IText,System.Collections.Generic.IEnumerable{Roslyn.Compilers.TextChange})">
            <summary>
            Construct a new IText with the specified changes.
            The changes must be ordered and not overlapping.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextExtensions.WithChanges(Roslyn.Compilers.IText,Roslyn.Compilers.TextChange[])">
            <summary>
            Construct a new IText with the specified changes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextExtensions.GetSubText(Roslyn.Compilers.IText,System.Int32)">
            <summary>
            Constructs a new text that has the contents of this text including and after the start position.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextExtensions.GetTextChanges(Roslyn.Compilers.IText,Roslyn.Compilers.IText)">
            <summary>
            Gets the set of TextChanges that describe how the text changed
            between old and new versions. Some containers keep track of changes between
            text instances and may report multiple detailed changes. Others many simply report
            a single change from old to new encompassing the entire text.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextLine">
            <summary>
            StringText implementation of ITextLine
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.ITextLine">
            <summary>
            Immutable representation of a line in an IText instance
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.ITextLine.ToString">
            <summary>
            Gets the text of the line 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.Start">
            <summary>
            Start of the line
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.End">
            <summary>
            End of the line not including the line break
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.EndIncludingLineBreak">
            <summary>
            End of the line including the line break
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.Extent">
            <summary>
            Extent of the line not incluing the line break
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.ExtentIncludingLineBreak">
            <summary>
            Extent of the line including the line break
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.ITextLine.LineNumber">
            <summary>
            Gets the line number for this line.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextLine.#ctor(Roslyn.Compilers.IText,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a new TextLineSpan from the given parameters
            </summary>
            <param name="text">StringText this Line is a part of</param>
            <param name="start">Start position of the TextLineSpan</param>
            <param name="length">Length of the span not including the line break</param>
            <param name="lineBreakLength">Length of the line break section of the line</param>
            <param name="lineNumber">Line number of this line.</param>
        </member>
        <member name="T:Roslyn.Compilers.LinePosition">
            <summary>
            Immutable representation of a line number and position within a IText instance.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:Roslyn.Compilers.LinePosition"/> with the given line and character.
            </summary>
            <param name="line">
            The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
            </param>
            <param name="character">
            The character position in the line.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.op_Equality(Roslyn.Compilers.LinePosition,Roslyn.Compilers.LinePosition)">
            <summary>
            Determines whether two <see cref="T:LinePositions"/> are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.op_Inequality(Roslyn.Compilers.LinePosition,Roslyn.Compilers.LinePosition)">
            <summary>
            Determines whether two <see cref="T:LinePositions"/> are different.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.Equals(Roslyn.Compilers.LinePosition)">
            <summary>
            Determines whether two <see cref="T:LinePositions"/> are the same.
            </summary>
            <param name="other">The object to compare.</param>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.Equals(System.Object)">
            <summary>
            Determines whether two <see cref="T:LinePositions"/> are the same.
            </summary>
            <param name="obj">The object to compare.</param>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.GetHashCode">
            <summary>
            Provides a hash function for <see cref="T:LinePositions"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.LinePosition.ToString">
            <summary>
            Provides a string representation for <see cref="T:LinePositions"/>.
            </summary>
            <example>0,10</example>
        </member>
        <member name="F:Roslyn.Compilers.LinePosition.Zero">
            <summary>
            A <see cref="T:LinePositions"/> that represents position 0 at line 0.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.LinePosition.Line">
            <summary>
            The line number. The first line in a file is defined as line 0 (zero based line numbering).
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.LinePosition.Character">
            <summary>
            The character position within the line.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.StringBuilderText">
            <summary>
            Implementation of IText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.StringBuilderText.builder">
            <summary>
            Underlying string on which this IText instance is based
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringBuilderText.#ctor(System.Text.StringBuilder)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided data.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringBuilderText.ToString(Roslyn.Compilers.TextSpan)">
            <summary>
            Provides a string representation of the StringBuilderText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="P:Roslyn.Compilers.StringBuilderText.Builder">
            <summary>
            Underlying string which is the source of this IText instance
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.StringBuilderText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.StringBuilderText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="T:Roslyn.Compilers.StringText">
            <summary>
            Implementation of IText based on a <see cref="T:System.String"/> input
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.StringText.source">
            <summary>
            Underlying string on which this IText instance is based
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringText.#ctor(System.String)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided data.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringText.#ctor(System.IO.Stream)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided bytes.
            The following encodings will be automatically detected: BigEndianUnicode, Unicode, UTF8
            (with or without byte order mark).  The default windows codepage will be used as a fallback.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringText.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Initializes an instance of <see cref="T:StringText"/> with provided bytes.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.StringText.ToString(Roslyn.Compilers.TextSpan)">
            <summary>
            Provides a string representation of the StringText located within given span.
            </summary>
            <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        </member>
        <member name="P:Roslyn.Compilers.StringText.Source">
            <summary>
            Underlying string which is the source of this IText instance
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.StringText.Length">
            <summary>
            The length of the text represented by <see cref="T:StringText"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.StringText.Item(System.Int32)">
            <summary>
            Returns a character at given position.
            </summary>
            <param name="position">The position to get the character from.</param>
            <returns>The character.</returns>
            <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
            greater than <see cref="T:"/> length.</exception>
        </member>
        <member name="T:Roslyn.Compilers.TextChange">
            <summary>
            Describes a single change when a particular span is replaced with a new text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextChange.#ctor(Roslyn.Compilers.TextSpan,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:TextChange"/>
            </summary>
            <param name="span">The original span of the changed text.</param>
            <param name="newText">The new text.</param>
        </member>
        <member name="M:Roslyn.Compilers.TextChange.ToString">
            <summary>
            Provides a string representation for <see cref="T:TextChange"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextChange.Span">
            <summary>
            The original span of the changed text. 
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextChange.NewText">
            <summary>
            The new text.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextChangeRange">
            <summary>
            Represents the change to a span of text.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.#ctor(Roslyn.Compilers.TextSpan,System.Int32)">
            <summary>
            Initializes a new instance of <see cref="T:TextChangeRange"/>.
            </summary>
            <param name="span"></param>
            <param name="newLength"></param>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.Equals(Roslyn.Compilers.TextChangeRange)">
            <summary>
            Compares current instance of <see cref="T:TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.Equals(System.Object)">
            <summary>
            Compares current instance of <see cref="T:TextChangeRange"/> to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.GetHashCode">
            <summary>
            Provides hash code for current instnce of <see cref="T:TextChangeRange"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.op_Equality(Roslyn.Compilers.TextChangeRange,Roslyn.Compilers.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:TextChangeRange"/> are same.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextChangeRange.op_Inequality(Roslyn.Compilers.TextChangeRange,Roslyn.Compilers.TextChangeRange)">
            <summary>
            Determines if two instances of <see cref="T:TextChangeRange"/> are different.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextChangeRange.Span">
            <summary>
            The span of text before the edit which is being changed
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextChangeRange.NewLength">
            <summary>
            Width of the span after the edit.  A 0 here would represent a delete
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextSpan">
            <summary>
            Immutable abstract representation of a span of text.  For example, in an error diagnostic that reports a
            location, it could come from a parsed string, text from a tool editor buffer, etc.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a TextSpan instance beginning with the position Start and having the Length specified 
            with length
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Contains(System.Int32)">
            <summary>
            Determines whether the position lies within the span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position is greater than or equal to Start and strictly less 
            than End, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Contains(Roslyn.Compilers.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> falls completely within this span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.OverlapsWith(Roslyn.Compilers.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
            if they have positions in common and neither is empty. Empty spans do not overlap with any 
            other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans overlap, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Overlap(Roslyn.Compilers.TextSpan)">
            <summary>
            Returns the overlap with the given span, or null if there is no overlap.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The overlap of the spans, or null if the overlap is empty.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.IntersectsWith(Roslyn.Compilers.TextSpan)">
            <summary>
            Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
            intersect if they have positions in common or the end of one span 
            coincides with the start of the other span.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            <c>true</c> if the spans intersect, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.IntersectsWith(System.Int32)">
            <summary>
            Determines whether <paramref name="position"/> intersects this span. 
            A position is considered to intersect if it is between the start and
            end positions (inclusive) of this span.
            </summary>
            <param name="position">
            The position to check.
            </param>
            <returns>
            <c>true</c> if the position intersects, otherwise <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Intersection(Roslyn.Compilers.TextSpan)">
            <summary>
            Returns the intersection with the given span, or null if there is no intersection.
            </summary>
            <param name="span">
            The span to check.
            </param>
            <returns>
            The intersection of the spans, or null if the intersection is empty.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.FromBounds(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:TextSpan"/> from <param name="start" /> and <param
            name="end"/> positions as opposed to a position and length.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.op_Equality(Roslyn.Compilers.TextSpan,Roslyn.Compilers.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:TextSpan"/> are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.op_Inequality(Roslyn.Compilers.TextSpan,Roslyn.Compilers.TextSpan)">
            <summary>
            Determines if two instances of <see cref="T:TextSpan"/> are different.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Equals(Roslyn.Compilers.TextSpan)">
            <summary>
            Determines if current instance of <see cref="T:TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.Equals(System.Object)">
            <summary>
            Determines if current instance of <see cref="T:TextSpan"/> is equal to another.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.GetHashCode">
            <summary>
            Produces a hash code for <see cref="T:TextSpan"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.ToString">
            <summary>
            Provides a string representation for <see cref="T:TextSpan"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextSpan.CompareTo(Roslyn.Compilers.TextSpan)">
            <summary>
            Compares current instance of <see cref="T:TextSpan"/> with another.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextSpan.Start">
            <summary>
            Start point of the Span
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextSpan.End">
            <summary>
            End of the span
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextSpan.Length">
            <summary>
            Length of the span
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.TextSpan.IsEmpty">
            <summary>
            Determines whether or not the span is empty
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextUtilities">
            <summary>
            Holder for common Text Utility functions and values
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextUtilities.Create(System.Action{System.IO.TextWriter})">
            <summary>
            Create a new IText instance from a function that writes to a TextWriter
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextUtilities.GetStartAndLengthOfLineBreakEndingAt(Roslyn.Compilers.IText,System.Int32,System.Int32@,System.Int32@)">
            <summary>
            Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
            Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
            Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextUtilities.IsAnyLineBreakCharacter(System.Char)">
            <summary>
            Determine if the character in question is any line break character
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.TextUtilities.DetectEncodingAndDecode(System.IO.Stream)">
            The following encodings will be automatically detected: BigEndianUnicode, Unicode, UTF8
            (with or without byte order mark).  The default windows codepage will be used as a fallback.
        </member>
        <member name="F:Roslyn.Compilers.TextUtilities.NoEncoderFallback">
            <summary>
            We never indent to encode anything with this, but we need some value to pass to GetEncoding in TryDecodeUTF8NoBOM.
            All instances can share this object.
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextUtilities.SimpleEncoderFallback">
            <summary>
            We never encode anything, but we need something to pass to GetEncoding
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TextUtilities.SimpleDecoderFallback">
            <summary>
            Simple decoder fallback (just used to detect if there was an error while decoding)
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TreeDumper">
            <summary>
            This is ONLY used id BoundNode.cs Debug method - Dump()
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.TreeDumperNode">
            <summary>
            This is ONLY used for debugging purpose
            </summary>
        </member>
        <member name="T:Roslyn.Compilers.AssemblyIdentity">
            <summary>
            Represents an identity of an assembly as defined by CLI metadata specification.
            </summary>
            <remarks>
            May represent assembly definition or assembly reference identity.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.GetDisplayName(System.Boolean)">
            <summary>
            Returns the display name of the assembly identity.
            </summary>
            <param name="fullKey">True if the full public key should be included in the name. Otherwise public key token is used.</param>
            <returns>The display name.</returns>
            <remarks>
            Characters ',', '=', '"', '\'', '\' occuring in the simple name is escaped by backslash in the display name.
            Any character '\t' is replaced by two characters '\' and 't',
            Any character '\n' is replaced by two characters '\' and 'n',
            Any character '\r' is replaced by two characters '\' and 'r',
            The assembly name in the display name is enclosed in double qoutes if it starts or ends with 
            a whitespace character (' ', '\t', '\r', '\n').
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.TryParseDisplayName(System.String,Roslyn.Compilers.AssemblyIdentity@)">
            <summary>
            Parses display name filling defaults for any basic properties that are missing (and thus ever producing a partial name).
            </summary>
            <param name="displayName">Display name.</param>
            <param name="identity">A full assembly identity.</param>
            <returns>True if display name parsed correctly.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.TryParseSimpleName(System.String,System.String@)">
            <summary>
            Parses simple name out of an assembly display name.
            </summary>
            <param name="displayName">Display name.</param>
            <param name="simpleName">Simple name.</param>
            <returns>True if successful.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="displayName"/> is null.</exception>
            <remarks>
            The result is not equivalent to calling <see cref="M:TryParseDisplayName"/> and retrieving <see cref="P:Roslyn.Compilers.AssemblyIdentity.Name"/> property.
            This method might succeed even if the name is not well formed as it only parses a part of it.
            This method also succeeds in parsing some simple names that <see cref="M:TryParseDisplayName"/> rejects,
            for example a whitespace only name.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.FromAssemblyDefinition(System.String)">
            <summary>
            Reads assembly definition identity from given assembly file.
            </summary>
            <param name="path">Path to the assembly file.</param>
            <returns>Assembly definition identity.</returns>
            <remarks>
            Uses current working directory of the process if path is relative.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.FromAssemblyDefinition(System.Reflection.Assembly)">
            <summary>
            Retrieves assembly definition identity from given runtime assembly.
            </summary>
            <param name="assembly">The runtime assembly.</param>
            <returns>Assembly definition identity.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="assembly"/> is null.</exception>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ToAssemblyName(System.Boolean)">
            <summary>
            Converts this identity to <see cref="T:System.Reflection.AssemblyName"/>.
            </summary>
            <param name="setCodeBase">
            True if the <see cref="P:System.Reflection.AssemblyName.CodeBase"/> property should be set based upon the value of <see cref="P:Roslyn.Compilers.AssemblyIdentity.Location"/>.
            </param>
            <returns>A new instance of <see cref="T:System.Reflection.AssemblyName"/>.</returns>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.MatchDefinition(Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Matches assembly reference identity against definition identity.
            </summary>
            <param name="definition">Definition identity.</param>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ReferenceMatchesDefinition(System.String,Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Compares assembly reference (partial) name with definition identity.
            </summary>
            <param name="referenceDisplayName">Partial or full assembly display name.</param>
            <param name="definition">Definition identity.</param>
            <returns>True if the reference name matches the definition name.</returns>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ReferenceMatchesDefinition(System.String,System.String)">
            <summary>
            Compares assembly reference (partial) name with definition name.
            </summary>
            <param name="referenceDisplayName">Partial or full assembly display name.</param>
            <param name="definitionFullDisplayName">Full assembly display name.</param>
            <returns>True if the reference name matches the definition name.</returns>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.IsEquivalent(Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Compares two assembly identities for equivalence.
            </summary>
            <param name="other">Assembly identitity.</param>
            <returns>True if this identity is equivalent to the <paramref name="other"/>.</returns>
            <remarks>
            Unifies Framework assemblies, doesn't unify versions of non-Framework assemblies.
            </remarks>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.MemberwiseEqual(Roslyn.Compilers.AssemblyIdentity,Roslyn.Compilers.AssemblyIdentity)">
            <summary>
            Returns true (false) if specified assembly identities are (not) equal 
            regardless of unification, retargeting or other assembly binding policies. 
            Returns null if these policies must be consulted to determine name equivalence.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.GetBestMatch(Roslyn.Compilers.AssemblyIdentity.IAssemblyName,System.Collections.Generic.IEnumerable{Roslyn.Compilers.AssemblyIdentity.IAssemblyName},System.String)">
            <summary>
            Selects the candidate assembly name that best matches given name and optionally culture.
            All candidate names must include versions and cultures.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ToAssemblyName(Roslyn.Compilers.AssemblyIdentity.IAssemblyName)">
            <summary>
            Converts <see cref="T:Roslyn.Compilers.AssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with possibly missing name components.
            </summary>
            <returns>
            An <see cref="T:System.Reflection.AssemblyName"/> whose fields are be null if not present in <paramref name="nameObject"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ToAssemblyIdentity(Roslyn.Compilers.AssemblyIdentity.IAssemblyName,System.String)">
            <summary>
            Converts <see cref="T:Roslyn.Compilers.AssemblyIdentity.IAssemblyName"/> to <see cref="T:System.Reflection.AssemblyName"/> with all metadata fields filled.
            </summary>
            <returns>
            Assembly name with Version, Culture and PublicKeyToken components filled in:
            "SimpleName, Version=#.#.#.#, Culture=XXX, PublicKeyToken=XXXXXXXXXXXXXXXX".
            In addition Retargetable flag and ContentType are set.
            </returns>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ToAssemblyNameObject(System.Reflection.AssemblyName)">
            <summary>
            Converts <see cref="T:System.Reflection.AssemblyName"/> to an equivalent <see cref="T:Roslyn.Compilers.AssemblyIdentity.IAssemblyName"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.AssemblyIdentity.ToAssemblyNameObject(System.String)">
            <summary>
            Creates <see cref="T:Roslyn.Compilers.AssemblyIdentity.IAssemblyName"/> object by parsing given display name.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyIdentity.ContentType">
            <summary>
            Specifies assembly binding model for the assembly definition or reference, 
            that is how assembly references are matched to assembly definitions.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyIdentity.HasPublicKey">
            <summary>
            True if the assembly identity includes full public key.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyIdentity.PublicKey">
            <summary>
            Full public key or empty.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyIdentity.PublicKeyToken">
            <summary>
            Low 8 bytes of SHA1 hash of the public key, or empty.
            </summary>
        </member>
        <member name="P:Roslyn.Compilers.AssemblyIdentity.IsStrongName">
            <summary>
            True if the assembly identity has a strong name, ie. either a full public key or a token.
            False if <see cref="P:Roslyn.Compilers.AssemblyIdentity.ContentType"/> is <see cref="F:System.Reflection.AssemblyContentType.WindowsRuntime"/> regardless of key presence.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.AssemblyIdentity.MatchResult.NotEquivalent">
            <summary>
            Reference doesn't match definition.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.AssemblyIdentity.MatchResult.Equivalent">
            <summary>
            Strongly named reference matches strongly named definition (strong identity is identity with public key or token),
            Or weak reference matches weak definition.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.AssemblyIdentity.MatchResult.EquivalentAfterFrameworkUnification">
            <summary>
            Definition is a Framework assembly and the reference matches it after version unification.
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.AssemblyIdentity.MatchResult.EquivalentIgnoringVersion">
            <summary>
            Reference matches definition except for version (reference version is lower or higher than definition version).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Requires(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Assert(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.Assume(System.Boolean,System.String)">
             <summary>
             Equivalent to Debug.Assert.  
            
             DevDiv 867813 covers removing this completely at a future date
             </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="M:Roslyn.Compilers.VersionHelper.TryParse(System.String,System.Version@)">
            <summary>
            sets as many fields as it can.
            </summary>
            <param name="s"></param>
            <param name="version"></param>
            <returns>True when the input was entirely parsable.</returns>
        </member>
        <member name="M:Roslyn.Compilers.WellKnownMembers.IsSynthesizedAttributeOptional(Roslyn.Compilers.WellKnownMember)">
            <summary>
            This function defines whether an attribute is optional or not.
            </summary>
            <param name="attributeMember">The attribute member.</param>
        </member>
        <member name="T:Roslyn.Compilers.WellKnownType">
            <summary>
            Ids of well known runtime types.
            Values should not intersect with SpecialType enum!
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Roslyn.Compilers.WellKnownTypes.First">
            <summary>
            First well known type in WellKnownType enum
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.WellKnownTypes.Count">
            <summary>
            Number of well known types in WellKnownType enum
            </summary>
        </member>
        <member name="F:Roslyn.Compilers.WellKnownTypes.metadataNames">
            <summary>
            Array of names for types.
            The names should correspond to ids from WellKnownType enum so
            that we could use ids to index into the array
            </summary>
            <remarks></remarks>
        </member>
    </members>
</doc>
